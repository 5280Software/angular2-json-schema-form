{
  "version": 3,
  "file": "validator.functions.js",
  "sources": [
    "ng://angular2-json-schema-form/src/lib/src/shared/validator.functions.ts"
  ],
  "sourcesContent": [
    "import { AbstractControl, ValidationErrors } from '@angular/forms';\nimport { Observable } from 'rxjs-compat/Observable';\nimport { fromPromise } from 'rxjs-compat/observable/fromPromise';\nimport { toPromise } from 'rxjs-compat/operator/toPromise';\n\n/**\n * Validator utility function library:\n *\n * Validator and error utilities:\n *   _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors\n *\n * Individual value checking:\n *   isDefined, hasValue, isEmpty\n *\n * Individual type checking:\n *   isString, isNumber, isInteger, isBoolean, isFunction, isObject, isArray,\n *   isMap, isSet, isPromise, isObservable\n *\n * Multiple type checking and fixing:\n *   getType, isType, isPrimitive, toJavaScriptType, toSchemaType,\n *   _toPromise, toObservable\n *\n * Utility functions:\n *   inArray, xor\n *\n * Typescript types and interfaces:\n *   SchemaPrimitiveType, SchemaType, JavaScriptPrimitiveType, JavaScriptType,\n *   PrimitiveValue, PlainObject, IValidatorFn, AsyncIValidatorFn\n *\n * Note: 'IValidatorFn' is short for 'invertable validator function',\n *   which is a validator functions that accepts an optional second\n *   argument which, if set to TRUE, causes the validator to perform\n *   the opposite of its original function.\n */\n\nexport type SchemaPrimitiveType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null';\nexport type SchemaType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null' | 'object' | 'array';\nexport type JavaScriptPrimitiveType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined';\nexport type JavaScriptType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined' | 'object' | 'array' |\n  'map' | 'set' | 'arguments' | 'date' | 'error' | 'function' | 'json' |\n  'math' | 'regexp'; // Note: this list is incomplete\nexport type PrimitiveValue = string | number | boolean | null | undefined;\nexport interface PlainObject { [k: string]: any; }\n\nexport type IValidatorFn = (c: AbstractControl, i?: boolean) => PlainObject;\nexport type AsyncIValidatorFn = (c: AbstractControl, i?: boolean) => any;\n\n/**\n * '_executeValidators' utility function\n *\n * Validates a control against an array of validators, and returns\n * an array of the same length containing a combination of error messages\n * (from invalid validators) and null values (from valid validators)\n *\n * @param  { AbstractControl } control - control to validate\n * @param  { IValidatorFn[] } validators - array of validators\n * @param  { boolean } invert - invert?\n * @return { PlainObject[] } - array of nulls and error message\n */\nexport function _executeValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_executeAsyncValidators' utility function\n *\n * Validates a control against an array of async validators, and returns\n * an array of observabe results of the same length containing a combination of\n * error messages (from invalid validators) and null values (from valid ones)\n *\n * @param  { AbstractControl } control - control to validate\n * @param  { AsyncIValidatorFn[] } validators - array of async validators\n * @param  { boolean } invert - invert?\n * @return { any[] } - array of observable nulls and error message\n */\nexport function _executeAsyncValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_mergeObjects' utility function\n *\n * Recursively Merges one or more objects into a single object with combined keys.\n * Automatically detects and ignores null and undefined inputs.\n * Also detects duplicated boolean 'not' keys and XORs their values.\n *\n * @param  { PlainObject[] } objects - one or more objects to merge\n * @return { PlainObject } - merged object\n */\nexport function _mergeObjects(...objects) {\n  const mergedObject: PlainObject = { };\n  for (const currentObject of objects) {\n    if (isObject(currentObject)) {\n      for (const key of Object.keys(currentObject)) {\n        const currentValue = currentObject[key];\n        const mergedValue = mergedObject[key];\n        mergedObject[key] = !isDefined(mergedValue) ? currentValue :\n          key === 'not' && isBoolean(mergedValue, 'strict') &&\n            isBoolean(currentValue, 'strict') ? xor(mergedValue, currentValue) :\n          getType(mergedValue) === 'object' && getType(currentValue) === 'object' ?\n            _mergeObjects(mergedValue, currentValue) :\n            currentValue;\n      }\n    }\n  }\n  return mergedObject;\n}\n\n/**\n * '_mergeErrors' utility function\n *\n * Merges an array of objects.\n * Used for combining the validator errors returned from 'executeValidators'\n *\n * @param  { PlainObject[] } arrayOfErrors - array of objects\n * @return { PlainObject } - merged object, or null if no usable input objectcs\n */\nexport function _mergeErrors(arrayOfErrors) {\n  const mergedErrors = _mergeObjects(...arrayOfErrors);\n  return isEmpty(mergedErrors) ? null : mergedErrors;\n}\n\n/**\n * 'isDefined' utility function\n *\n * Checks if a variable contains a value of any type.\n * Returns true even for otherwise 'falsey' values of 0, '', and false.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined or null, otherwise true\n */\nexport function isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * 'hasValue' utility function\n *\n * Checks if a variable contains a value.\n * Returs false for null, undefined, or a zero-length strng, '',\n * otherwise returns true.\n * (Stricter than 'isDefined' because it also returns false for '',\n * though it stil returns true for otherwise 'falsey' values 0 and false.)\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function hasValue(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\n/**\n * 'isEmpty' utility function\n *\n * Similar to !hasValue, but also returns true for empty arrays and objects.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function isEmpty(value) {\n  if (isArray(value)) { return !value.length; }\n  if (isObject(value)) { return !Object.keys(value).length; }\n  return value === undefined || value === null || value === '';\n}\n\n/**\n * 'isString' utility function\n *\n * Checks if a value is a string.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - true if string, false if not\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * 'isNumber' utility function\n *\n * Checks if a value is a regular number, numeric string, or JavaScript Date.\n *\n * @param  { any } value - the value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return { boolean } - true if number, false if not\n */\nexport function isNumber(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) && value !== value / 0;\n}\n\n/**\n * 'isInteger' utility function\n *\n * Checks if a value is an integer.\n *\n * @param  { any } value - the value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return {boolean } - true if number, false if not\n */\nexport function isInteger(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) &&  value !== value / 0 && value % 1 === 0;\n}\n\n/**\n * 'isBoolean' utility function\n *\n * Checks if a value is a boolean.\n *\n * @param  { any } value - the value to check\n * @param  { any = null } option - if 'strict', also checks JavaScript type\n *                              if TRUE or FALSE, checks only for that value\n * @return { boolean } - true if boolean, false if not\n */\nexport function isBoolean(value, option: any = null) {\n  if (option === 'strict') { return value === true || value === false; }\n  if (option === true) {\n    return value === true || value === 1 || value === 'true' || value === '1';\n  }\n  if (option === false) {\n    return value === false || value === 0 || value === 'false' || value === '0';\n  }\n  return value === true || value === 1 || value === 'true' || value === '1' ||\n    value === false || value === 0 || value === 'false' || value === '0';\n}\n\nexport function isFunction(item: any): boolean {\n  return typeof item === 'function';\n}\n\nexport function isObject(item: any): boolean {\n  return item !== null && typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Object]';\n}\n\nexport function isArray(item: any): boolean {\n  return Array.isArray(item) ||\n    Object.prototype.toString.call(item) === '[object Array]';\n}\n\nexport function isDate(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Date]';\n}\n\nexport function isMap(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Map]';\n}\n\nexport function isSet(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Set]';\n}\n\nexport function isSymbol(item: any): boolean {\n  return typeof item === 'symbol';\n}\n\n/**\n * 'getType' function\n *\n * Detects the JSON Schema Type of a value.\n * By default, detects numbers and integers even if formatted as strings.\n * (So all integers are also numbers, and any number may also be a string.)\n * However, it only detects true boolean values (to detect boolean values\n * in non-boolean formats, use isBoolean() instead).\n *\n * If passed a second optional parameter of 'strict', it will only detect\n * numbers and integers if they are formatted as JavaScript numbers.\n *\n * Examples:\n * getType('10.5') = 'number'\n * getType(10.5) = 'number'\n * getType('10') = 'integer'\n * getType(10) = 'integer'\n * getType('true') = 'string'\n * getType(true) = 'boolean'\n * getType(null) = 'null'\n * getType({ }) = 'object'\n * getType([]) = 'array'\n *\n * getType('10.5', 'strict') = 'string'\n * getType(10.5, 'strict') = 'number'\n * getType('10', 'strict') = 'string'\n * getType(10, 'strict') = 'integer'\n * getType('true', 'strict') = 'string'\n * getType(true, 'strict') = 'boolean'\n *\n * @param  { any } value - value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return { SchemaType }\n */\nexport function getType(value, strict: any = false) {\n  if (!isDefined(value)) { return 'null'; }\n  if (isArray(value)) { return 'array'; }\n  if (isObject(value)) { return 'object'; }\n  if (isBoolean(value, 'strict')) { return 'boolean'; }\n  if (isInteger(value, strict)) { return 'integer'; }\n  if (isNumber(value, strict)) { return 'number'; }\n  if (isString(value) || (!strict && isDate(value))) { return 'string'; }\n  return null;\n}\n\n/**\n * 'isType' function\n *\n * Checks wether an input (probably string) value contains data of\n * a specified JSON Schema type\n *\n * @param  { PrimitiveValue } value - value to check\n * @param  { SchemaPrimitiveType } type - type to check\n * @return { boolean }\n */\nexport function isType(value, type) {\n  switch (type) {\n    case 'string':\n      return isString(value) || isDate(value);\n    case 'number':\n      return isNumber(value);\n    case 'integer':\n      return isInteger(value);\n    case 'boolean':\n      return isBoolean(value);\n    case 'null':\n      return !hasValue(value);\n    default:\n      console.error(`isType error: \"${type}\" is not a recognized type.`);\n      return null;\n  }\n}\n\n/**\n * 'isPrimitive' function\n *\n * Checks wether an input value is a JavaScript primitive type:\n * string, number, boolean, or null.\n *\n * @param  { any } value - value to check\n * @return { boolean }\n */\nexport function isPrimitive(value) {\n  return (isString(value) || isNumber(value) ||\n    isBoolean(value, 'strict') || value === null);\n}\n\n/**\n * 'toJavaScriptType' function\n *\n * Converts an input (probably string) value to a JavaScript primitive type -\n * 'string', 'number', 'boolean', or 'null' - before storing in a JSON object.\n *\n * Does not coerce values (other than null), and only converts the types\n * of values that would otherwise be valid.\n *\n * If the optional third parameter 'strictIntegers' is TRUE, and the\n * JSON Schema type 'integer' is specified, it also verifies the input value\n * is an integer and, if it is, returns it as a JaveScript number.\n * If 'strictIntegers' is FALSE (or not set) the type 'integer' is treated\n * exactly the same as 'number', and allows decimals.\n *\n * Valid Examples:\n * toJavaScriptType('10',   'number' ) = 10   // '10'   is a number\n * toJavaScriptType('10',   'integer') = 10   // '10'   is also an integer\n * toJavaScriptType( 10,    'integer') = 10   //  10    is still an integer\n * toJavaScriptType( 10,    'string' ) = '10' //  10    can be made into a string\n * toJavaScriptType('10.5', 'number' ) = 10.5 // '10.5' is a number\n *\n * Invalid Examples:\n * toJavaScriptType('10.5', 'integer') = null // '10.5' is not an integer\n * toJavaScriptType( 10.5,  'integer') = null //  10.5  is still not an integer\n *\n * @param  { PrimitiveValue } value - value to convert\n * @param  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - types to convert to\n * @param  { boolean = false } strictIntegers - if FALSE, treat integers as numbers\n * @return { PrimitiveValue }\n */\nexport function toJavaScriptType(value, types, strictIntegers = true)  {\n  if (!isDefined(value)) { return null; }\n  if (isString(types)) { types = [types]; }\n  if (strictIntegers && inArray('integer', types)) {\n    if (isInteger(value, 'strict')) { return value; }\n    if (isInteger(value)) { return parseInt(value, 10); }\n  }\n  if (inArray('number', types) || (!strictIntegers && inArray('integer', types))) {\n    if (isNumber(value, 'strict')) { return value; }\n    if (isNumber(value)) { return parseFloat(value); }\n  }\n  if (inArray('string', types)) {\n    if (isString(value)) { return value; }\n    // If value is a date, and types includes 'string',\n    // convert the date to a string\n    if (isDate(value)) { return value.toISOString().slice(0, 10); }\n    if (isNumber(value)) { return value.toString(); }\n  }\n  // If value is a date, and types includes 'integer' or 'number',\n  // but not 'string', convert the date to a number\n  if (isDate(value) && (inArray('integer', types) || inArray('number', types))) {\n    return value.getTime();\n  }\n  if (inArray('boolean', types)) {\n    if (isBoolean(value, true)) { return true; }\n    if (isBoolean(value, false)) { return false; }\n  }\n  return null;\n}\n\n/**\n * 'toSchemaType' function\n *\n * Converts an input (probably string) value to the \"best\" JavaScript\n * equivalent available from an allowed list of JSON Schema types, which may\n * contain 'string', 'number', 'integer', 'boolean', and/or 'null'.\n * If necssary, it does progressively agressive type coersion.\n * It will not return null unless null is in the list of allowed types.\n *\n * Number conversion examples:\n * toSchemaType('10', ['number','integer','string']) = 10 // integer\n * toSchemaType('10', ['number','string']) = 10 // number\n * toSchemaType('10', ['string']) = '10' // string\n * toSchemaType('10.5', ['number','integer','string']) = 10.5 // number\n * toSchemaType('10.5', ['integer','string']) = '10.5' // string\n * toSchemaType('10.5', ['integer']) = 10 // integer\n * toSchemaType(10.5, ['null','boolean','string']) = '10.5' // string\n * toSchemaType(10.5, ['null','boolean']) = true // boolean\n *\n * String conversion examples:\n * toSchemaType('1.5x', ['boolean','number','integer','string']) = '1.5x' // string\n * toSchemaType('1.5x', ['boolean','number','integer']) = '1.5' // number\n * toSchemaType('1.5x', ['boolean','integer']) = '1' // integer\n * toSchemaType('1.5x', ['boolean']) = true // boolean\n * toSchemaType('xyz', ['number','integer','boolean','null']) = true // boolean\n * toSchemaType('xyz', ['number','integer','null']) = null // null\n * toSchemaType('xyz', ['number','integer']) = 0 // number\n *\n * Boolean conversion examples:\n * toSchemaType('1', ['integer','number','string','boolean']) = 1 // integer\n * toSchemaType('1', ['number','string','boolean']) = 1 // number\n * toSchemaType('1', ['string','boolean']) = '1' // string\n * toSchemaType('1', ['boolean']) = true // boolean\n * toSchemaType('true', ['number','string','boolean']) = 'true' // string\n * toSchemaType('true', ['boolean']) = true // boolean\n * toSchemaType('true', ['number']) = 0 // number\n * toSchemaType(true, ['number','string','boolean']) = true // boolean\n * toSchemaType(true, ['number','string']) = 'true' // string\n * toSchemaType(true, ['number']) = 1 // number\n *\n * @param  { PrimitiveValue } value - value to convert\n * @param  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - allowed types to convert to\n * @return { PrimitiveValue }\n */\nexport function toSchemaType(value, types) {\n  if (!isArray(<SchemaPrimitiveType>types)) {\n    types = <SchemaPrimitiveType[]>[types];\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('null') && !hasValue(value)) {\n    return null;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && !isBoolean(value, 'strict')) {\n    return value;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) {\n    const testValue = toJavaScriptType(value, 'integer');\n    if (testValue !== null) { return +testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) {\n    const testValue = toJavaScriptType(value, 'number');\n    if (testValue !== null) { return +testValue; }\n  }\n  if (\n    (isString(value) || isNumber(value, 'strict')) &&\n    (<SchemaPrimitiveType[]>types).includes('string')\n  ) { // Convert number to string\n    return toJavaScriptType(value, 'string');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && isBoolean(value)) {\n    return toJavaScriptType(value, 'boolean');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('string')) { // Convert null & boolean to string\n    if (value === null) { return ''; }\n    const testValue = toJavaScriptType(value, 'string');\n    if (testValue !== null) { return testValue; }\n  }\n  if ((\n    (<SchemaPrimitiveType[]>types).includes('number') ||\n    (<SchemaPrimitiveType[]>types).includes('integer'))\n  ) {\n    if (value === true) { return 1; } // Convert boolean & null to number\n    if (value === false || value === null || value === '') { return 0; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) { // Convert mixed string to number\n    const testValue = parseFloat(<string>value);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) { // Convert string or number to integer\n    const testValue = parseInt(<string>value, 10);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean')) { // Convert anything to boolean\n    return !!value;\n  }\n  if ((\n      (<SchemaPrimitiveType[]>types).includes('number') ||\n      (<SchemaPrimitiveType[]>types).includes('integer')\n    ) && !(<SchemaPrimitiveType[]>types).includes('null')\n  ) {\n    return 0; // If null not allowed, return 0 for non-convertable values\n  }\n}\n\n/**\n * 'isPromise' function\n *\n * @param  { any } object\n * @return { boolean }\n */\nexport function isPromise(object): object is Promise<any> {\n  return !!object && typeof object.then === 'function';\n}\n\n/**\n * 'isObservable' function\n *\n * @param  { any } object\n * @return { boolean }\n */\nexport function isObservable(object): object is Observable<any> {\n  return !!object && typeof object.subscribe === 'function';\n}\n\n/**\n * '_toPromise' function\n *\n * @param  { object } object\n * @return { Promise<any> }\n */\nexport function _toPromise(object): Promise<any> {\n  return isPromise(object) ? object : toPromise.call(object);\n}\n\n/**\n * 'toObservable' function\n *\n * @param  { object } object\n * @return { Observable<any> }\n */\nexport function toObservable(object): Observable<any> {\n  const observable = isPromise(object) ? fromPromise(object) : object;\n  if (isObservable(observable)) { return observable; }\n  console.error('toObservable error: Expected validator to return Promise or Observable.');\n  return new Observable();\n}\n\n/**\n * 'inArray' function\n *\n * Searches an array for an item, or one of a list of items, and returns true\n * as soon as a match is found, or false if no match.\n *\n * If the optional third parameter allIn is set to TRUE, and the item to find\n * is an array, then the function returns true only if all elements from item\n * are found in the array list, and false if any element is not found. If the\n * item to find is not an array, setting allIn to TRUE has no effect.\n *\n * @param  { any|any[] } item - the item to search for\n * @param  { any[] } array - the array to search\n * @param  { boolean = false } allIn - if TRUE, all items must be in array\n * @return { boolean } - true if item(s) in array, false otherwise\n */\nexport function inArray(item, array, allIn = false) {\n  if (!isDefined(item) || !isArray(array)) { return false; }\n  return isArray(item) ?\n    item[allIn ? 'every' : 'some'](subItem => array.includes(subItem)) :\n    array.includes(item);\n}\n\n/**\n * 'xor' utility function - exclusive or\n *\n * Returns true if exactly one of two values is truthy.\n *\n * @param  { any } value1 - first value to check\n * @param  { any } value2 - second value to check\n * @return { boolean } - true if exactly one input value is truthy, false if not\n */\nexport function xor(value1, value2) {\n  return (!!value1 && !value2) || (!value1 && !!value2);\n}\n"
  ],
  "names": [],
  "mappings": "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"
}
