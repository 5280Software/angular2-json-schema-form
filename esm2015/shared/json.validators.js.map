{
  "version": 3,
  "file": "json.validators.js",
  "sources": [
    "ng://angular2-json-schema-form/src/lib/src/shared/json.validators.ts"
  ],
  "sourcesContent": [
    "import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\nimport { Observable } from 'rxjs-compat/Observable';\nimport { forkJoin } from 'rxjs-compat/observable/forkJoin';\nimport { map } from 'rxjs-compat/operator/map';\n\nimport * as _ from 'lodash';\n\nimport {\n  _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors,\n  isEmpty, isDefined, hasValue, isString, isNumber, isBoolean, isArray,\n  getType, isType, toJavaScriptType, toObservable, xor, SchemaPrimitiveType,\n  PlainObject, IValidatorFn, AsyncIValidatorFn\n} from './validator.functions';\nimport { forEachCopy } from './utility.functions';\nimport { jsonSchemaFormatTests, JsonSchemaFormatNames } from './format-regex.constants';\n\n/**\n * 'JsonValidators' class\n *\n * Provides an extended set of validators to be used by form controls,\n * compatible with standard JSON Schema validation options.\n * http://json-schema.org/latest/json-schema-validation.html\n *\n * Note: This library is designed as a drop-in replacement for the Angular\n * Validators library, and except for one small breaking change to the 'pattern'\n * validator (described below) it can even be imported as a substitute, like so:\n *\n *   import { JsonValidators as Validators } from 'json-validators';\n *\n * and it should work with existing code as a complete replacement.\n *\n * The one exception is the 'pattern' validator, which has been changed to\n * matche partial values by default (the standard 'pattern' validator wrapped\n * all patterns in '^' and '$', forcing them to always match an entire value).\n * However, the old behavior can be restored by simply adding '^' and '$'\n * around your patterns, or by passing an optional second parameter of TRUE.\n * This change is to make the 'pattern' validator match the behavior of a\n * JSON Schema pattern, which allows partial matches, rather than the behavior\n * of an HTML input control pattern, which does not.\n *\n * This library replaces Angular's validators and combination functions\n * with the following validators and transformation functions:\n *\n * Validators:\n *   For all formControls:     required (*), type, enum, const\n *   For text formControls:    minLength (*), maxLength (*), pattern (*), format\n *   For numeric formControls: maximum, exclusiveMaximum,\n *                             minimum, exclusiveMinimum, multipleOf\n *   For formGroup objects:    minProperties, maxProperties, dependencies\n *   For formArray arrays:     minItems, maxItems, uniqueItems, contains\n *   Not used by JSON Schema:  min (*), max (*), requiredTrue (*), email (*)\n * (Validators originally included with Angular are maked with (*).)\n *\n * NOTE / TODO: The dependencies validator is not complete.\n * NOTE / TODO: The contains validator is not complete.\n *\n * Validators not used by JSON Schema (but included for compatibility)\n * and their JSON Schema equivalents:\n *\n *   Angular validator | JSON Schema equivalent\n *   ------------------|-----------------------\n *     min(number)     |   minimum(number)\n *     max(number)     |   maximum(number)\n *     requiredTrue()  |   const(true)\n *     email()         |   format('email')\n *\n * Validator transformation functions:\n *   composeAnyOf, composeOneOf, composeAllOf, composeNot\n * (Angular's original combination funciton, 'compose', is also included for\n * backward compatibility, though it is functionally equivalent to composeAllOf,\n * asside from its more generic error message.)\n *\n * All validators have also been extended to accept an optional second argument\n * which, if passed a TRUE value, causes the validator to perform the opposite\n * of its original finction. (This is used internally to enable 'not' and\n * 'composeOneOf' to function and return useful error messages.)\n *\n * The 'required' validator has also been overloaded so that if called with\n * a boolean parameter (or no parameters) it returns the original validator\n * function (rather than executing it). However, if it is called with an\n * AbstractControl parameter (as was previously required), it behaves\n * exactly as before.\n *\n * This enables all validators (including 'required') to be constructed in\n * exactly the same way, so they can be automatically applied using the\n * equivalent key names and values taken directly from a JSON Schema.\n *\n * This source code is partially derived from Angular,\n * which is Copyright (c) 2014-2017 Google, Inc.\n * Use of this source code is therefore governed by the same MIT-style license\n * that can be found in the LICENSE file at https://angular.io/license\n *\n * Original Angular Validators:\n * https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n */\nexport class JsonValidators {\n\n  /**\n   * Validator functions:\n   *\n   * For all formControls:     required, type, enum, const\n   * For text formControls:    minLength, maxLength, pattern, format\n   * For numeric formControls: maximum, exclusiveMaximum,\n   *                           minimum, exclusiveMinimum, multipleOf\n   * For formGroup objects:    minProperties, maxProperties, dependencies\n   * For formArray arrays:     minItems, maxItems, uniqueItems, contains\n   *\n   * TODO: finish dependencies validator\n   */\n\n  /**\n   * 'required' validator\n   *\n   * This validator is overloaded, compared to the default required validator.\n   * If called with no parameters, or TRUE, this validator returns the\n   * 'required' validator function (rather than executing it). This matches\n   * the behavior of all other validators in this library.\n   *\n   * If this validator is called with an AbstractControl parameter\n   * (as was previously required) it behaves the same as Angular's default\n   * required validator, and returns an error if the control is empty.\n   *\n   * Old behavior: (if input type = AbstractControl)\n   * @param {AbstractControl} control - required control\n   * @return {{[key: string]: boolean}} - returns error message if no input\n   *\n   * New behavior: (if no input, or input type = boolean)\n   * @param {boolean = true} required? - true to validate, false to disable\n   * @return {IValidatorFn} - returns the 'required' validator function itself\n   */\n  static required(input: AbstractControl): ValidationErrors|null;\n  static required(input?: boolean): IValidatorFn;\n\n  static required(input?: AbstractControl|boolean): ValidationErrors|null|IValidatorFn {\n    if (input === undefined) { input = true; }\n    switch (input) {\n      case true: // Return required function (do not execute it yet)\n        return (control: AbstractControl, invert = false): ValidationErrors|null => {\n          if (invert) { return null; } // if not required, always return valid\n          return hasValue(control.value) ? null : { 'required': true };\n        };\n      case false: // Do nothing (if field is not required, it is always valid)\n        return JsonValidators.nullValidator;\n      default: // Execute required function\n        return hasValue((<AbstractControl>input).value) ? null : { 'required': true };\n    }\n  }\n\n  /**\n   * 'type' validator\n   *\n   * Requires a control to only accept values of a specified type,\n   * or one of an array of types.\n   *\n   * Note: SchemaPrimitiveType = 'string'|'number'|'integer'|'boolean'|'null'\n   *\n   * @param {SchemaPrimitiveType|SchemaPrimitiveType[]} type - type(s) to accept\n   * @return {IValidatorFn}\n   */\n  static type(requiredType: SchemaPrimitiveType|SchemaPrimitiveType[]): IValidatorFn {\n    if (!hasValue(requiredType)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isValid = isArray(requiredType) ?\n        (<SchemaPrimitiveType[]>requiredType).some(type => isType(currentValue, type)) :\n        isType(currentValue, <SchemaPrimitiveType>requiredType);\n      return xor(isValid, invert) ?\n        null : { 'type': { requiredType, currentValue } };\n    };\n  }\n\n  /**\n   * 'enum' validator\n   *\n   * Requires a control to have a value from an enumerated list of values.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null enum values.\n   *\n   * @param {any[]} allowedValues - array of acceptable values\n   * @return {IValidatorFn}\n   */\n  static enum(allowedValues: any[]): IValidatorFn {\n    if (!isArray(allowedValues)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqual = (enumValue, inputValue) =>\n        enumValue === inputValue ||\n        (isNumber(enumValue) && +inputValue === +enumValue) ||\n        (isBoolean(enumValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === enumValue) ||\n        (enumValue === null && !hasValue(inputValue)) ||\n        _.isEqual(enumValue, inputValue);\n      const isValid = isArray(currentValue) ?\n        currentValue.every(inputValue => allowedValues.some(enumValue =>\n          isEqual(enumValue, inputValue)\n        )) :\n        allowedValues.some(enumValue => isEqual(enumValue, currentValue));\n      return xor(isValid, invert) ?\n        null : { 'enum': { allowedValues, currentValue } };\n    };\n  }\n\n  /**\n   * 'const' validator\n   *\n   * Requires a control to have a specific value.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null values.\n   *\n   * TODO: modify to work with objects\n   *\n   * @param {any[]} requiredValue - required value\n   * @return {IValidatorFn}\n   */\n  static const(requiredValue: any): IValidatorFn {\n    if (!hasValue(requiredValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqual = (constValue, inputValue) =>\n        constValue === inputValue ||\n        isNumber(constValue) && +inputValue === +constValue ||\n        isBoolean(constValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === constValue ||\n        constValue === null && !hasValue(inputValue);\n      const isValid = isEqual(requiredValue, currentValue);\n      return xor(isValid, invert) ?\n        null : { 'const': { requiredValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minLength' validator\n   *\n   * Requires a control's text value to be greater than a specified length.\n   *\n   * @param {number} minimumLength - minimum allowed string length\n   * @param {boolean = false} invert - instead return error object only if valid\n   * @return {IValidatorFn}\n   */\n  static minLength(minimumLength: number): IValidatorFn {\n    if (!hasValue(minimumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength >= minimumLength;\n      return xor(isValid, invert) ?\n        null : { 'minLength': { minimumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'maxLength' validator\n   *\n   * Requires a control's text value to be less than a specified length.\n   *\n   * @param {number} maximumLength - maximum allowed string length\n   * @param {boolean = false} invert - instead return error object only if valid\n   * @return {IValidatorFn}\n   */\n  static maxLength(maximumLength: number): IValidatorFn {\n    if (!hasValue(maximumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength <= maximumLength;\n      return xor(isValid, invert) ?\n        null : { 'maxLength': { maximumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'pattern' validator\n   *\n   * Note: NOT the same as Angular's default pattern validator.\n   *\n   * Requires a control's value to match a specified regular expression pattern.\n   *\n   * This validator changes the behavior of default pattern validator\n   * by replacing RegExp(`^${pattern}$`) with RegExp(`${pattern}`),\n   * which allows for partial matches.\n   *\n   * To return to the default funcitonality, and match the entire string,\n   * pass TRUE as the optional second parameter.\n   *\n   * @param {string} pattern - regular expression pattern\n   * @param {boolean = false} wholeString - match whole value string?\n   * @return {IValidatorFn}\n   */\n  static pattern(pattern: string|RegExp, wholeString = false): IValidatorFn {\n    if (!hasValue(pattern)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let regex: RegExp;\n      let requiredPattern: string;\n      if (typeof pattern === 'string') {\n        requiredPattern = (wholeString) ? `^${pattern}$` : pattern;\n        regex = new RegExp(requiredPattern);\n      } else {\n        requiredPattern = pattern.toString();\n        regex = pattern;\n      }\n      const currentValue: string = control.value;\n      const isValid = isString(currentValue) ? regex.test(currentValue) : false;\n      return xor(isValid, invert) ?\n        null : { 'pattern': { requiredPattern, currentValue } };\n    };\n  }\n\n  /**\n   * 'format' validator\n   *\n   * Requires a control to have a value of a certain format.\n   *\n   * This validator currently checks the following formsts:\n   *   date, time, date-time, email, hostname, ipv4, ipv6,\n   *   uri, uri-reference, uri-template, url, uuid, color,\n   *   json-pointer, relative-json-pointer, regex\n   *\n   * Fast format regular expressions copied from AJV:\n   * https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n   *\n   * @param {JsonSchemaFormatNames} requiredFormat - format to check\n   * @return {IValidatorFn}\n   */\n  static format(requiredFormat: JsonSchemaFormatNames): IValidatorFn {\n    if (!hasValue(requiredFormat)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let isValid: boolean;\n      const currentValue: string|Date = control.value;\n      if (isString(currentValue)) {\n        const formatTest: Function|RegExp = jsonSchemaFormatTests[requiredFormat];\n        if (typeof formatTest === 'object') {\n          isValid = (<RegExp>formatTest).test(<string>currentValue);\n        } else if (typeof formatTest === 'function') {\n          isValid = (<Function>formatTest)(<string>currentValue);\n        } else {\n          console.error(`format validator error: \"${requiredFormat}\" is not a recognized format.`);\n          isValid = true;\n        }\n      } else {\n        // Allow JavaScript Date objects\n        isValid = ['date', 'time', 'date-time'].includes(requiredFormat) &&\n          Object.prototype.toString.call(currentValue) === '[object Date]';\n      }\n      return xor(isValid, invert) ?\n        null : { 'format': { requiredFormat, currentValue } };\n    };\n  }\n\n  /**\n   * 'minimum' validator\n   *\n   * Requires a control's numeric value to be greater than or equal to\n   * a minimum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a minimum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} minimum - minimum allowed value\n   * @return {IValidatorFn}\n   */\n  static minimum(minimumValue: number): IValidatorFn {\n    if (!hasValue(minimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || currentValue >= minimumValue;\n      return xor(isValid, invert) ?\n        null : { 'minimum': { minimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMinimum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} exclusiveMinimumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static exclusiveMinimum(exclusiveMinimumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMinimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMinimumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMinimum': { exclusiveMinimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'maximum' validator\n   *\n   * Requires a control's numeric value to be less than or equal to\n   * a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} maximumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static maximum(maximumValue: number): IValidatorFn {\n    if (!hasValue(maximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue <= maximumValue;\n      return xor(isValid, invert) ?\n        null : { 'maximum': { maximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMaximum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} exclusiveMaximumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static exclusiveMaximum(exclusiveMaximumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMaximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMaximumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMaximum': { exclusiveMaximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'multipleOf' validator\n   *\n   * Requires a control to have a numeric value that is a multiple\n   * of a specified number.\n   *\n   * @param {number} multipleOfValue - number value must be a multiple of\n   * @return {IValidatorFn}\n   */\n  static multipleOf(multipleOfValue: number): IValidatorFn {\n    if (!hasValue(multipleOfValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = isNumber(currentValue) &&\n        currentValue % multipleOfValue === 0;\n      return xor(isValid, invert) ?\n        null : { 'multipleOf': { multipleOfValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minProperties' validator\n   *\n   * Requires a form group to have a minimum number of properties (i.e. have\n   * values entered in a minimum number of controls within the group).\n   *\n   * @param {number} minimumProperties - minimum number of properties allowed\n   * @return {IValidatorFn}\n   */\n  static minProperties(minimumProperties: number): IValidatorFn {\n    if (!hasValue(minimumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties >= minimumProperties;\n      return xor(isValid, invert) ?\n        null : { 'minProperties': { minimumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'maxProperties' validator\n   *\n   * Requires a form group to have a maximum number of properties (i.e. have\n   * values entered in a maximum number of controls within the group).\n   *\n   * Note: Has no effect if the form group does not contain more than the\n   * maximum number of controls.\n   *\n   * @param {number} maximumProperties - maximum number of properties allowed\n   * @return {IValidatorFn}\n   */\n  static maxProperties(maximumProperties: number): IValidatorFn {\n    if (!hasValue(maximumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties <= maximumProperties;\n      return xor(isValid, invert) ?\n        null : { 'maxProperties': { maximumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'dependencies' validator\n   *\n   * Requires the controls in a form group to meet additional validation\n   * criteria, depending on the values of other controls in the group.\n   *\n   * Examples:\n   * https://spacetelescope.github.io/understanding-json-schema/reference/object.html#dependencies\n   *\n   * @param {any} dependencies - required dependencies\n   * @return {IValidatorFn}\n   */\n  static dependencies(dependencies: any): IValidatorFn {\n    if (getType(dependencies) !== 'object' || isEmpty(dependencies)) {\n      return JsonValidators.nullValidator;\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const allErrors = _mergeObjects(\n        forEachCopy(dependencies, (value, requiringField) => {\n          if (!hasValue(control.value[requiringField])) { return null; }\n          let requiringFieldErrors: ValidationErrors = { };\n          let requiredFields: string[];\n          let properties: ValidationErrors = { };\n          if (getType(dependencies[requiringField]) === 'array') {\n            requiredFields = dependencies[requiringField];\n          } else if (getType(dependencies[requiringField]) === 'object') {\n            requiredFields = dependencies[requiringField]['required'] || [];\n            properties = dependencies[requiringField]['properties'] || { };\n          }\n\n          // Validate property dependencies\n          for (const requiredField of requiredFields) {\n            if (xor(!hasValue(control.value[requiredField]), invert)) {\n              requiringFieldErrors[requiredField] = { 'required': true };\n            }\n          }\n\n          // Validate schema dependencies\n          requiringFieldErrors = _mergeObjects(requiringFieldErrors,\n            forEachCopy(properties, (requirements, requiredField) => {\n              const requiredFieldErrors = _mergeObjects(\n                forEachCopy(requirements, (requirement, parameter) => {\n                  let validator: IValidatorFn = null;\n                  if (requirement === 'maximum' || requirement === 'minimum') {\n                    const exclusive = !!requirements['exclusiveM' + requirement.slice(1)];\n                    validator = JsonValidators[requirement](parameter, exclusive);\n                  } else if (typeof JsonValidators[requirement] === 'function') {\n                    validator = JsonValidators[requirement](parameter);\n                  }\n                  return !isDefined(validator) ?\n                    null : validator(control.value[requiredField]);\n                })\n              );\n              return isEmpty(requiredFieldErrors) ?\n                null : { [requiredField]: requiredFieldErrors };\n            })\n          );\n          return isEmpty(requiringFieldErrors) ?\n            null : { [requiringField]: requiringFieldErrors };\n        })\n      );\n      return isEmpty(allErrors) ? null : allErrors;\n    };\n  }\n\n  /**\n   * 'minItems' validator\n   *\n   * Requires a form array to have a minimum number of values.\n   *\n   * @param {number} minimumItems - minimum number of items allowed\n   * @return {IValidatorFn}\n   */\n  static minItems(minimumItems: number): IValidatorFn {\n    if (!hasValue(minimumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems >= minimumItems;\n      return xor(isValid, invert) ?\n        null : { 'minItems': { minimumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'maxItems' validator\n   *\n   * Requires a form array to have a maximum number of values.\n   *\n   * @param {number} maximumItems - maximum number of items allowed\n   * @return {IValidatorFn}\n   */\n  static maxItems(maximumItems: number): IValidatorFn {\n    if (!hasValue(maximumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems <= maximumItems;\n      return xor(isValid, invert) ?\n        null : { 'maxItems': { maximumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'uniqueItems' validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param {boolean = true} unique? - true to validate, false to disable\n   * @return {IValidatorFn}\n   */\n  static uniqueItems(unique = true): IValidatorFn {\n    if (!unique) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const sorted: any[] = control.value.slice().sort();\n      const duplicateItems = [];\n      for (let i = 1; i < sorted.length; i++) {\n        if (sorted[i - 1] === sorted[i] && duplicateItems.includes(sorted[i])) {\n          duplicateItems.push(sorted[i]);\n        }\n      }\n      const isValid = !duplicateItems.length;\n      return xor(isValid, invert) ?\n        null : { 'uniqueItems': { duplicateItems } };\n    };\n  }\n\n  /**\n   * 'contains' validator\n   *\n   * TODO: Complete this validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param {boolean = true} unique? - true to validate, false to disable\n   * @return {IValidatorFn}\n   */\n  static contains(requiredItem = true): IValidatorFn {\n    if (!requiredItem) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value) || !isArray(control.value)) { return null; }\n      const currentItems = control.value;\n      // const isValid = currentItems.some(item =>\n      //\n      // );\n      const isValid = true;\n      return xor(isValid, invert) ?\n        null : { 'contains': { requiredItem, currentItems } };\n    };\n  }\n\n  /**\n   * No-op validator. Included for backward compatibility.\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null {\n    return null;\n  }\n\n  /**\n   * Validator transformation functions:\n   * composeAnyOf, composeOneOf, composeAllOf, composeNot,\n   * compose, composeAsync\n   *\n   * TODO: Add composeAnyOfAsync, composeOneOfAsync,\n   *           composeAllOfAsync, composeNotAsync\n   */\n\n  /**\n   * 'composeAnyOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid if any one or more of the submitted validators are\n   * valid. If every validator is invalid, it returns combined errors from\n   * all validators.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeAnyOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators, invert).filter(isDefined);\n      const isValid = validators.length > arrayOfErrors.length;\n      return xor(isValid, invert) ?\n        null : _mergeObjects(...arrayOfErrors, { 'anyOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeOneOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if exactly one of the submitted validators\n   * is valid. Otherwise returns combined information from all validators,\n   * both valid and invalid.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeOneOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators);\n      const validControls =\n        validators.length - arrayOfErrors.filter(isDefined).length;\n      const isValid = validControls === 1;\n      if (xor(isValid, invert)) { return null; }\n      const arrayOfValids =\n        _executeValidators(control, presentValidators, invert);\n      return _mergeObjects(...arrayOfErrors, ...arrayOfValids, { 'oneOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeAllOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if all the submitted validators are individually\n   * valid. Otherwise it returns combined errors from all invalid validators.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeAllOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const combinedErrors = _mergeErrors(\n        _executeValidators(control, presentValidators, invert)\n      );\n      const isValid = combinedErrors === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(combinedErrors, { 'allOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeNot' validator inversion function\n   *\n   * Accepts a single validator function and inverts its result.\n   * Returns valid if the submitted validator is invalid, and\n   * returns invalid if the submitted validator is valid.\n   * (Note: this function can itself be inverted\n   *   - e.g. composeNot(composeNot(validator)) -\n   *   but this can be confusing and is therefore not recommended.)\n   *\n   * @param {IValidatorFn[]} validators - validator(s) to invert\n   * @return {IValidatorFn} - new validator function that returns opposite result\n   */\n  static composeNot(validator: IValidatorFn): IValidatorFn {\n    if (!validator) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const error = validator(control, !invert);\n      const isValid = error === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(error, { 'not': !invert });\n    };\n  }\n\n  /**\n   * 'compose' validator combination function\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static compose(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null =>\n      _mergeErrors(_executeValidators(control, presentValidators, invert));\n  }\n\n  /**\n   * 'composeAsync' async validator combination function\n   *\n   * @param {AsyncIValidatorFn[]} async validators - array of async validators\n   * @return {AsyncIValidatorFn} - single combined async validator function\n   */\n  static composeAsync(validators: AsyncIValidatorFn[]): AsyncIValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl) => {\n      const observables =\n        _executeAsyncValidators(control, presentValidators).map(toObservable);\n      return map.call(forkJoin(observables), _mergeErrors);\n    };\n  }\n\n  // Additional angular validators (not used by Angualr JSON Schema Form)\n  // From https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   */\n  static min(min: number): ValidatorFn {\n    if (!hasValue(min)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(min)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return isNaN(value) || value >= min ? null : { 'min': { min, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   */\n  static max(max: number): ValidatorFn {\n    if (!hasValue(max)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(max)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return isNaN(value) || value <= max ? null : { 'max': { max, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    return control.value === true ? null : { 'required': true };\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    const EMAIL_REGEXP =\n      // tslint:disable-next-line max-line-length\n      /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n    return EMAIL_REGEXP.test(control.value) ? null : { 'email': true };\n  }\n}\n"
  ],
  "names": [],
  "mappings": "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"
}
