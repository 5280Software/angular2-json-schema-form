{
  "version": 3,
  "file": "merge-schemas.function.js",
  "sources": [
    "ng://angular2-json-schema-form/src/lib/src/shared/merge-schemas.function.ts"
  ],
  "sourcesContent": [
    "import * as _ from 'lodash';\n\nimport {\n  isArray, isEmpty, isNumber, isObject, isString\n} from './validator.functions';\nimport { hasOwn, uniqueItems, commonItems } from './utility.functions';\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\n\n/**\n * 'mergeSchemas' function\n *\n * Merges multiple JSON schemas into a single schema with combined rules.\n *\n * If able to logically merge properties from all schemas,\n * returns a single schema object containing all merged properties.\n *\n * Example: ({ a: b, max: 1 }, { c: d, max: 2 }) => { a: b, c: d, max: 1 }\n *\n * If unable to logically merge, returns an allOf schema object containing\n * an array of the original schemas;\n *\n * Example: ({ a: b }, { a: d }) => { allOf: [ { a: b }, { a: d } ] }\n *\n * @param  { any } schemas - one or more input schemas\n * @return { any } - merged schema\n */\nexport function mergeSchemas(...schemas) {\n  schemas = schemas.filter(schema => !isEmpty(schema));\n  if (schemas.some(schema => !isObject(schema))) { return null; }\n  const combinedSchema: any = {};\n  for (const schema of schemas) {\n    for (const key of Object.keys(schema)) {\n      const combinedValue = combinedSchema[key];\n      const schemaValue = schema[key];\n      if (!hasOwn(combinedSchema, key) || _.isEqual(combinedValue, schemaValue)) {\n        combinedSchema[key] = schemaValue;\n      } else {\n        switch (key) {\n          case 'allOf':\n            // Combine all items from both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.allOf = mergeSchemas(...combinedValue, ...schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'additionalItems': case 'additionalProperties':\n          case 'contains': case 'propertyNames':\n            // Merge schema objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema[key] = mergeSchemas(combinedValue, schemaValue);\n            // additionalProperties == false in any schema overrides all other values\n            } else if (\n              key === 'additionalProperties' &&\n              (combinedValue === false || schemaValue === false)\n            ) {\n              combinedSchema.combinedSchema = false;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'anyOf': case 'oneOf': case 'enum':\n            // Keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema[key] = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema[key].length) { return { allOf: [ ...schemas ] }; }\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'definitions':\n            // Combine keys from both objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // Don't combine matching keys with different values\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.definitions = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'dependencies':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys,\n            // converting from arrays to objects if necessary\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are arrays, include all items from both arrays,\n                // excluding duplicates\n                } else if (\n                  isArray(schemaValue[subKey]) && isArray(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    uniqueItems(...combinedObject[subKey], ...schemaValue[subKey]);\n                // If either key is an object, merge the schemas\n                } else if (\n                  (isArray(schemaValue[subKey]) || isObject(schemaValue[subKey])) &&\n                  (isArray(combinedObject[subKey]) || isObject(combinedObject[subKey]))\n                ) {\n                  // If either key is an array, convert it to an object first\n                  const required = isArray(combinedSchema.required) ?\n                    combinedSchema.required : [];\n                  const combinedDependency = isArray(combinedObject[subKey]) ?\n                    { required: uniqueItems(...required, combinedObject[subKey]) } :\n                    combinedObject[subKey];\n                  const schemaDependency = isArray(schemaValue[subKey]) ?\n                    { required: uniqueItems(...required, schemaValue[subKey]) } :\n                    schemaValue[subKey];\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedDependency, schemaDependency);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.dependencies = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'items':\n            // If arrays, keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema.items.length) { return { allOf: [ ...schemas ] }; }\n            // If both keys are objects, merge them\n            } else if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items = mergeSchemas(combinedValue, schemaValue);\n            // If object + array, combine object with each array item\n            } else if (isArray(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items =\n                combinedValue.map(item => mergeSchemas(item, schemaValue));\n            } else if (isObject(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items =\n                schemaValue.map(item => mergeSchemas(item, combinedValue));\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'multipleOf':\n            // TODO: Adjust to correctly handle decimal values\n            // If numbers, set to least common multiple\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              const gcd = (x, y) => !y ? x : gcd(y, x % y);\n              const lcm = (x, y) => (x * y) / gcd(x, y);\n              combinedSchema.multipleOf = lcm(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'maximum': case 'exclusiveMaximum': case 'maxLength':\n          case 'maxItems': case 'maxProperties':\n            // If numbers, set to lowest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.min(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'minimum': case 'exclusiveMinimum': case 'minLength':\n          case 'minItems': case 'minProperties':\n            // If numbers, set to highest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.max(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'not':\n            // Combine not values into anyOf array\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const notAnyOf = [combinedValue, schemaValue]\n                .reduce((notAnyOfArray, notSchema) =>\n                  isArray(notSchema.anyOf) &&\n                  Object.keys(notSchema).length === 1 ?\n                    [ ...notAnyOfArray, ...notSchema.anyOf ] :\n                    [ ...notAnyOfArray, notSchema ]\n                , []);\n              // TODO: Remove duplicate items from array\n              combinedSchema.not = { anyOf: notAnyOf };\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'patternProperties':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) && isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.patternProperties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'properties':\n            // Combine all keys from both objects\n            // unless additionalProperties === false\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              // If new schema has additionalProperties,\n              // merge or remove non-matching property keys in combined schema\n              if (hasOwn(schemaValue, 'additionalProperties')) {\n                Object.keys(combinedValue)\n                  .filter(combinedKey => !Object.keys(schemaValue).includes(combinedKey))\n                  .forEach(nonMatchingKey => {\n                    if (schemaValue.additionalProperties === false) {\n                      delete combinedObject[nonMatchingKey];\n                    } else if (isObject(schemaValue.additionalProperties)) {\n                      combinedObject[nonMatchingKey] = mergeSchemas(\n                        combinedObject[nonMatchingKey],\n                        schemaValue.additionalProperties\n                      );\n                    }\n                  });\n              }\n              for (const subKey of Object.keys(schemaValue)) {\n                if (_.isEqual(combinedObject[subKey], schemaValue[subKey]) || (\n                  !hasOwn(combinedObject, subKey) &&\n                  !hasOwn(combinedObject, 'additionalProperties')\n                )) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If combined schema has additionalProperties,\n                // merge or ignore non-matching property keys in new schema\n                } else if (\n                  !hasOwn(combinedObject, subKey) &&\n                  hasOwn(combinedObject, 'additionalProperties')\n                ) {\n                  // If combinedObject.additionalProperties === false,\n                  // do nothing (don't set key)\n                  // If additionalProperties is object, merge with new key\n                  if (isObject(combinedObject.additionalProperties)) {\n                    combinedObject[subKey] = mergeSchemas(\n                      combinedObject.additionalProperties, schemaValue[subKey]\n                    );\n                  }\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) &&\n                  isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.properties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'required':\n            // If arrays, include all items from both arrays, excluding duplicates\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.required = uniqueItems(...combinedValue, ...schemaValue);\n            // If booleans, aet true if either true\n            } else if (\n              typeof schemaValue === 'boolean' &&\n              typeof combinedValue === 'boolean'\n            ) {\n              combinedSchema.required = !!combinedValue || !!schemaValue;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case '$schema': case '$id': case 'id':\n            // Don't combine these keys\n          break;\n          case 'title': case 'description':\n            // Return the last value, overwriting any previous one\n            // These properties are not used for validation, so conflicts don't matter\n            combinedSchema[key] = schemaValue;\n          break;\n          case 'type':\n            if (\n              (isArray(schemaValue) || isString(schemaValue)) &&\n              (isArray(combinedValue) || isString(combinedValue))\n            ) {\n              const combinedTypes = commonItems(combinedValue, schemaValue);\n              if (!combinedTypes.length) { return { allOf: [ ...schemas ] }; }\n              combinedSchema.type = combinedTypes.length > 1 ? combinedTypes : combinedTypes[0];\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'uniqueItems':\n            // Set true if either true\n            combinedSchema.uniqueItems = !!combinedValue || !!schemaValue;\n          break;\n          default:\n            return { allOf: [ ...schemas ] };\n        }\n      }\n    }\n  }\n  return combinedSchema;\n}\n"
  ],
  "names": [],
  "mappings": "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"
}
