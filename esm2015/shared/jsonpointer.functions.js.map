{
  "version": 3,
  "file": "jsonpointer.functions.js",
  "sources": [
    "ng://angular2-json-schema-form/src/lib/src/shared/jsonpointer.functions.ts"
  ],
  "sourcesContent": [
    "import { Injectable } from '@angular/core';\n\nimport {\n  isDefined, isEmpty, isObject, isArray, isMap, isNumber, isString\n} from './validator.functions';\nimport { hasOwn, copy } from './utility.functions';\n\n/**\n * 'JsonPointer' class\n *\n * Some utilities for using JSON Pointers with JSON objects\n * https://tools.ietf.org/html/rfc6901\n *\n * get, getCopy, getFirst, set, setCopy, insert, insertCopy, remove, has, dict,\n * forEachDeep, forEachDeepCopy, escape, unescape, parse, compile, toKey,\n * isJsonPointer, isSubPointer, toIndexedPointer, toGenericPointer,\n * toControlPointer, toSchemaPointer, toDataPointer, parseObjectPath\n *\n * Some functions based on manuelstofer's json-pointer utilities\n * https://github.com/manuelstofer/json-pointer\n */\nexport type Pointer = string | string[];\n\n@Injectable()\nexport class JsonPointer {\n\n  /**\n   * 'get' function\n   *\n   * Uses a JSON Pointer to retrieve a value from an object.\n   *\n   * @param  { object } object - Object to get value from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * @param  { number } endSlice - Zero-based index of last Pointer key to use\n   * @param  { boolean = false } getBoolean - Return only true or false?\n   * @param  { boolean = false } errors - Show error if not found?\n   * @return { object } - Located value (or true or false if getBoolean = true)\n   */\n  static get(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    if (object === null) { return getBoolean ? false : undefined; }\n    let keyArray: any[] = this.parse(pointer, errors);\n    if (typeof object === 'object' && keyArray !== null) {\n      let subObject = object;\n      if (startSlice >= keyArray.length || endSlice <= -keyArray.length) { return object; }\n      if (startSlice <= -keyArray.length) { startSlice = 0; }\n      if (!isDefined(endSlice) || endSlice >= keyArray.length) { endSlice = keyArray.length; }\n      keyArray = keyArray.slice(startSlice, endSlice);\n      for (let key of keyArray) {\n        if (key === '-' && isArray(subObject) && subObject.length) {\n          key = subObject.length - 1;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else if (typeof subObject === 'object' && subObject !== null &&\n          hasOwn(subObject, key)\n        ) {\n          subObject = subObject[key];\n        } else {\n          if (errors) {\n            console.error(`get error: \"${key}\" key not found in object.`);\n            console.error(pointer);\n            console.error(object);\n          }\n          return getBoolean ? false : undefined;\n        }\n      }\n      return getBoolean ? true : subObject;\n    }\n    if (errors && keyArray === null) {\n      console.error(`get error: Invalid JSON Pointer: ${pointer}`);\n    }\n    if (errors && typeof object !== 'object') {\n      console.error('get error: Invalid object:');\n      console.error(object);\n    }\n    return getBoolean ? false : undefined;\n  }\n\n  /**\n   * 'getCopy' function\n   *\n   * Uses a JSON Pointer to deeply clone a value from an object.\n   *\n   * @param  { object } object - Object to get value from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * @param  { number } endSlice - Zero-based index of last Pointer key to use\n   * @param  { boolean = false } getBoolean - Return only true or false?\n   * @param  { boolean = false } errors - Show error if not found?\n   * @return { object } - Located value (or true or false if getBoolean = true)\n   */\n  static getCopy(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    const objectToCopy =\n      this.get(object, pointer, startSlice, endSlice, getBoolean, errors);\n    return this.forEachDeepCopy(objectToCopy);\n  }\n\n  /**\n   * 'getFirst' function\n   *\n   * Takes an array of JSON Pointers and objects,\n   * checks each object for a value specified by the pointer,\n   * and returns the first value found.\n   *\n   * @param  { [object, pointer][] } items - Array of objects and pointers to check\n   * @param  { any = null } defaultValue - Value to return if nothing found\n   * @param  { boolean = false } getCopy - Return a copy instead?\n   * @return { any } - First value found\n   */\n  static getFirst(items, defaultValue: any = null, getCopy = false) {\n    if (isEmpty(items)) { return; }\n    if (isArray(items)) {\n      for (const item of items) {\n        if (isEmpty(item)) { continue; }\n        if (isArray(item) && item.length >= 2) {\n          if (isEmpty(item[0]) || isEmpty(item[1])) { continue; }\n          const value = getCopy ?\n            this.getCopy(item[0], item[1]) :\n            this.get(item[0], item[1]);\n          if (value) { return value; }\n          continue;\n        }\n        console.error('getFirst error: Input not in correct format.\\n' +\n          'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n        return;\n      }\n      return defaultValue;\n    }\n    if (isMap(items)) {\n      for (const [object, pointer] of items) {\n        if (object === null || !this.isJsonPointer(pointer)) { continue; }\n        const value = getCopy ?\n          this.getCopy(object, pointer) :\n          this.get(object, pointer);\n        if (value) { return value; }\n      }\n      return defaultValue;\n    }\n    console.error('getFirst error: Input not in correct format.\\n' +\n      'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n    return defaultValue;\n  }\n\n  /**\n   * 'getFirstCopy' function\n   *\n   * Similar to getFirst, but always returns a copy.\n   *\n   * @param  { [object, pointer][] } items - Array of objects and pointers to check\n   * @param  { any = null } defaultValue - Value to return if nothing found\n   * @return { any } - Copy of first value found\n   */\n  static getFirstCopy(items, defaultValue: any = null) {\n    const firstCopy = this.getFirst(items, defaultValue, true);\n    return firstCopy;\n  }\n\n  /**\n   * 'set' function\n   *\n   * Uses a JSON Pointer to set a value on an object.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing\n   * value (if any) at that location.\n   *\n   * So set([1, 2, 3], '/1', 4) => [1, 4, 3]\n   * and\n   * So set([1, 2, 3], '/1', 4, true) => [1, 4, 2, 3]\n   *\n   * @param  { object } object - The object to set value in\n   * @param  { Pointer } pointer - The JSON Pointer (string or array)\n   * @param  { any } value - The new value to set\n   * @param  { boolean } insert - insert value?\n   * @return { object } - The original object, modified with the set value\n   */\n  static set(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let subObject = object;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return object;\n    }\n    console.error(`set error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'setCopy' function\n   *\n   * Copies an object and uses a JSON Pointer to set a value on the copy.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing value.\n   *\n   * @param  { object } object - The object to copy and set value in\n   * @param  { Pointer } pointer - The JSON Pointer (string or array)\n   * @param  { any } value - The value to set\n   * @param  { boolean } insert - insert value?\n   * @return { object } - The new object with the set value\n   */\n  static setCopy(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null) {\n      const newObject = copy(object);\n      let subObject = newObject;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject.set(key, copy(subObject.get(key)));\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject[key] = copy(subObject[key]);\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return newObject;\n    }\n    console.error(`setCopy error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'insert' function\n   *\n   * Calls 'set' with insert = TRUE\n   *\n   * @param  { object } object - object to insert value in\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { any } value - value to insert\n   * @return { object }\n   */\n  static insert(object, pointer, value) {\n    const updatedObject = this.set(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'insertCopy' function\n   *\n   * Calls 'setCopy' with insert = TRUE\n   *\n   * @param  { object } object - object to insert value in\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { any } value - value to insert\n   * @return { object }\n   */\n  static insertCopy(object, pointer, value) {\n    const updatedObject = this.setCopy(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'remove' function\n   *\n   * Uses a JSON Pointer to remove a key and its attribute from an object\n   *\n   * @param  { object } object - object to delete attribute from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @return { object }\n   */\n  static remove(object, pointer) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let lastKey = keyArray.pop();\n      const parentObject = this.get(object, keyArray);\n      if (isArray(parentObject)) {\n        if (lastKey === '-') { lastKey = parentObject.length - 1; }\n        parentObject.splice(lastKey, 1);\n      } else if (isObject(parentObject)) {\n        delete parentObject[lastKey];\n      }\n      return object;\n    }\n    console.error(`remove error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'has' function\n   *\n   * Tests if an object has a value at the location specified by a JSON Pointer\n   *\n   * @param  { object } object - object to chek for value\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @return { boolean }\n   */\n  static has(object, pointer) {\n    const hasValue = this.get(object, pointer, 0, null, true);\n    return hasValue;\n  }\n\n  /**\n   * 'dict' function\n   *\n   * Returns a (pointer -> value) dictionary for an object\n   *\n   * @param  { object } object - The object to create a dictionary from\n   * @return { object } - The resulting dictionary object\n   */\n  static dict(object) {\n    const results: any = {};\n    this.forEachDeep(object, (value, pointer) => {\n      if (typeof value !== 'object') { results[pointer] = value; }\n    });\n    return results;\n  }\n\n  /**\n   * 'forEachDeep' function\n   *\n   * Iterates over own enumerable properties of an object or items in an array\n   * and invokes an iteratee function for each key/value or index/value pair.\n   * By default, iterates over items within objects and arrays after calling\n   * the iteratee function on the containing object or array itself.\n   *\n   * The iteratee is invoked with three arguments: (value, pointer, rootObject),\n   * where pointer is a JSON pointer indicating the location of the current\n   * value within the root object, and rootObject is the root object initially\n   * submitted to th function.\n   *\n   * If a third optional parameter 'bottomUp' is set to TRUE, the iterator\n   * function will be called on sub-objects and arrays after being\n   * called on their contents, rather than before, which is the default.\n   *\n   * This function can also optionally be called directly on a sub-object by\n   * including optional 4th and 5th parameterss to specify the initial\n   * root object and pointer.\n   *\n   * @param  { object } object - the initial object or array\n   * @param  { (v: any, p?: string, o?: any) => any } function - iteratee function\n   * @param  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * @param  { object = object } rootObject - optional, root object or array\n   * @param  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * @return { object } - The modified object\n   */\n  static forEachDeep(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeep error: Iterator is not a function:`, fn);\n      return;\n    }\n    if (!bottomUp) { fn(object, pointer, rootObject); }\n    if (isObject(object) || isArray(object)) {\n      for (const key of Object.keys(object)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        this.forEachDeep(object[key], fn, bottomUp, newPointer, rootObject);\n      }\n    }\n    if (bottomUp) { fn(object, pointer, rootObject); }\n  }\n\n  /**\n   * 'forEachDeepCopy' function\n   *\n   * Similar to forEachDeep, but returns a copy of the original object, with\n   * the same keys and indexes, but with values replaced with the result of\n   * the iteratee function.\n   *\n   * @param  { object } object - the initial object or array\n   * @param  { (v: any, k?: string, o?: any, p?: any) => any } function - iteratee function\n   * @param  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * @param  { object = object } rootObject - optional, root object or array\n   * @param  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * @return { object } - The copied object\n   */\n  static forEachDeepCopy(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeepCopy error: Iterator is not a function:`, fn);\n      return null;\n    }\n    if (isObject(object) || isArray(object)) {\n      let newObject = isArray(object) ? [ ...object ] : { ...object };\n      if (!bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      for (const key of Object.keys(newObject)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        newObject[key] = this.forEachDeepCopy(\n          newObject[key], fn, bottomUp, newPointer, rootObject\n        );\n      }\n      if (bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      return newObject;\n    } else {\n      return fn(object, pointer, rootObject);\n    }\n  }\n\n  /**\n   * 'escape' function\n   *\n   * Escapes a string reference key\n   *\n   * @param  { string } key - string key to escape\n   * @return { string } - escaped key\n   */\n  static escape(key) {\n    const escaped = key.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n    return escaped;\n  }\n\n  /**\n   * 'unescape' function\n   *\n   * Unescapes a string reference key\n   *\n   * @param  { string } key - string key to unescape\n   * @return { string } - unescaped key\n   */\n  static unescape(key) {\n    const unescaped = key.toString().replace(/~1/g, '/').replace(/~0/g, '~');\n    return unescaped;\n  }\n\n  /**\n   * 'parse' function\n   *\n   * Converts a string JSON Pointer into a array of keys\n   * (if input is already an an array of keys, it is returned unchanged)\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string[] } - JSON Pointer array of keys\n   */\n  static parse(pointer, errors = false) {\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`parse error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) { return <string[]>pointer; }\n    if (typeof pointer === 'string') {\n      if ((<string>pointer)[0] === '#') { pointer = pointer.slice(1); }\n      if (<string>pointer === '' || <string>pointer === '/') { return []; }\n      return (<string>pointer).slice(1).split('/').map(this.unescape);\n    }\n  }\n\n  /**\n   * 'compile' function\n   *\n   * Converts an array of keys into a JSON Pointer string\n   * (if input is already a string, it is normalized and returned)\n   *\n   * The optional second parameter is a default which will replace any empty keys.\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { string | number = '' } defaultValue - Default value\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string } - JSON Pointer string\n   */\n  static compile(pointer, defaultValue = '', errors = false) {\n    if (pointer === '#') { return ''; }\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`compile error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) {\n      if ((<string[]>pointer).length === 0) { return ''; }\n      return '/' + (<string[]>pointer).map(\n        key => key === '' ? defaultValue : this.escape(key)\n      ).join('/');\n    }\n    if (typeof pointer === 'string') {\n      if (pointer[0] === '#') { pointer = pointer.slice(1); }\n      return pointer;\n    }\n  }\n\n  /**\n   * 'toKey' function\n   *\n   * Extracts name of the final key from a JSON Pointer.\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string } - the extracted key\n   */\n  static toKey(pointer, errors = false) {\n    const keyArray = this.parse(pointer, errors);\n    if (keyArray === null) { return null; }\n    if (!keyArray.length) { return ''; }\n    return keyArray[keyArray.length - 1];\n  }\n\n  /**\n   * 'isJsonPointer' function\n   *\n   * Checks a string or array value to determine if it is a valid JSON Pointer.\n   * Returns true if a string is empty, or starts with '/' or '#/'.\n   * Returns true if an array contains only string values.\n   *\n   * @param  { any } value - value to check\n   * @return { boolean } - true if value is a valid JSON Pointer, otherwise false\n   */\n  static isJsonPointer(value) {\n    if (isArray(value)) {\n      return value.every(key => typeof key === 'string');\n    } else if (isString(value)) {\n      if (value === '' || value === '#') { return true; }\n      if (value[0] === '/' || value.slice(0, 2) === '#/') {\n        return !/(~[^01]|~$)/g.test(value);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * 'isSubPointer' function\n   *\n   * Checks whether one JSON Pointer is a subset of another.\n   *\n   * @param  { Pointer } shortPointer - potential subset JSON Pointer\n   * @param  { Pointer } longPointer - potential superset JSON Pointer\n   * @param  { boolean = false } trueIfMatching - return true if pointers match?\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { boolean } - true if shortPointer is a subset of longPointer, false if not\n   */\n  static isSubPointer(\n    shortPointer, longPointer, trueIfMatching = false, errors = false\n  ) {\n    if (!this.isJsonPointer(shortPointer) || !this.isJsonPointer(longPointer)) {\n      if (errors) {\n        let invalid = '';\n        if (!this.isJsonPointer(shortPointer)) { invalid += ` 1: ${shortPointer}`; }\n        if (!this.isJsonPointer(longPointer)) { invalid += ` 2: ${longPointer}`; }\n        console.error(`isSubPointer error: Invalid JSON Pointer ${invalid}`);\n      }\n      return;\n    }\n    shortPointer = this.compile(shortPointer, '', errors);\n    longPointer = this.compile(longPointer, '', errors);\n    return shortPointer === longPointer ? trueIfMatching :\n      `${shortPointer}/` === longPointer.slice(0, shortPointer.length + 1);\n  }\n\n  /**\n   * 'toIndexedPointer' function\n   *\n   * Merges an array of numeric indexes and a generic pointer to create an\n   * indexed pointer for a specific item.\n   *\n   * For example, merging the generic pointer '/foo/-/bar/-/baz' and\n   * the array [4, 2] would result in the indexed pointer '/foo/4/bar/2/baz'\n   *\n   * @function\n   * @param  { Pointer } genericPointer - The generic pointer\n   * @param  { number[] } indexArray - The array of numeric indexes\n   * @param  { Map<string, number> } arrayMap - An optional array map\n   * @return { string } - The merged pointer with indexes\n   */\n  static toIndexedPointer(\n    genericPointer, indexArray, arrayMap: Map<string, number> = null\n  ) {\n    if (this.isJsonPointer(genericPointer) && isArray(indexArray)) {\n      let indexedPointer = this.compile(genericPointer);\n      if (isMap(arrayMap)) {\n        let arrayIndex = 0;\n        return indexedPointer.replace(/\\/\\-(?=\\/|$)/g, (key, stringIndex) =>\n          arrayMap.has((<string>indexedPointer).slice(0, stringIndex)) ?\n            '/' + indexArray[arrayIndex++] : key\n        );\n      } else {\n        for (const pointerIndex of indexArray) {\n          indexedPointer = indexedPointer.replace('/-', '/' + pointerIndex);\n        }\n        return indexedPointer;\n      }\n    }\n    if (!this.isJsonPointer(genericPointer)) {\n      console.error(`toIndexedPointer error: Invalid JSON Pointer: ${genericPointer}`);\n    }\n    if (!isArray(indexArray)) {\n      console.error(`toIndexedPointer error: Invalid indexArray: ${indexArray}`);\n    }\n  }\n\n  /**\n   * 'toGenericPointer' function\n   *\n   * Compares an indexed pointer to an array map and removes list array\n   * indexes (but leaves tuple arrray indexes and all object keys, including\n   * numeric keys) to create a generic pointer.\n   *\n   * For example, using the indexed pointer '/foo/1/bar/2/baz/3' and\n   * the arrayMap [['/foo', 0], ['/foo/-/bar', 3], ['/foo/-/bar/-/baz', 0]]\n   * would result in the generic pointer '/foo/-/bar/2/baz/-'\n   * Using the indexed pointer '/foo/1/bar/4/baz/3' and the same arrayMap\n   * would result in the generic pointer '/foo/-/bar/-/baz/-'\n   * (the bar array has 3 tuple items, so index 2 is retained, but 4 is removed)\n   *\n   * The structure of the arrayMap is: [['path to array', number of tuple items]...]\n   *\n   * @function\n   * @param  { Pointer } indexedPointer - The indexed pointer (array or string)\n   * @param  { Map<string, number> } arrayMap - The optional array map (for preserving tuple indexes)\n   * @return { string } - The generic pointer with indexes removed\n   */\n  static toGenericPointer(indexedPointer, arrayMap = new Map<string, number>()) {\n    if (this.isJsonPointer(indexedPointer) && isMap(arrayMap)) {\n      const pointerArray = this.parse(indexedPointer);\n      for (let i = 1; i < pointerArray.length; i++) {\n        const subPointer = this.compile(pointerArray.slice(0, i));\n        if (arrayMap.has(subPointer) &&\n          arrayMap.get(subPointer) <= +pointerArray[i]\n        ) {\n          pointerArray[i] = '-';\n        }\n      }\n      return this.compile(pointerArray);\n    }\n    if (!this.isJsonPointer(indexedPointer)) {\n      console.error(`toGenericPointer error: invalid JSON Pointer: ${indexedPointer}`);\n    }\n    if (!isMap(arrayMap)) {\n      console.error(`toGenericPointer error: invalid arrayMap: ${arrayMap}`);\n    }\n  }\n\n  /**\n   * 'toControlPointer' function\n   *\n   * Accepts a JSON Pointer for a data object and returns a JSON Pointer for the\n   * matching control in an Angular FormGroup.\n   *\n   * @param  { Pointer } dataPointer - JSON Pointer (string or array) to a data object\n   * @param  { FormGroup } formGroup - Angular FormGroup to get value from\n   * @param  { boolean = false } controlMustExist - Only return if control exists?\n   * @return { Pointer } - JSON Pointer (string) to the formGroup object\n   */\n  static toControlPointer(dataPointer, formGroup, controlMustExist = false) {\n    const dataPointerArray = this.parse(dataPointer);\n    const controlPointerArray: string[] = [];\n    let subGroup = formGroup;\n    if (dataPointerArray !== null) {\n      for (const key of dataPointerArray) {\n        if (hasOwn(subGroup, 'controls')) {\n          controlPointerArray.push('controls');\n          subGroup = subGroup.controls;\n        }\n        if (isArray(subGroup) && (key === '-')) {\n          controlPointerArray.push((subGroup.length - 1).toString());\n          subGroup = subGroup[subGroup.length - 1];\n        } else if (hasOwn(subGroup, key)) {\n          controlPointerArray.push(key);\n          subGroup = subGroup[key];\n        } else if (controlMustExist) {\n          console.error(`toControlPointer error: Unable to find \"${key}\" item in FormGroup.`);\n          console.error(dataPointer);\n          console.error(formGroup);\n          return;\n        } else {\n          controlPointerArray.push(key);\n          subGroup = { controls: {} };\n        }\n      }\n      return this.compile(controlPointerArray);\n    }\n    console.error(`toControlPointer error: Invalid JSON Pointer: ${dataPointer}`);\n  }\n\n  /**\n   * 'toSchemaPointer' function\n   *\n   * Accepts a JSON Pointer to a value inside a data object and a JSON schema\n   * for that object.\n   *\n   * Returns a Pointer to the sub-schema for the value inside the object's schema.\n   *\n   * @param  { Pointer } dataPointer - JSON Pointer (string or array) to an object\n   * @param  { any } schema - JSON schema for the object\n   * @return { Pointer } - JSON Pointer (string) to the object's schema\n   */\n  static toSchemaPointer(dataPointer, schema) {\n    if (this.isJsonPointer(dataPointer) && typeof schema === 'object') {\n      const pointerArray = this.parse(dataPointer);\n      if (!pointerArray.length) { return ''; }\n      const firstKey = pointerArray.shift();\n      if (schema.type === 'object' || schema.properties || schema.additionalProperties) {\n        if ((schema.properties || {})[firstKey]) {\n          return `/properties/${this.escape(firstKey)}` +\n            this.toSchemaPointer(pointerArray, schema.properties[firstKey]);\n        } else  if (schema.additionalProperties) {\n          return '/additionalProperties' +\n            this.toSchemaPointer(pointerArray, schema.additionalProperties);\n        }\n      }\n      if ((schema.type === 'array' || schema.items) &&\n        (isNumber(firstKey) || firstKey === '-' || firstKey === '')\n      ) {\n        const arrayItem = firstKey === '-' || firstKey === '' ? 0 : +firstKey;\n        if (isArray(schema.items)) {\n          if (arrayItem < schema.items.length) {\n            return '/items/' + arrayItem +\n              this.toSchemaPointer(pointerArray, schema.items[arrayItem]);\n          } else if (schema.additionalItems) {\n            return '/additionalItems' +\n              this.toSchemaPointer(pointerArray, schema.additionalItems);\n          }\n        } else if (isObject(schema.items)) {\n          return '/items' + this.toSchemaPointer(pointerArray, schema.items);\n        } else if (isObject(schema.additionalItems)) {\n          return '/additionalItems' +\n            this.toSchemaPointer(pointerArray, schema.additionalItems);\n        }\n      }\n      console.error(`toSchemaPointer error: Data pointer ${dataPointer} ` +\n        `not compatible with schema ${schema}`);\n      return null;\n    }\n    if (!this.isJsonPointer(dataPointer)) {\n      console.error(`toSchemaPointer error: Invalid JSON Pointer: ${dataPointer}`);\n    }\n    if (typeof schema !== 'object') {\n      console.error(`toSchemaPointer error: Invalid JSON Schema: ${schema}`);\n    }\n    return null;\n  }\n\n  /**\n   * 'toDataPointer' function\n   *\n   * Accepts a JSON Pointer to a sub-schema inside a JSON schema and the schema.\n   *\n   * If possible, returns a generic Pointer to the corresponding value inside\n   * the data object described by the JSON schema.\n   *\n   * Returns null if the sub-schema is in an ambiguous location (such as\n   * definitions or additionalProperties) where the corresponding value\n   * location cannot be determined.\n   *\n   * @param  { Pointer } schemaPointer - JSON Pointer (string or array) to a JSON schema\n   * @param  { any } schema - the JSON schema\n   * @param  { boolean = false } errors - Show errors?\n   * @return { Pointer } - JSON Pointer (string) to the value in the data object\n   */\n  static toDataPointer(schemaPointer, schema, errors = false) {\n    if (this.isJsonPointer(schemaPointer) && typeof schema === 'object' &&\n      this.has(schema, schemaPointer)\n    ) {\n      const pointerArray = this.parse(schemaPointer);\n      if (!pointerArray.length) { return ''; }\n      const dataPointer = '';\n      const firstKey = pointerArray.shift();\n      if (firstKey === 'properties' ||\n        (firstKey === 'items' && isArray(schema.items))\n      ) {\n        const secondKey = pointerArray.shift();\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n        return pointerSuffix === null ? null : '/' + secondKey + pointerSuffix;\n      } else if (firstKey === 'additionalItems' ||\n        (firstKey === 'items' && isObject(schema.items))\n      ) {\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey]);\n        return pointerSuffix === null ? null : '/-' + pointerSuffix;\n      } else if (['allOf', 'anyOf', 'oneOf'].includes(firstKey)) {\n        const secondKey = pointerArray.shift();\n        return this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n      } else if (firstKey === 'not') {\n        return this.toDataPointer(pointerArray, schema[firstKey]);\n      } else if (['contains', 'definitions', 'dependencies', 'additionalItems',\n        'additionalProperties', 'patternProperties', 'propertyNames'].includes(firstKey)\n      ) {\n        if (errors) { console.error(`toDataPointer error: Ambiguous location`); }\n      }\n      return '';\n    }\n    if (errors) {\n      if (!this.isJsonPointer(schemaPointer)) {\n        console.error(`toDataPointer error: Invalid JSON Pointer: ${schemaPointer}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Invalid JSON Schema: ${schema}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Pointer ${schemaPointer} invalid for Schema: ${schema}`);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 'parseObjectPath' function\n   *\n   * Parses a JavaScript object path into an array of keys, which\n   * can then be passed to compile() to convert into a string JSON Pointer.\n   *\n   * Based on mike-marcacci's excellent objectpath parse function:\n   * https://github.com/mike-marcacci/objectpath\n   *\n   * @param  { Pointer } path - The object path to parse\n   * @return { string[] } - The resulting array of keys\n   */\n  static parseObjectPath(path) {\n    if (isArray(path)) { return <string[]>path; }\n    if (this.isJsonPointer(path)) { return this.parse(path); }\n    if (typeof path === 'string') {\n      let index = 0;\n      const parts: string[] = [];\n      while (index < path.length) {\n        const nextDot = path.indexOf('.', index);\n        const nextOB = path.indexOf('[', index); // next open bracket\n        if (nextDot === -1 && nextOB === -1) { // last item\n          parts.push(path.slice(index));\n          index = path.length;\n        } else if (nextDot !== -1 && (nextDot < nextOB || nextOB === -1)) { // dot notation\n          parts.push(path.slice(index, nextDot));\n          index = nextDot + 1;\n        } else { // bracket notation\n          if (nextOB > index) {\n            parts.push(path.slice(index, nextOB));\n            index = nextOB;\n          }\n          const quote = path.charAt(nextOB + 1);\n          if (quote === '\"' || quote === '\\'') { // enclosing quotes\n            let nextCB = path.indexOf(quote + ']', nextOB); // next close bracket\n            while (nextCB !== -1 && path.charAt(nextCB - 1) === '\\\\') {\n              nextCB = path.indexOf(quote + ']', nextCB + 2);\n            }\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 2, nextCB)\n              .replace(new RegExp('\\\\' + quote, 'g'), quote));\n            index = nextCB + 2;\n          } else { // no enclosing quotes\n            let nextCB = path.indexOf(']', nextOB); // next close bracket\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 1, nextCB));\n            index = nextCB + 1;\n          }\n          if (path.charAt(index) === '.') { index++; }\n        }\n      }\n      return parts;\n    }\n    console.error('parseObjectPath error: Input object path must be a string.');\n  }\n}\n"
  ],
  "names": [],
  "mappings": "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"
}
