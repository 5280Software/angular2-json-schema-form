{
  "version": 3,
  "file": "angular2-json-schema-form.umd.min.js",
  "sources": [
    "ng://angular2-json-schema-form/src/lib/src/shared/validator.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/utility.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/jsonpointer.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/merge-schemas.function.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/json-schema.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/format-regex.constants.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/json.validators.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/form-group.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/layout.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/locale/en-validation-messages.ts",
    "ng://angular2-json-schema-form/src/lib/src/locale/fr-validation-messages.ts",
    "ng://angular2-json-schema-form/src/lib/src/json-schema-form.service.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/add-reference.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/one-of.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/button.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/checkbox.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/orderable.directive.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/checkboxes.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/file.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/input.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/message.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/none.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/number.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/radios.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/root.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/section.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/select.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/select-framework.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/select-widget.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/submit.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/tabs.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/template.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/textarea.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/widget-library.service.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/framework.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/framework-library.service.ts",
    "ng://angular2-json-schema-form/src/lib/src/json-schema-form.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/convert-schema-to-draft6.function.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/hidden.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/tab.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/index.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/widget-library.module.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/no-framework/no-framework.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/no-framework/no.framework.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/no-framework/no-framework.module.ts",
    "ng://angular2-json-schema-form/src/lib/src/json-schema-form.module.ts"
  ],
  "sourcesContent": [
    "import { AbstractControl, ValidationErrors } from '@angular/forms';\nimport { Observable } from 'rxjs-compat/Observable';\nimport { fromPromise } from 'rxjs-compat/observable/fromPromise';\nimport { toPromise } from 'rxjs-compat/operator/toPromise';\n\n/**\n * Validator utility function library:\n *\n * Validator and error utilities:\n *   _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors\n *\n * Individual value checking:\n *   isDefined, hasValue, isEmpty\n *\n * Individual type checking:\n *   isString, isNumber, isInteger, isBoolean, isFunction, isObject, isArray,\n *   isMap, isSet, isPromise, isObservable\n *\n * Multiple type checking and fixing:\n *   getType, isType, isPrimitive, toJavaScriptType, toSchemaType,\n *   _toPromise, toObservable\n *\n * Utility functions:\n *   inArray, xor\n *\n * Typescript types and interfaces:\n *   SchemaPrimitiveType, SchemaType, JavaScriptPrimitiveType, JavaScriptType,\n *   PrimitiveValue, PlainObject, IValidatorFn, AsyncIValidatorFn\n *\n * Note: 'IValidatorFn' is short for 'invertable validator function',\n *   which is a validator functions that accepts an optional second\n *   argument which, if set to TRUE, causes the validator to perform\n *   the opposite of its original function.\n */\n\nexport type SchemaPrimitiveType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null';\nexport type SchemaType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null' | 'object' | 'array';\nexport type JavaScriptPrimitiveType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined';\nexport type JavaScriptType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined' | 'object' | 'array' |\n  'map' | 'set' | 'arguments' | 'date' | 'error' | 'function' | 'json' |\n  'math' | 'regexp'; // Note: this list is incomplete\nexport type PrimitiveValue = string | number | boolean | null | undefined;\nexport interface PlainObject { [k: string]: any; }\n\nexport type IValidatorFn = (c: AbstractControl, i?: boolean) => PlainObject;\nexport type AsyncIValidatorFn = (c: AbstractControl, i?: boolean) => any;\n\n/**\n * '_executeValidators' utility function\n *\n * Validates a control against an array of validators, and returns\n * an array of the same length containing a combination of error messages\n * (from invalid validators) and null values (from valid validators)\n *\n * @param  { AbstractControl } control - control to validate\n * @param  { IValidatorFn[] } validators - array of validators\n * @param  { boolean } invert - invert?\n * @return { PlainObject[] } - array of nulls and error message\n */\nexport function _executeValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_executeAsyncValidators' utility function\n *\n * Validates a control against an array of async validators, and returns\n * an array of observabe results of the same length containing a combination of\n * error messages (from invalid validators) and null values (from valid ones)\n *\n * @param  { AbstractControl } control - control to validate\n * @param  { AsyncIValidatorFn[] } validators - array of async validators\n * @param  { boolean } invert - invert?\n * @return { any[] } - array of observable nulls and error message\n */\nexport function _executeAsyncValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_mergeObjects' utility function\n *\n * Recursively Merges one or more objects into a single object with combined keys.\n * Automatically detects and ignores null and undefined inputs.\n * Also detects duplicated boolean 'not' keys and XORs their values.\n *\n * @param  { PlainObject[] } objects - one or more objects to merge\n * @return { PlainObject } - merged object\n */\nexport function _mergeObjects(...objects) {\n  const mergedObject: PlainObject = { };\n  for (const currentObject of objects) {\n    if (isObject(currentObject)) {\n      for (const key of Object.keys(currentObject)) {\n        const currentValue = currentObject[key];\n        const mergedValue = mergedObject[key];\n        mergedObject[key] = !isDefined(mergedValue) ? currentValue :\n          key === 'not' && isBoolean(mergedValue, 'strict') &&\n            isBoolean(currentValue, 'strict') ? xor(mergedValue, currentValue) :\n          getType(mergedValue) === 'object' && getType(currentValue) === 'object' ?\n            _mergeObjects(mergedValue, currentValue) :\n            currentValue;\n      }\n    }\n  }\n  return mergedObject;\n}\n\n/**\n * '_mergeErrors' utility function\n *\n * Merges an array of objects.\n * Used for combining the validator errors returned from 'executeValidators'\n *\n * @param  { PlainObject[] } arrayOfErrors - array of objects\n * @return { PlainObject } - merged object, or null if no usable input objectcs\n */\nexport function _mergeErrors(arrayOfErrors) {\n  const mergedErrors = _mergeObjects(...arrayOfErrors);\n  return isEmpty(mergedErrors) ? null : mergedErrors;\n}\n\n/**\n * 'isDefined' utility function\n *\n * Checks if a variable contains a value of any type.\n * Returns true even for otherwise 'falsey' values of 0, '', and false.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined or null, otherwise true\n */\nexport function isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * 'hasValue' utility function\n *\n * Checks if a variable contains a value.\n * Returs false for null, undefined, or a zero-length strng, '',\n * otherwise returns true.\n * (Stricter than 'isDefined' because it also returns false for '',\n * though it stil returns true for otherwise 'falsey' values 0 and false.)\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function hasValue(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\n/**\n * 'isEmpty' utility function\n *\n * Similar to !hasValue, but also returns true for empty arrays and objects.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function isEmpty(value) {\n  if (isArray(value)) { return !value.length; }\n  if (isObject(value)) { return !Object.keys(value).length; }\n  return value === undefined || value === null || value === '';\n}\n\n/**\n * 'isString' utility function\n *\n * Checks if a value is a string.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - true if string, false if not\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * 'isNumber' utility function\n *\n * Checks if a value is a regular number, numeric string, or JavaScript Date.\n *\n * @param  { any } value - the value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return { boolean } - true if number, false if not\n */\nexport function isNumber(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) && value !== value / 0;\n}\n\n/**\n * 'isInteger' utility function\n *\n * Checks if a value is an integer.\n *\n * @param  { any } value - the value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return {boolean } - true if number, false if not\n */\nexport function isInteger(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) &&  value !== value / 0 && value % 1 === 0;\n}\n\n/**\n * 'isBoolean' utility function\n *\n * Checks if a value is a boolean.\n *\n * @param  { any } value - the value to check\n * @param  { any = null } option - if 'strict', also checks JavaScript type\n *                              if TRUE or FALSE, checks only for that value\n * @return { boolean } - true if boolean, false if not\n */\nexport function isBoolean(value, option: any = null) {\n  if (option === 'strict') { return value === true || value === false; }\n  if (option === true) {\n    return value === true || value === 1 || value === 'true' || value === '1';\n  }\n  if (option === false) {\n    return value === false || value === 0 || value === 'false' || value === '0';\n  }\n  return value === true || value === 1 || value === 'true' || value === '1' ||\n    value === false || value === 0 || value === 'false' || value === '0';\n}\n\nexport function isFunction(item: any): boolean {\n  return typeof item === 'function';\n}\n\nexport function isObject(item: any): boolean {\n  return item !== null && typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Object]';\n}\n\nexport function isArray(item: any): boolean {\n  return Array.isArray(item) ||\n    Object.prototype.toString.call(item) === '[object Array]';\n}\n\nexport function isDate(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Date]';\n}\n\nexport function isMap(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Map]';\n}\n\nexport function isSet(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Set]';\n}\n\nexport function isSymbol(item: any): boolean {\n  return typeof item === 'symbol';\n}\n\n/**\n * 'getType' function\n *\n * Detects the JSON Schema Type of a value.\n * By default, detects numbers and integers even if formatted as strings.\n * (So all integers are also numbers, and any number may also be a string.)\n * However, it only detects true boolean values (to detect boolean values\n * in non-boolean formats, use isBoolean() instead).\n *\n * If passed a second optional parameter of 'strict', it will only detect\n * numbers and integers if they are formatted as JavaScript numbers.\n *\n * Examples:\n * getType('10.5') = 'number'\n * getType(10.5) = 'number'\n * getType('10') = 'integer'\n * getType(10) = 'integer'\n * getType('true') = 'string'\n * getType(true) = 'boolean'\n * getType(null) = 'null'\n * getType({ }) = 'object'\n * getType([]) = 'array'\n *\n * getType('10.5', 'strict') = 'string'\n * getType(10.5, 'strict') = 'number'\n * getType('10', 'strict') = 'string'\n * getType(10, 'strict') = 'integer'\n * getType('true', 'strict') = 'string'\n * getType(true, 'strict') = 'boolean'\n *\n * @param  { any } value - value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return { SchemaType }\n */\nexport function getType(value, strict: any = false) {\n  if (!isDefined(value)) { return 'null'; }\n  if (isArray(value)) { return 'array'; }\n  if (isObject(value)) { return 'object'; }\n  if (isBoolean(value, 'strict')) { return 'boolean'; }\n  if (isInteger(value, strict)) { return 'integer'; }\n  if (isNumber(value, strict)) { return 'number'; }\n  if (isString(value) || (!strict && isDate(value))) { return 'string'; }\n  return null;\n}\n\n/**\n * 'isType' function\n *\n * Checks wether an input (probably string) value contains data of\n * a specified JSON Schema type\n *\n * @param  { PrimitiveValue } value - value to check\n * @param  { SchemaPrimitiveType } type - type to check\n * @return { boolean }\n */\nexport function isType(value, type) {\n  switch (type) {\n    case 'string':\n      return isString(value) || isDate(value);\n    case 'number':\n      return isNumber(value);\n    case 'integer':\n      return isInteger(value);\n    case 'boolean':\n      return isBoolean(value);\n    case 'null':\n      return !hasValue(value);\n    default:\n      console.error(`isType error: \"${type}\" is not a recognized type.`);\n      return null;\n  }\n}\n\n/**\n * 'isPrimitive' function\n *\n * Checks wether an input value is a JavaScript primitive type:\n * string, number, boolean, or null.\n *\n * @param  { any } value - value to check\n * @return { boolean }\n */\nexport function isPrimitive(value) {\n  return (isString(value) || isNumber(value) ||\n    isBoolean(value, 'strict') || value === null);\n}\n\n/**\n * 'toJavaScriptType' function\n *\n * Converts an input (probably string) value to a JavaScript primitive type -\n * 'string', 'number', 'boolean', or 'null' - before storing in a JSON object.\n *\n * Does not coerce values (other than null), and only converts the types\n * of values that would otherwise be valid.\n *\n * If the optional third parameter 'strictIntegers' is TRUE, and the\n * JSON Schema type 'integer' is specified, it also verifies the input value\n * is an integer and, if it is, returns it as a JaveScript number.\n * If 'strictIntegers' is FALSE (or not set) the type 'integer' is treated\n * exactly the same as 'number', and allows decimals.\n *\n * Valid Examples:\n * toJavaScriptType('10',   'number' ) = 10   // '10'   is a number\n * toJavaScriptType('10',   'integer') = 10   // '10'   is also an integer\n * toJavaScriptType( 10,    'integer') = 10   //  10    is still an integer\n * toJavaScriptType( 10,    'string' ) = '10' //  10    can be made into a string\n * toJavaScriptType('10.5', 'number' ) = 10.5 // '10.5' is a number\n *\n * Invalid Examples:\n * toJavaScriptType('10.5', 'integer') = null // '10.5' is not an integer\n * toJavaScriptType( 10.5,  'integer') = null //  10.5  is still not an integer\n *\n * @param  { PrimitiveValue } value - value to convert\n * @param  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - types to convert to\n * @param  { boolean = false } strictIntegers - if FALSE, treat integers as numbers\n * @return { PrimitiveValue }\n */\nexport function toJavaScriptType(value, types, strictIntegers = true)  {\n  if (!isDefined(value)) { return null; }\n  if (isString(types)) { types = [types]; }\n  if (strictIntegers && inArray('integer', types)) {\n    if (isInteger(value, 'strict')) { return value; }\n    if (isInteger(value)) { return parseInt(value, 10); }\n  }\n  if (inArray('number', types) || (!strictIntegers && inArray('integer', types))) {\n    if (isNumber(value, 'strict')) { return value; }\n    if (isNumber(value)) { return parseFloat(value); }\n  }\n  if (inArray('string', types)) {\n    if (isString(value)) { return value; }\n    // If value is a date, and types includes 'string',\n    // convert the date to a string\n    if (isDate(value)) { return value.toISOString().slice(0, 10); }\n    if (isNumber(value)) { return value.toString(); }\n  }\n  // If value is a date, and types includes 'integer' or 'number',\n  // but not 'string', convert the date to a number\n  if (isDate(value) && (inArray('integer', types) || inArray('number', types))) {\n    return value.getTime();\n  }\n  if (inArray('boolean', types)) {\n    if (isBoolean(value, true)) { return true; }\n    if (isBoolean(value, false)) { return false; }\n  }\n  return null;\n}\n\n/**\n * 'toSchemaType' function\n *\n * Converts an input (probably string) value to the \"best\" JavaScript\n * equivalent available from an allowed list of JSON Schema types, which may\n * contain 'string', 'number', 'integer', 'boolean', and/or 'null'.\n * If necssary, it does progressively agressive type coersion.\n * It will not return null unless null is in the list of allowed types.\n *\n * Number conversion examples:\n * toSchemaType('10', ['number','integer','string']) = 10 // integer\n * toSchemaType('10', ['number','string']) = 10 // number\n * toSchemaType('10', ['string']) = '10' // string\n * toSchemaType('10.5', ['number','integer','string']) = 10.5 // number\n * toSchemaType('10.5', ['integer','string']) = '10.5' // string\n * toSchemaType('10.5', ['integer']) = 10 // integer\n * toSchemaType(10.5, ['null','boolean','string']) = '10.5' // string\n * toSchemaType(10.5, ['null','boolean']) = true // boolean\n *\n * String conversion examples:\n * toSchemaType('1.5x', ['boolean','number','integer','string']) = '1.5x' // string\n * toSchemaType('1.5x', ['boolean','number','integer']) = '1.5' // number\n * toSchemaType('1.5x', ['boolean','integer']) = '1' // integer\n * toSchemaType('1.5x', ['boolean']) = true // boolean\n * toSchemaType('xyz', ['number','integer','boolean','null']) = true // boolean\n * toSchemaType('xyz', ['number','integer','null']) = null // null\n * toSchemaType('xyz', ['number','integer']) = 0 // number\n *\n * Boolean conversion examples:\n * toSchemaType('1', ['integer','number','string','boolean']) = 1 // integer\n * toSchemaType('1', ['number','string','boolean']) = 1 // number\n * toSchemaType('1', ['string','boolean']) = '1' // string\n * toSchemaType('1', ['boolean']) = true // boolean\n * toSchemaType('true', ['number','string','boolean']) = 'true' // string\n * toSchemaType('true', ['boolean']) = true // boolean\n * toSchemaType('true', ['number']) = 0 // number\n * toSchemaType(true, ['number','string','boolean']) = true // boolean\n * toSchemaType(true, ['number','string']) = 'true' // string\n * toSchemaType(true, ['number']) = 1 // number\n *\n * @param  { PrimitiveValue } value - value to convert\n * @param  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - allowed types to convert to\n * @return { PrimitiveValue }\n */\nexport function toSchemaType(value, types) {\n  if (!isArray(<SchemaPrimitiveType>types)) {\n    types = <SchemaPrimitiveType[]>[types];\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('null') && !hasValue(value)) {\n    return null;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && !isBoolean(value, 'strict')) {\n    return value;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) {\n    const testValue = toJavaScriptType(value, 'integer');\n    if (testValue !== null) { return +testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) {\n    const testValue = toJavaScriptType(value, 'number');\n    if (testValue !== null) { return +testValue; }\n  }\n  if (\n    (isString(value) || isNumber(value, 'strict')) &&\n    (<SchemaPrimitiveType[]>types).includes('string')\n  ) { // Convert number to string\n    return toJavaScriptType(value, 'string');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && isBoolean(value)) {\n    return toJavaScriptType(value, 'boolean');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('string')) { // Convert null & boolean to string\n    if (value === null) { return ''; }\n    const testValue = toJavaScriptType(value, 'string');\n    if (testValue !== null) { return testValue; }\n  }\n  if ((\n    (<SchemaPrimitiveType[]>types).includes('number') ||\n    (<SchemaPrimitiveType[]>types).includes('integer'))\n  ) {\n    if (value === true) { return 1; } // Convert boolean & null to number\n    if (value === false || value === null || value === '') { return 0; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) { // Convert mixed string to number\n    const testValue = parseFloat(<string>value);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) { // Convert string or number to integer\n    const testValue = parseInt(<string>value, 10);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean')) { // Convert anything to boolean\n    return !!value;\n  }\n  if ((\n      (<SchemaPrimitiveType[]>types).includes('number') ||\n      (<SchemaPrimitiveType[]>types).includes('integer')\n    ) && !(<SchemaPrimitiveType[]>types).includes('null')\n  ) {\n    return 0; // If null not allowed, return 0 for non-convertable values\n  }\n}\n\n/**\n * 'isPromise' function\n *\n * @param  { any } object\n * @return { boolean }\n */\nexport function isPromise(object): object is Promise<any> {\n  return !!object && typeof object.then === 'function';\n}\n\n/**\n * 'isObservable' function\n *\n * @param  { any } object\n * @return { boolean }\n */\nexport function isObservable(object): object is Observable<any> {\n  return !!object && typeof object.subscribe === 'function';\n}\n\n/**\n * '_toPromise' function\n *\n * @param  { object } object\n * @return { Promise<any> }\n */\nexport function _toPromise(object): Promise<any> {\n  return isPromise(object) ? object : toPromise.call(object);\n}\n\n/**\n * 'toObservable' function\n *\n * @param  { object } object\n * @return { Observable<any> }\n */\nexport function toObservable(object): Observable<any> {\n  const observable = isPromise(object) ? fromPromise(object) : object;\n  if (isObservable(observable)) { return observable; }\n  console.error('toObservable error: Expected validator to return Promise or Observable.');\n  return new Observable();\n}\n\n/**\n * 'inArray' function\n *\n * Searches an array for an item, or one of a list of items, and returns true\n * as soon as a match is found, or false if no match.\n *\n * If the optional third parameter allIn is set to TRUE, and the item to find\n * is an array, then the function returns true only if all elements from item\n * are found in the array list, and false if any element is not found. If the\n * item to find is not an array, setting allIn to TRUE has no effect.\n *\n * @param  { any|any[] } item - the item to search for\n * @param  { any[] } array - the array to search\n * @param  { boolean = false } allIn - if TRUE, all items must be in array\n * @return { boolean } - true if item(s) in array, false otherwise\n */\nexport function inArray(item, array, allIn = false) {\n  if (!isDefined(item) || !isArray(array)) { return false; }\n  return isArray(item) ?\n    item[allIn ? 'every' : 'some'](subItem => array.includes(subItem)) :\n    array.includes(item);\n}\n\n/**\n * 'xor' utility function - exclusive or\n *\n * Returns true if exactly one of two values is truthy.\n *\n * @param  { any } value1 - first value to check\n * @param  { any } value2 - second value to check\n * @return { boolean } - true if exactly one input value is truthy, false if not\n */\nexport function xor(value1, value2) {\n  return (!!value1 && !value2) || (!value1 && !!value2);\n}\n",
    "import {\n  hasValue, inArray, isArray, isDefined, isObject, isEmpty, isMap, isSet,\n  isString, PlainObject\n} from './validator.functions';\n\n/**\n * Utility function library:\n *\n * addClasses, copy, forEach, forEachCopy, hasOwn, mergeFilteredObject,\n * uniqueItems, commonItems, fixTitle, toTitleCase\n*/\n\n/**\n * 'addClasses' function\n *\n * Merges two space-delimited lists of CSS classes and removes duplicates.\n *\n * @param {string | string[] | Set<string>} oldClasses\n * @param {string | string[] | Set<string>} newClasses\n * @return {string | string[] | Set<string>} - Combined classes\n */\nexport function addClasses(\n  oldClasses: string | string[] | Set<string>,\n  newClasses: string | string[] | Set<string>\n): string | string[] | Set<string> {\n  const badType = i => !isSet(i) && !isArray(i) && !isString(i);\n  if (badType(newClasses)) { return oldClasses; }\n  if (badType(oldClasses)) { oldClasses = ''; }\n  const toSet = i => isSet(i) ? i : isArray(i) ? new Set(i) : new Set(i.split(' '));\n  const combinedSet: Set<any> = toSet(oldClasses);\n  const newSet: Set<any> = toSet(newClasses);\n  newSet.forEach(c => combinedSet.add(c));\n  if (isSet(oldClasses)) { return combinedSet; }\n  if (isArray(oldClasses)) { return Array.from(combinedSet); }\n  return Array.from(combinedSet).join(' ');\n}\n\n/**\n * 'copy' function\n *\n * Makes a shallow copy of a JavaScript object, array, Map, or Set.\n * If passed a JavaScript primitive value (string, number, boolean, or null),\n * it returns the value.\n *\n * @param {Object|Array|string|number|boolean|null} object - The object to copy\n * @param {boolean = false} errors - Show errors?\n * @return {Object|Array|string|number|boolean|null} - The copied object\n */\nexport function copy(object: any, errors = false): any {\n  if (typeof object !== 'object' || object === null) { return object; }\n  if (isMap(object))    { return new Map(object); }\n  if (isSet(object))    { return new Set(object); }\n  if (isArray(object))  { return [ ...object ];   }\n  if (isObject(object)) { return { ...object };   }\n  if (errors) {\n    console.error('copy error: Object to copy must be a JavaScript object or value.');\n  }\n  return object;\n}\n\n/**\n * 'forEach' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator funciton on each item.\n *\n * The iterator function is called with four values:\n * 1. The current item's value\n * 2. The current item's key\n * 3. The parent object, which contains the current item\n * 4. The root object\n *\n * Setting the optional third parameter to 'top-down' or 'bottom-up' will cause\n * it to also recursively iterate over items in sub-objects or sub-arrays in the\n * specified direction.\n *\n * @param {Object|Array} object - The object or array to iterate over\n * @param {function} fn - the iterator funciton to call on each item\n * @param {boolean = false} errors - Show errors?\n * @return {void}\n */\nexport function forEach(\n  object: any, fn: (v: any, k?: string | number, c?: any, rc?: any) => any,\n  recurse: boolean | string = false, rootObject: any = object, errors = false\n): void {\n  if (isEmpty(object)) { return; }\n  if ((isObject(object) || isArray(object)) && typeof fn === 'function') {\n    for (const key of Object.keys(object)) {\n      const value = object[key];\n      if (recurse === 'bottom-up' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject);\n      }\n      fn(value, key, object, rootObject);\n      if (recurse === 'top-down' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject);\n      }\n    }\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEach error: Iterator must be a function.');\n      console.error('function', fn);\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEach error: Input object must be an object or array.');\n      console.error('object', object);\n    }\n  }\n}\n\n/**\n * 'forEachCopy' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator function on each item. Returns a new object or array\n * with the same keys or indexes as the original, and values set to the results\n * of the iterator function.\n *\n * Does NOT recursively iterate over items in sub-objects or sub-arrays.\n *\n * @param {Object | Array} object - The object or array to iterate over\n * @param {function} fn - The iterator funciton to call on each item\n * @param {boolean = false} errors - Show errors?\n * @return {Object | Array} - The resulting object or array\n */\nexport function forEachCopy(\n  object: any, fn: (v: any, k?: string | number, o?: any, p?: string) => any,\n  errors = false\n): any {\n  if (!hasValue(object)) { return; }\n  if ((isObject(object) || isArray(object)) && typeof object !== 'function') {\n    const newObject: any = isArray(object) ? [] : {};\n    for (const key of Object.keys(object)) {\n      newObject[key] = fn(object[key], key, object);\n    }\n    return newObject;\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEachCopy error: Iterator must be a function.');\n      console.error('function', fn);\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEachCopy error: Input object must be an object or array.');\n      console.error('object', object);\n    }\n  }\n}\n\n/**\n * 'hasOwn' utility function\n *\n * Checks whether an object or array has a particular property.\n *\n * @param {any} object - the object to check\n * @param {string} property - the property to look for\n * @return {boolean} - true if object has property, false if not\n */\nexport function hasOwn(object: any, property: string): boolean {\n  if (!object || !['number', 'string', 'symbol'].includes(typeof property) ||\n    (!isObject(object) && !isArray(object) && !isMap(object) && !isSet(object))\n  ) { return false; }\n  if (isMap(object) || isSet(object)) { return object.has(property); }\n  if (typeof property === 'number') {\n    if (isArray(object)) { return object[<number>property]; }\n    property = property + '';\n  }\n  return object.hasOwnProperty(property);\n}\n\n/**\n * 'mergeFilteredObject' utility function\n *\n * Shallowly merges two objects, setting key and values from source object\n * in target object, excluding specified keys.\n *\n * Optionally, it can also use functions to transform the key names and/or\n * the values of the merging object.\n *\n * @param {PlainObject} targetObject - Target object to add keys and values to\n * @param {PlainObject} sourceObject - Source object to copy keys and values from\n * @param {string[]} excludeKeys - Array of keys to exclude\n * @param {(string: string) => string = (k) => k} keyFn - Function to apply to keys\n * @param {(any: any) => any = (v) => v} valueFn - Function to apply to values\n * @return {PlainObject} - Returns targetObject\n */\nexport function mergeFilteredObject(\n  targetObject: PlainObject,\n  sourceObject: PlainObject,\n  excludeKeys = <string[]>[],\n  keyFn = (key: string): string => key,\n  valFn = (val: any): any => val\n): PlainObject {\n  if (!isObject(sourceObject)) { return targetObject; }\n  if (!isObject(targetObject)) { targetObject = {}; }\n  for (const key of Object.keys(sourceObject)) {\n    if (!inArray(key, excludeKeys) && isDefined(sourceObject[key])) {\n      targetObject[keyFn(key)] = valFn(sourceObject[key]);\n    }\n  }\n  return targetObject;\n}\n\n/**\n * 'uniqueItems' function\n *\n * Accepts any number of string value inputs,\n * and returns an array of all input vaues, excluding duplicates.\n *\n * @param {...string} ...items -\n * @return {string[]} -\n */\nexport function uniqueItems(...items): string[] {\n  const returnItems = [];\n  for (const item of items) {\n    if (!returnItems.includes(item)) { returnItems.push(item); }\n  }\n  return returnItems;\n}\n\n/**\n * 'commonItems' function\n *\n * Accepts any number of strings or arrays of string values,\n * and returns a single array containing only values present in all inputs.\n *\n * @param {...string|string[]} ...arrays -\n * @return {string[]} -\n */\nexport function commonItems(...arrays): string[] {\n  let returnItems = null;\n  for (let array of arrays) {\n    if (isString(array)) { array = [array]; }\n    returnItems = returnItems === null ? [ ...array ] :\n      returnItems.filter(item => array.includes(item));\n    if (!returnItems.length) { return []; }\n  }\n  return returnItems;\n}\n\n/**\n * 'fixTitle' function\n *\n *\n * @param {string} input -\n * @return {string} -\n */\nexport function fixTitle(name: string): string {\n  return name && toTitleCase(name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' '));\n}\n\n/**\n * 'toTitleCase' function\n *\n * Intelligently converts an input string to Title Case.\n *\n * Accepts an optional second parameter with a list of additional\n * words and abbreviations to force into a particular case.\n *\n * This function is built on prior work by John Gruber and David Gouch:\n * http://daringfireball.net/2008/08/title_case_update\n * https://github.com/gouch/to-title-case\n *\n * @param {string} input -\n * @param {string|string[]} forceWords? -\n * @return {string} -\n */\nexport function toTitleCase(input: string, forceWords?: string|string[]): string {\n  if (!isString(input)) { return input; }\n  let forceArray: string[] = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'en',\n   'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'per', 'the', 'to', 'v', 'v.',\n   'vs', 'vs.', 'via'];\n  if (isString(forceWords)) { forceWords = (<string>forceWords).split('|'); }\n  if (isArray(forceWords)) { forceArray = forceArray.concat(forceWords); }\n  const forceArrayLower: string[] = forceArray.map(w => w.toLowerCase());\n  const noInitialCase: boolean =\n    input === input.toUpperCase() || input === input.toLowerCase();\n  let prevLastChar = '';\n  input = input.trim();\n  return input.replace(/[A-Za-z0-9\\u00C0-\\u00FF]+[^\\s-]*/g, (word, idx) => {\n    if (!noInitialCase && word.slice(1).search(/[A-Z]|\\../) !== -1) {\n      return word;\n    } else {\n      let newWord: string;\n      const forceWord: string =\n        forceArray[forceArrayLower.indexOf(word.toLowerCase())];\n      if (!forceWord) {\n        if (noInitialCase) {\n          if (word.slice(1).search(/\\../) !== -1) {\n            newWord = word.toLowerCase();\n          } else {\n            newWord = word[0].toUpperCase() + word.slice(1).toLowerCase();\n          }\n        } else {\n          newWord = word[0].toUpperCase() + word.slice(1);\n        }\n      } else if (\n        forceWord === forceWord.toLowerCase() && (\n          idx === 0 || idx + word.length === input.length ||\n          prevLastChar === ':' || input[idx - 1].search(/[^\\s-]/) !== -1 ||\n          (input[idx - 1] !== '-' && input[idx + word.length] === '-')\n        )\n      ) {\n        newWord = forceWord[0].toUpperCase() + forceWord.slice(1);\n      } else {\n        newWord = forceWord;\n      }\n      prevLastChar = word.slice(-1);\n      return newWord;\n    }\n  });\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport {\n  isDefined, isEmpty, isObject, isArray, isMap, isNumber, isString\n} from './validator.functions';\nimport { hasOwn, copy } from './utility.functions';\n\n/**\n * 'JsonPointer' class\n *\n * Some utilities for using JSON Pointers with JSON objects\n * https://tools.ietf.org/html/rfc6901\n *\n * get, getCopy, getFirst, set, setCopy, insert, insertCopy, remove, has, dict,\n * forEachDeep, forEachDeepCopy, escape, unescape, parse, compile, toKey,\n * isJsonPointer, isSubPointer, toIndexedPointer, toGenericPointer,\n * toControlPointer, toSchemaPointer, toDataPointer, parseObjectPath\n *\n * Some functions based on manuelstofer's json-pointer utilities\n * https://github.com/manuelstofer/json-pointer\n */\nexport type Pointer = string | string[];\n\n@Injectable()\nexport class JsonPointer {\n\n  /**\n   * 'get' function\n   *\n   * Uses a JSON Pointer to retrieve a value from an object.\n   *\n   * @param  { object } object - Object to get value from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * @param  { number } endSlice - Zero-based index of last Pointer key to use\n   * @param  { boolean = false } getBoolean - Return only true or false?\n   * @param  { boolean = false } errors - Show error if not found?\n   * @return { object } - Located value (or true or false if getBoolean = true)\n   */\n  static get(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    if (object === null) { return getBoolean ? false : undefined; }\n    let keyArray: any[] = this.parse(pointer, errors);\n    if (typeof object === 'object' && keyArray !== null) {\n      let subObject = object;\n      if (startSlice >= keyArray.length || endSlice <= -keyArray.length) { return object; }\n      if (startSlice <= -keyArray.length) { startSlice = 0; }\n      if (!isDefined(endSlice) || endSlice >= keyArray.length) { endSlice = keyArray.length; }\n      keyArray = keyArray.slice(startSlice, endSlice);\n      for (let key of keyArray) {\n        if (key === '-' && isArray(subObject) && subObject.length) {\n          key = subObject.length - 1;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else if (typeof subObject === 'object' && subObject !== null &&\n          hasOwn(subObject, key)\n        ) {\n          subObject = subObject[key];\n        } else {\n          if (errors) {\n            console.error(`get error: \"${key}\" key not found in object.`);\n            console.error(pointer);\n            console.error(object);\n          }\n          return getBoolean ? false : undefined;\n        }\n      }\n      return getBoolean ? true : subObject;\n    }\n    if (errors && keyArray === null) {\n      console.error(`get error: Invalid JSON Pointer: ${pointer}`);\n    }\n    if (errors && typeof object !== 'object') {\n      console.error('get error: Invalid object:');\n      console.error(object);\n    }\n    return getBoolean ? false : undefined;\n  }\n\n  /**\n   * 'getCopy' function\n   *\n   * Uses a JSON Pointer to deeply clone a value from an object.\n   *\n   * @param  { object } object - Object to get value from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * @param  { number } endSlice - Zero-based index of last Pointer key to use\n   * @param  { boolean = false } getBoolean - Return only true or false?\n   * @param  { boolean = false } errors - Show error if not found?\n   * @return { object } - Located value (or true or false if getBoolean = true)\n   */\n  static getCopy(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    const objectToCopy =\n      this.get(object, pointer, startSlice, endSlice, getBoolean, errors);\n    return this.forEachDeepCopy(objectToCopy);\n  }\n\n  /**\n   * 'getFirst' function\n   *\n   * Takes an array of JSON Pointers and objects,\n   * checks each object for a value specified by the pointer,\n   * and returns the first value found.\n   *\n   * @param  { [object, pointer][] } items - Array of objects and pointers to check\n   * @param  { any = null } defaultValue - Value to return if nothing found\n   * @param  { boolean = false } getCopy - Return a copy instead?\n   * @return { any } - First value found\n   */\n  static getFirst(items, defaultValue: any = null, getCopy = false) {\n    if (isEmpty(items)) { return; }\n    if (isArray(items)) {\n      for (const item of items) {\n        if (isEmpty(item)) { continue; }\n        if (isArray(item) && item.length >= 2) {\n          if (isEmpty(item[0]) || isEmpty(item[1])) { continue; }\n          const value = getCopy ?\n            this.getCopy(item[0], item[1]) :\n            this.get(item[0], item[1]);\n          if (value) { return value; }\n          continue;\n        }\n        console.error('getFirst error: Input not in correct format.\\n' +\n          'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n        return;\n      }\n      return defaultValue;\n    }\n    if (isMap(items)) {\n      for (const [object, pointer] of items) {\n        if (object === null || !this.isJsonPointer(pointer)) { continue; }\n        const value = getCopy ?\n          this.getCopy(object, pointer) :\n          this.get(object, pointer);\n        if (value) { return value; }\n      }\n      return defaultValue;\n    }\n    console.error('getFirst error: Input not in correct format.\\n' +\n      'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n    return defaultValue;\n  }\n\n  /**\n   * 'getFirstCopy' function\n   *\n   * Similar to getFirst, but always returns a copy.\n   *\n   * @param  { [object, pointer][] } items - Array of objects and pointers to check\n   * @param  { any = null } defaultValue - Value to return if nothing found\n   * @return { any } - Copy of first value found\n   */\n  static getFirstCopy(items, defaultValue: any = null) {\n    const firstCopy = this.getFirst(items, defaultValue, true);\n    return firstCopy;\n  }\n\n  /**\n   * 'set' function\n   *\n   * Uses a JSON Pointer to set a value on an object.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing\n   * value (if any) at that location.\n   *\n   * So set([1, 2, 3], '/1', 4) => [1, 4, 3]\n   * and\n   * So set([1, 2, 3], '/1', 4, true) => [1, 4, 2, 3]\n   *\n   * @param  { object } object - The object to set value in\n   * @param  { Pointer } pointer - The JSON Pointer (string or array)\n   * @param  { any } value - The new value to set\n   * @param  { boolean } insert - insert value?\n   * @return { object } - The original object, modified with the set value\n   */\n  static set(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let subObject = object;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return object;\n    }\n    console.error(`set error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'setCopy' function\n   *\n   * Copies an object and uses a JSON Pointer to set a value on the copy.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing value.\n   *\n   * @param  { object } object - The object to copy and set value in\n   * @param  { Pointer } pointer - The JSON Pointer (string or array)\n   * @param  { any } value - The value to set\n   * @param  { boolean } insert - insert value?\n   * @return { object } - The new object with the set value\n   */\n  static setCopy(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null) {\n      const newObject = copy(object);\n      let subObject = newObject;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject.set(key, copy(subObject.get(key)));\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject[key] = copy(subObject[key]);\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return newObject;\n    }\n    console.error(`setCopy error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'insert' function\n   *\n   * Calls 'set' with insert = TRUE\n   *\n   * @param  { object } object - object to insert value in\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { any } value - value to insert\n   * @return { object }\n   */\n  static insert(object, pointer, value) {\n    const updatedObject = this.set(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'insertCopy' function\n   *\n   * Calls 'setCopy' with insert = TRUE\n   *\n   * @param  { object } object - object to insert value in\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { any } value - value to insert\n   * @return { object }\n   */\n  static insertCopy(object, pointer, value) {\n    const updatedObject = this.setCopy(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'remove' function\n   *\n   * Uses a JSON Pointer to remove a key and its attribute from an object\n   *\n   * @param  { object } object - object to delete attribute from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @return { object }\n   */\n  static remove(object, pointer) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let lastKey = keyArray.pop();\n      const parentObject = this.get(object, keyArray);\n      if (isArray(parentObject)) {\n        if (lastKey === '-') { lastKey = parentObject.length - 1; }\n        parentObject.splice(lastKey, 1);\n      } else if (isObject(parentObject)) {\n        delete parentObject[lastKey];\n      }\n      return object;\n    }\n    console.error(`remove error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'has' function\n   *\n   * Tests if an object has a value at the location specified by a JSON Pointer\n   *\n   * @param  { object } object - object to chek for value\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @return { boolean }\n   */\n  static has(object, pointer) {\n    const hasValue = this.get(object, pointer, 0, null, true);\n    return hasValue;\n  }\n\n  /**\n   * 'dict' function\n   *\n   * Returns a (pointer -> value) dictionary for an object\n   *\n   * @param  { object } object - The object to create a dictionary from\n   * @return { object } - The resulting dictionary object\n   */\n  static dict(object) {\n    const results: any = {};\n    this.forEachDeep(object, (value, pointer) => {\n      if (typeof value !== 'object') { results[pointer] = value; }\n    });\n    return results;\n  }\n\n  /**\n   * 'forEachDeep' function\n   *\n   * Iterates over own enumerable properties of an object or items in an array\n   * and invokes an iteratee function for each key/value or index/value pair.\n   * By default, iterates over items within objects and arrays after calling\n   * the iteratee function on the containing object or array itself.\n   *\n   * The iteratee is invoked with three arguments: (value, pointer, rootObject),\n   * where pointer is a JSON pointer indicating the location of the current\n   * value within the root object, and rootObject is the root object initially\n   * submitted to th function.\n   *\n   * If a third optional parameter 'bottomUp' is set to TRUE, the iterator\n   * function will be called on sub-objects and arrays after being\n   * called on their contents, rather than before, which is the default.\n   *\n   * This function can also optionally be called directly on a sub-object by\n   * including optional 4th and 5th parameterss to specify the initial\n   * root object and pointer.\n   *\n   * @param  { object } object - the initial object or array\n   * @param  { (v: any, p?: string, o?: any) => any } function - iteratee function\n   * @param  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * @param  { object = object } rootObject - optional, root object or array\n   * @param  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * @return { object } - The modified object\n   */\n  static forEachDeep(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeep error: Iterator is not a function:`, fn);\n      return;\n    }\n    if (!bottomUp) { fn(object, pointer, rootObject); }\n    if (isObject(object) || isArray(object)) {\n      for (const key of Object.keys(object)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        this.forEachDeep(object[key], fn, bottomUp, newPointer, rootObject);\n      }\n    }\n    if (bottomUp) { fn(object, pointer, rootObject); }\n  }\n\n  /**\n   * 'forEachDeepCopy' function\n   *\n   * Similar to forEachDeep, but returns a copy of the original object, with\n   * the same keys and indexes, but with values replaced with the result of\n   * the iteratee function.\n   *\n   * @param  { object } object - the initial object or array\n   * @param  { (v: any, k?: string, o?: any, p?: any) => any } function - iteratee function\n   * @param  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * @param  { object = object } rootObject - optional, root object or array\n   * @param  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * @return { object } - The copied object\n   */\n  static forEachDeepCopy(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeepCopy error: Iterator is not a function:`, fn);\n      return null;\n    }\n    if (isObject(object) || isArray(object)) {\n      let newObject = isArray(object) ? [ ...object ] : { ...object };\n      if (!bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      for (const key of Object.keys(newObject)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        newObject[key] = this.forEachDeepCopy(\n          newObject[key], fn, bottomUp, newPointer, rootObject\n        );\n      }\n      if (bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      return newObject;\n    } else {\n      return fn(object, pointer, rootObject);\n    }\n  }\n\n  /**\n   * 'escape' function\n   *\n   * Escapes a string reference key\n   *\n   * @param  { string } key - string key to escape\n   * @return { string } - escaped key\n   */\n  static escape(key) {\n    const escaped = key.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n    return escaped;\n  }\n\n  /**\n   * 'unescape' function\n   *\n   * Unescapes a string reference key\n   *\n   * @param  { string } key - string key to unescape\n   * @return { string } - unescaped key\n   */\n  static unescape(key) {\n    const unescaped = key.toString().replace(/~1/g, '/').replace(/~0/g, '~');\n    return unescaped;\n  }\n\n  /**\n   * 'parse' function\n   *\n   * Converts a string JSON Pointer into a array of keys\n   * (if input is already an an array of keys, it is returned unchanged)\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string[] } - JSON Pointer array of keys\n   */\n  static parse(pointer, errors = false) {\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`parse error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) { return <string[]>pointer; }\n    if (typeof pointer === 'string') {\n      if ((<string>pointer)[0] === '#') { pointer = pointer.slice(1); }\n      if (<string>pointer === '' || <string>pointer === '/') { return []; }\n      return (<string>pointer).slice(1).split('/').map(this.unescape);\n    }\n  }\n\n  /**\n   * 'compile' function\n   *\n   * Converts an array of keys into a JSON Pointer string\n   * (if input is already a string, it is normalized and returned)\n   *\n   * The optional second parameter is a default which will replace any empty keys.\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { string | number = '' } defaultValue - Default value\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string } - JSON Pointer string\n   */\n  static compile(pointer, defaultValue = '', errors = false) {\n    if (pointer === '#') { return ''; }\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`compile error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) {\n      if ((<string[]>pointer).length === 0) { return ''; }\n      return '/' + (<string[]>pointer).map(\n        key => key === '' ? defaultValue : this.escape(key)\n      ).join('/');\n    }\n    if (typeof pointer === 'string') {\n      if (pointer[0] === '#') { pointer = pointer.slice(1); }\n      return pointer;\n    }\n  }\n\n  /**\n   * 'toKey' function\n   *\n   * Extracts name of the final key from a JSON Pointer.\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string } - the extracted key\n   */\n  static toKey(pointer, errors = false) {\n    const keyArray = this.parse(pointer, errors);\n    if (keyArray === null) { return null; }\n    if (!keyArray.length) { return ''; }\n    return keyArray[keyArray.length - 1];\n  }\n\n  /**\n   * 'isJsonPointer' function\n   *\n   * Checks a string or array value to determine if it is a valid JSON Pointer.\n   * Returns true if a string is empty, or starts with '/' or '#/'.\n   * Returns true if an array contains only string values.\n   *\n   * @param  { any } value - value to check\n   * @return { boolean } - true if value is a valid JSON Pointer, otherwise false\n   */\n  static isJsonPointer(value) {\n    if (isArray(value)) {\n      return value.every(key => typeof key === 'string');\n    } else if (isString(value)) {\n      if (value === '' || value === '#') { return true; }\n      if (value[0] === '/' || value.slice(0, 2) === '#/') {\n        return !/(~[^01]|~$)/g.test(value);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * 'isSubPointer' function\n   *\n   * Checks whether one JSON Pointer is a subset of another.\n   *\n   * @param  { Pointer } shortPointer - potential subset JSON Pointer\n   * @param  { Pointer } longPointer - potential superset JSON Pointer\n   * @param  { boolean = false } trueIfMatching - return true if pointers match?\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { boolean } - true if shortPointer is a subset of longPointer, false if not\n   */\n  static isSubPointer(\n    shortPointer, longPointer, trueIfMatching = false, errors = false\n  ) {\n    if (!this.isJsonPointer(shortPointer) || !this.isJsonPointer(longPointer)) {\n      if (errors) {\n        let invalid = '';\n        if (!this.isJsonPointer(shortPointer)) { invalid += ` 1: ${shortPointer}`; }\n        if (!this.isJsonPointer(longPointer)) { invalid += ` 2: ${longPointer}`; }\n        console.error(`isSubPointer error: Invalid JSON Pointer ${invalid}`);\n      }\n      return;\n    }\n    shortPointer = this.compile(shortPointer, '', errors);\n    longPointer = this.compile(longPointer, '', errors);\n    return shortPointer === longPointer ? trueIfMatching :\n      `${shortPointer}/` === longPointer.slice(0, shortPointer.length + 1);\n  }\n\n  /**\n   * 'toIndexedPointer' function\n   *\n   * Merges an array of numeric indexes and a generic pointer to create an\n   * indexed pointer for a specific item.\n   *\n   * For example, merging the generic pointer '/foo/-/bar/-/baz' and\n   * the array [4, 2] would result in the indexed pointer '/foo/4/bar/2/baz'\n   *\n   * @function\n   * @param  { Pointer } genericPointer - The generic pointer\n   * @param  { number[] } indexArray - The array of numeric indexes\n   * @param  { Map<string, number> } arrayMap - An optional array map\n   * @return { string } - The merged pointer with indexes\n   */\n  static toIndexedPointer(\n    genericPointer, indexArray, arrayMap: Map<string, number> = null\n  ) {\n    if (this.isJsonPointer(genericPointer) && isArray(indexArray)) {\n      let indexedPointer = this.compile(genericPointer);\n      if (isMap(arrayMap)) {\n        let arrayIndex = 0;\n        return indexedPointer.replace(/\\/\\-(?=\\/|$)/g, (key, stringIndex) =>\n          arrayMap.has((<string>indexedPointer).slice(0, stringIndex)) ?\n            '/' + indexArray[arrayIndex++] : key\n        );\n      } else {\n        for (const pointerIndex of indexArray) {\n          indexedPointer = indexedPointer.replace('/-', '/' + pointerIndex);\n        }\n        return indexedPointer;\n      }\n    }\n    if (!this.isJsonPointer(genericPointer)) {\n      console.error(`toIndexedPointer error: Invalid JSON Pointer: ${genericPointer}`);\n    }\n    if (!isArray(indexArray)) {\n      console.error(`toIndexedPointer error: Invalid indexArray: ${indexArray}`);\n    }\n  }\n\n  /**\n   * 'toGenericPointer' function\n   *\n   * Compares an indexed pointer to an array map and removes list array\n   * indexes (but leaves tuple arrray indexes and all object keys, including\n   * numeric keys) to create a generic pointer.\n   *\n   * For example, using the indexed pointer '/foo/1/bar/2/baz/3' and\n   * the arrayMap [['/foo', 0], ['/foo/-/bar', 3], ['/foo/-/bar/-/baz', 0]]\n   * would result in the generic pointer '/foo/-/bar/2/baz/-'\n   * Using the indexed pointer '/foo/1/bar/4/baz/3' and the same arrayMap\n   * would result in the generic pointer '/foo/-/bar/-/baz/-'\n   * (the bar array has 3 tuple items, so index 2 is retained, but 4 is removed)\n   *\n   * The structure of the arrayMap is: [['path to array', number of tuple items]...]\n   *\n   * @function\n   * @param  { Pointer } indexedPointer - The indexed pointer (array or string)\n   * @param  { Map<string, number> } arrayMap - The optional array map (for preserving tuple indexes)\n   * @return { string } - The generic pointer with indexes removed\n   */\n  static toGenericPointer(indexedPointer, arrayMap = new Map<string, number>()) {\n    if (this.isJsonPointer(indexedPointer) && isMap(arrayMap)) {\n      const pointerArray = this.parse(indexedPointer);\n      for (let i = 1; i < pointerArray.length; i++) {\n        const subPointer = this.compile(pointerArray.slice(0, i));\n        if (arrayMap.has(subPointer) &&\n          arrayMap.get(subPointer) <= +pointerArray[i]\n        ) {\n          pointerArray[i] = '-';\n        }\n      }\n      return this.compile(pointerArray);\n    }\n    if (!this.isJsonPointer(indexedPointer)) {\n      console.error(`toGenericPointer error: invalid JSON Pointer: ${indexedPointer}`);\n    }\n    if (!isMap(arrayMap)) {\n      console.error(`toGenericPointer error: invalid arrayMap: ${arrayMap}`);\n    }\n  }\n\n  /**\n   * 'toControlPointer' function\n   *\n   * Accepts a JSON Pointer for a data object and returns a JSON Pointer for the\n   * matching control in an Angular FormGroup.\n   *\n   * @param  { Pointer } dataPointer - JSON Pointer (string or array) to a data object\n   * @param  { FormGroup } formGroup - Angular FormGroup to get value from\n   * @param  { boolean = false } controlMustExist - Only return if control exists?\n   * @return { Pointer } - JSON Pointer (string) to the formGroup object\n   */\n  static toControlPointer(dataPointer, formGroup, controlMustExist = false) {\n    const dataPointerArray = this.parse(dataPointer);\n    const controlPointerArray: string[] = [];\n    let subGroup = formGroup;\n    if (dataPointerArray !== null) {\n      for (const key of dataPointerArray) {\n        if (hasOwn(subGroup, 'controls')) {\n          controlPointerArray.push('controls');\n          subGroup = subGroup.controls;\n        }\n        if (isArray(subGroup) && (key === '-')) {\n          controlPointerArray.push((subGroup.length - 1).toString());\n          subGroup = subGroup[subGroup.length - 1];\n        } else if (hasOwn(subGroup, key)) {\n          controlPointerArray.push(key);\n          subGroup = subGroup[key];\n        } else if (controlMustExist) {\n          console.error(`toControlPointer error: Unable to find \"${key}\" item in FormGroup.`);\n          console.error(dataPointer);\n          console.error(formGroup);\n          return;\n        } else {\n          controlPointerArray.push(key);\n          subGroup = { controls: {} };\n        }\n      }\n      return this.compile(controlPointerArray);\n    }\n    console.error(`toControlPointer error: Invalid JSON Pointer: ${dataPointer}`);\n  }\n\n  /**\n   * 'toSchemaPointer' function\n   *\n   * Accepts a JSON Pointer to a value inside a data object and a JSON schema\n   * for that object.\n   *\n   * Returns a Pointer to the sub-schema for the value inside the object's schema.\n   *\n   * @param  { Pointer } dataPointer - JSON Pointer (string or array) to an object\n   * @param  { any } schema - JSON schema for the object\n   * @return { Pointer } - JSON Pointer (string) to the object's schema\n   */\n  static toSchemaPointer(dataPointer, schema) {\n    if (this.isJsonPointer(dataPointer) && typeof schema === 'object') {\n      const pointerArray = this.parse(dataPointer);\n      if (!pointerArray.length) { return ''; }\n      const firstKey = pointerArray.shift();\n      if (schema.type === 'object' || schema.properties || schema.additionalProperties) {\n        if ((schema.properties || {})[firstKey]) {\n          return `/properties/${this.escape(firstKey)}` +\n            this.toSchemaPointer(pointerArray, schema.properties[firstKey]);\n        } else  if (schema.additionalProperties) {\n          return '/additionalProperties' +\n            this.toSchemaPointer(pointerArray, schema.additionalProperties);\n        }\n      }\n      if ((schema.type === 'array' || schema.items) &&\n        (isNumber(firstKey) || firstKey === '-' || firstKey === '')\n      ) {\n        const arrayItem = firstKey === '-' || firstKey === '' ? 0 : +firstKey;\n        if (isArray(schema.items)) {\n          if (arrayItem < schema.items.length) {\n            return '/items/' + arrayItem +\n              this.toSchemaPointer(pointerArray, schema.items[arrayItem]);\n          } else if (schema.additionalItems) {\n            return '/additionalItems' +\n              this.toSchemaPointer(pointerArray, schema.additionalItems);\n          }\n        } else if (isObject(schema.items)) {\n          return '/items' + this.toSchemaPointer(pointerArray, schema.items);\n        } else if (isObject(schema.additionalItems)) {\n          return '/additionalItems' +\n            this.toSchemaPointer(pointerArray, schema.additionalItems);\n        }\n      }\n      console.error(`toSchemaPointer error: Data pointer ${dataPointer} ` +\n        `not compatible with schema ${schema}`);\n      return null;\n    }\n    if (!this.isJsonPointer(dataPointer)) {\n      console.error(`toSchemaPointer error: Invalid JSON Pointer: ${dataPointer}`);\n    }\n    if (typeof schema !== 'object') {\n      console.error(`toSchemaPointer error: Invalid JSON Schema: ${schema}`);\n    }\n    return null;\n  }\n\n  /**\n   * 'toDataPointer' function\n   *\n   * Accepts a JSON Pointer to a sub-schema inside a JSON schema and the schema.\n   *\n   * If possible, returns a generic Pointer to the corresponding value inside\n   * the data object described by the JSON schema.\n   *\n   * Returns null if the sub-schema is in an ambiguous location (such as\n   * definitions or additionalProperties) where the corresponding value\n   * location cannot be determined.\n   *\n   * @param  { Pointer } schemaPointer - JSON Pointer (string or array) to a JSON schema\n   * @param  { any } schema - the JSON schema\n   * @param  { boolean = false } errors - Show errors?\n   * @return { Pointer } - JSON Pointer (string) to the value in the data object\n   */\n  static toDataPointer(schemaPointer, schema, errors = false) {\n    if (this.isJsonPointer(schemaPointer) && typeof schema === 'object' &&\n      this.has(schema, schemaPointer)\n    ) {\n      const pointerArray = this.parse(schemaPointer);\n      if (!pointerArray.length) { return ''; }\n      const dataPointer = '';\n      const firstKey = pointerArray.shift();\n      if (firstKey === 'properties' ||\n        (firstKey === 'items' && isArray(schema.items))\n      ) {\n        const secondKey = pointerArray.shift();\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n        return pointerSuffix === null ? null : '/' + secondKey + pointerSuffix;\n      } else if (firstKey === 'additionalItems' ||\n        (firstKey === 'items' && isObject(schema.items))\n      ) {\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey]);\n        return pointerSuffix === null ? null : '/-' + pointerSuffix;\n      } else if (['allOf', 'anyOf', 'oneOf'].includes(firstKey)) {\n        const secondKey = pointerArray.shift();\n        return this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n      } else if (firstKey === 'not') {\n        return this.toDataPointer(pointerArray, schema[firstKey]);\n      } else if (['contains', 'definitions', 'dependencies', 'additionalItems',\n        'additionalProperties', 'patternProperties', 'propertyNames'].includes(firstKey)\n      ) {\n        if (errors) { console.error(`toDataPointer error: Ambiguous location`); }\n      }\n      return '';\n    }\n    if (errors) {\n      if (!this.isJsonPointer(schemaPointer)) {\n        console.error(`toDataPointer error: Invalid JSON Pointer: ${schemaPointer}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Invalid JSON Schema: ${schema}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Pointer ${schemaPointer} invalid for Schema: ${schema}`);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 'parseObjectPath' function\n   *\n   * Parses a JavaScript object path into an array of keys, which\n   * can then be passed to compile() to convert into a string JSON Pointer.\n   *\n   * Based on mike-marcacci's excellent objectpath parse function:\n   * https://github.com/mike-marcacci/objectpath\n   *\n   * @param  { Pointer } path - The object path to parse\n   * @return { string[] } - The resulting array of keys\n   */\n  static parseObjectPath(path) {\n    if (isArray(path)) { return <string[]>path; }\n    if (this.isJsonPointer(path)) { return this.parse(path); }\n    if (typeof path === 'string') {\n      let index = 0;\n      const parts: string[] = [];\n      while (index < path.length) {\n        const nextDot = path.indexOf('.', index);\n        const nextOB = path.indexOf('[', index); // next open bracket\n        if (nextDot === -1 && nextOB === -1) { // last item\n          parts.push(path.slice(index));\n          index = path.length;\n        } else if (nextDot !== -1 && (nextDot < nextOB || nextOB === -1)) { // dot notation\n          parts.push(path.slice(index, nextDot));\n          index = nextDot + 1;\n        } else { // bracket notation\n          if (nextOB > index) {\n            parts.push(path.slice(index, nextOB));\n            index = nextOB;\n          }\n          const quote = path.charAt(nextOB + 1);\n          if (quote === '\"' || quote === '\\'') { // enclosing quotes\n            let nextCB = path.indexOf(quote + ']', nextOB); // next close bracket\n            while (nextCB !== -1 && path.charAt(nextCB - 1) === '\\\\') {\n              nextCB = path.indexOf(quote + ']', nextCB + 2);\n            }\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 2, nextCB)\n              .replace(new RegExp('\\\\' + quote, 'g'), quote));\n            index = nextCB + 2;\n          } else { // no enclosing quotes\n            let nextCB = path.indexOf(']', nextOB); // next close bracket\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 1, nextCB));\n            index = nextCB + 1;\n          }\n          if (path.charAt(index) === '.') { index++; }\n        }\n      }\n      return parts;\n    }\n    console.error('parseObjectPath error: Input object path must be a string.');\n  }\n}\n",
    "import * as _ from 'lodash';\n\nimport {\n  isArray, isEmpty, isNumber, isObject, isString\n} from './validator.functions';\nimport { hasOwn, uniqueItems, commonItems } from './utility.functions';\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\n\n/**\n * 'mergeSchemas' function\n *\n * Merges multiple JSON schemas into a single schema with combined rules.\n *\n * If able to logically merge properties from all schemas,\n * returns a single schema object containing all merged properties.\n *\n * Example: ({ a: b, max: 1 }, { c: d, max: 2 }) => { a: b, c: d, max: 1 }\n *\n * If unable to logically merge, returns an allOf schema object containing\n * an array of the original schemas;\n *\n * Example: ({ a: b }, { a: d }) => { allOf: [ { a: b }, { a: d } ] }\n *\n * @param  { any } schemas - one or more input schemas\n * @return { any } - merged schema\n */\nexport function mergeSchemas(...schemas) {\n  schemas = schemas.filter(schema => !isEmpty(schema));\n  if (schemas.some(schema => !isObject(schema))) { return null; }\n  const combinedSchema: any = {};\n  for (const schema of schemas) {\n    for (const key of Object.keys(schema)) {\n      const combinedValue = combinedSchema[key];\n      const schemaValue = schema[key];\n      if (!hasOwn(combinedSchema, key) || _.isEqual(combinedValue, schemaValue)) {\n        combinedSchema[key] = schemaValue;\n      } else {\n        switch (key) {\n          case 'allOf':\n            // Combine all items from both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.allOf = mergeSchemas(...combinedValue, ...schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'additionalItems': case 'additionalProperties':\n          case 'contains': case 'propertyNames':\n            // Merge schema objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema[key] = mergeSchemas(combinedValue, schemaValue);\n            // additionalProperties == false in any schema overrides all other values\n            } else if (\n              key === 'additionalProperties' &&\n              (combinedValue === false || schemaValue === false)\n            ) {\n              combinedSchema.combinedSchema = false;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'anyOf': case 'oneOf': case 'enum':\n            // Keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema[key] = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema[key].length) { return { allOf: [ ...schemas ] }; }\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'definitions':\n            // Combine keys from both objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // Don't combine matching keys with different values\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.definitions = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'dependencies':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys,\n            // converting from arrays to objects if necessary\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are arrays, include all items from both arrays,\n                // excluding duplicates\n                } else if (\n                  isArray(schemaValue[subKey]) && isArray(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    uniqueItems(...combinedObject[subKey], ...schemaValue[subKey]);\n                // If either key is an object, merge the schemas\n                } else if (\n                  (isArray(schemaValue[subKey]) || isObject(schemaValue[subKey])) &&\n                  (isArray(combinedObject[subKey]) || isObject(combinedObject[subKey]))\n                ) {\n                  // If either key is an array, convert it to an object first\n                  const required = isArray(combinedSchema.required) ?\n                    combinedSchema.required : [];\n                  const combinedDependency = isArray(combinedObject[subKey]) ?\n                    { required: uniqueItems(...required, combinedObject[subKey]) } :\n                    combinedObject[subKey];\n                  const schemaDependency = isArray(schemaValue[subKey]) ?\n                    { required: uniqueItems(...required, schemaValue[subKey]) } :\n                    schemaValue[subKey];\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedDependency, schemaDependency);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.dependencies = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'items':\n            // If arrays, keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema.items.length) { return { allOf: [ ...schemas ] }; }\n            // If both keys are objects, merge them\n            } else if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items = mergeSchemas(combinedValue, schemaValue);\n            // If object + array, combine object with each array item\n            } else if (isArray(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items =\n                combinedValue.map(item => mergeSchemas(item, schemaValue));\n            } else if (isObject(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items =\n                schemaValue.map(item => mergeSchemas(item, combinedValue));\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'multipleOf':\n            // TODO: Adjust to correctly handle decimal values\n            // If numbers, set to least common multiple\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              const gcd = (x, y) => !y ? x : gcd(y, x % y);\n              const lcm = (x, y) => (x * y) / gcd(x, y);\n              combinedSchema.multipleOf = lcm(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'maximum': case 'exclusiveMaximum': case 'maxLength':\n          case 'maxItems': case 'maxProperties':\n            // If numbers, set to lowest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.min(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'minimum': case 'exclusiveMinimum': case 'minLength':\n          case 'minItems': case 'minProperties':\n            // If numbers, set to highest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.max(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'not':\n            // Combine not values into anyOf array\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const notAnyOf = [combinedValue, schemaValue]\n                .reduce((notAnyOfArray, notSchema) =>\n                  isArray(notSchema.anyOf) &&\n                  Object.keys(notSchema).length === 1 ?\n                    [ ...notAnyOfArray, ...notSchema.anyOf ] :\n                    [ ...notAnyOfArray, notSchema ]\n                , []);\n              // TODO: Remove duplicate items from array\n              combinedSchema.not = { anyOf: notAnyOf };\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'patternProperties':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) && isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.patternProperties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'properties':\n            // Combine all keys from both objects\n            // unless additionalProperties === false\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              // If new schema has additionalProperties,\n              // merge or remove non-matching property keys in combined schema\n              if (hasOwn(schemaValue, 'additionalProperties')) {\n                Object.keys(combinedValue)\n                  .filter(combinedKey => !Object.keys(schemaValue).includes(combinedKey))\n                  .forEach(nonMatchingKey => {\n                    if (schemaValue.additionalProperties === false) {\n                      delete combinedObject[nonMatchingKey];\n                    } else if (isObject(schemaValue.additionalProperties)) {\n                      combinedObject[nonMatchingKey] = mergeSchemas(\n                        combinedObject[nonMatchingKey],\n                        schemaValue.additionalProperties\n                      );\n                    }\n                  });\n              }\n              for (const subKey of Object.keys(schemaValue)) {\n                if (_.isEqual(combinedObject[subKey], schemaValue[subKey]) || (\n                  !hasOwn(combinedObject, subKey) &&\n                  !hasOwn(combinedObject, 'additionalProperties')\n                )) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If combined schema has additionalProperties,\n                // merge or ignore non-matching property keys in new schema\n                } else if (\n                  !hasOwn(combinedObject, subKey) &&\n                  hasOwn(combinedObject, 'additionalProperties')\n                ) {\n                  // If combinedObject.additionalProperties === false,\n                  // do nothing (don't set key)\n                  // If additionalProperties is object, merge with new key\n                  if (isObject(combinedObject.additionalProperties)) {\n                    combinedObject[subKey] = mergeSchemas(\n                      combinedObject.additionalProperties, schemaValue[subKey]\n                    );\n                  }\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) &&\n                  isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.properties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'required':\n            // If arrays, include all items from both arrays, excluding duplicates\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.required = uniqueItems(...combinedValue, ...schemaValue);\n            // If booleans, aet true if either true\n            } else if (\n              typeof schemaValue === 'boolean' &&\n              typeof combinedValue === 'boolean'\n            ) {\n              combinedSchema.required = !!combinedValue || !!schemaValue;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case '$schema': case '$id': case 'id':\n            // Don't combine these keys\n          break;\n          case 'title': case 'description':\n            // Return the last value, overwriting any previous one\n            // These properties are not used for validation, so conflicts don't matter\n            combinedSchema[key] = schemaValue;\n          break;\n          case 'type':\n            if (\n              (isArray(schemaValue) || isString(schemaValue)) &&\n              (isArray(combinedValue) || isString(combinedValue))\n            ) {\n              const combinedTypes = commonItems(combinedValue, schemaValue);\n              if (!combinedTypes.length) { return { allOf: [ ...schemas ] }; }\n              combinedSchema.type = combinedTypes.length > 1 ? combinedTypes : combinedTypes[0];\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'uniqueItems':\n            // Set true if either true\n            combinedSchema.uniqueItems = !!combinedValue || !!schemaValue;\n          break;\n          default:\n            return { allOf: [ ...schemas ] };\n        }\n      }\n    }\n  }\n  return combinedSchema;\n}\n",
    "import * as _ from 'lodash';\n\nimport {\n  getType, hasValue, inArray, isArray, isEmpty, isFunction, isNumber, isObject,\n  isString\n} from './validator.functions';\nimport {\n  forEach, hasOwn, mergeFilteredObject, uniqueItems, commonItems\n} from './utility.functions';\nimport { mergeSchemas } from './merge-schemas.function';\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\nimport { JsonValidators } from './json.validators';\n\n/**\n * JSON Schema function library:\n *\n * buildSchemaFromLayout:   TODO: Write this function\n *\n * buildSchemaFromData:\n *\n * getFromSchema:\n *\n * removeRecursiveReferences:\n *\n * getInputType:\n *\n * checkInlineType:\n *\n * isInputRequired:\n *\n * updateInputOptions:\n *\n * getTitleMapFromOneOf:\n *\n * getControlValidators:\n *\n * resolveSchemaReferences:\n *\n * getSubSchema:\n *\n * combineAllOf:\n *\n * fixRequiredArrayProperties:\n */\n\n/**\n * 'buildSchemaFromLayout' function\n *\n * TODO: Build a JSON Schema from a JSON Form layout\n *\n * @param  { any[] } layout - The JSON Form layout\n * @return { any } - The new JSON Schema\n */\nexport function buildSchemaFromLayout(layout) {\n  return;\n  // let newSchema: any = { };\n  // const walkLayout = (layoutItems: any[], callback: Function): any[] => {\n  //   let returnArray: any[] = [];\n  //   for (let layoutItem of layoutItems) {\n  //     const returnItem: any = callback(layoutItem);\n  //     if (returnItem) { returnArray = returnArray.concat(callback(layoutItem)); }\n  //     if (layoutItem.items) {\n  //       returnArray = returnArray.concat(walkLayout(layoutItem.items, callback));\n  //     }\n  //   }\n  //   return returnArray;\n  // };\n  // walkLayout(layout, layoutItem => {\n  //   let itemKey: string;\n  //   if (typeof layoutItem === 'string') {\n  //     itemKey = layoutItem;\n  //   } else if (layoutItem.key) {\n  //     itemKey = layoutItem.key;\n  //   }\n  //   if (!itemKey) { return; }\n  //   //\n  // });\n}\n\n/**\n * 'buildSchemaFromData' function\n *\n * Build a JSON Schema from a data object\n *\n * @param  { any } data - The data object\n * @param  { boolean = false } requireAllFields - Require all fields?\n * @param  { boolean = true } isRoot - is root\n * @return { any } - The new JSON Schema\n */\nexport function buildSchemaFromData(\n  data, requireAllFields = false, isRoot = true\n) {\n  const newSchema: any = {};\n  const getFieldType = (value: any): string => {\n    const fieldType = getType(value, 'strict');\n    return { integer: 'number', null: 'string' }[fieldType] || fieldType;\n  };\n  const buildSubSchema = (value) =>\n    buildSchemaFromData(value, requireAllFields, false);\n  if (isRoot) { newSchema.$schema = 'http://json-schema.org/draft-06/schema#'; }\n  newSchema.type = getFieldType(data);\n  if (newSchema.type === 'object') {\n    newSchema.properties = {};\n    if (requireAllFields) { newSchema.required = []; }\n    for (const key of Object.keys(data)) {\n      newSchema.properties[key] = buildSubSchema(data[key]);\n      if (requireAllFields) { newSchema.required.push(key); }\n    }\n  } else if (newSchema.type === 'array') {\n    newSchema.items = data.map(buildSubSchema);\n    // If all items are the same type, use an object for items instead of an array\n    if ((new Set(data.map(getFieldType))).size === 1) {\n      newSchema.items = newSchema.items.reduce((a, b) => ({ ...a, ...b }), {});\n    }\n    if (requireAllFields) { newSchema.minItems = 1; }\n  }\n  return newSchema;\n}\n\n/**\n * 'getFromSchema' function\n *\n * Uses a JSON Pointer for a value within a data object to retrieve\n * the schema for that value within schema for the data object.\n *\n * The optional third parameter can also be set to return something else:\n * 'schema' (default): the schema for the value indicated by the data pointer\n * 'parentSchema': the schema for the value's parent object or array\n * 'schemaPointer': a pointer to the value's schema within the object's schema\n * 'parentSchemaPointer': a pointer to the schema for the value's parent object or array\n *\n * @param  { any } schema - The schema to get the sub-schema from\n * @param  { Pointer } dataPointer - JSON Pointer (string or array)\n * @param  { string = 'schema' } returnType - what to return?\n * @return { any } - The located sub-schema\n */\nexport function getFromSchema(schema, dataPointer, returnType = 'schema') {\n  const dataPointerArray: any[] = JsonPointer.parse(dataPointer);\n  if (dataPointerArray === null) {\n    console.error(`getFromSchema error: Invalid JSON Pointer: ${dataPointer}`);\n    return null;\n  }\n  let subSchema = schema;\n  const schemaPointer = [];\n  const length = dataPointerArray.length;\n  if (returnType.slice(0, 6) === 'parent') { dataPointerArray.length--; }\n  for (let i = 0; i < length; ++i) {\n    const parentSchema = subSchema;\n    const key = dataPointerArray[i];\n    let subSchemaFound = false;\n    if (typeof subSchema !== 'object') {\n      console.error(`getFromSchema error: Unable to find \"${key}\" key in schema.`);\n      console.error(schema);\n      console.error(dataPointer);\n      return null;\n    }\n    if (subSchema.type === 'array' && (!isNaN(key) || key === '-')) {\n      if (hasOwn(subSchema, 'items')) {\n        if (isObject(subSchema.items)) {\n          subSchemaFound = true;\n          subSchema = subSchema.items;\n          schemaPointer.push('items');\n        } else if (isArray(subSchema.items)) {\n          if (!isNaN(key) && subSchema.items.length >= +key) {\n            subSchemaFound = true;\n            subSchema = subSchema.items[+key];\n            schemaPointer.push('items', key);\n          }\n        }\n      }\n      if (!subSchemaFound && isObject(subSchema.additionalItems)) {\n        subSchemaFound = true;\n        subSchema = subSchema.additionalItems;\n        schemaPointer.push('additionalItems');\n      } else if (subSchema.additionalItems !== false) {\n        subSchemaFound = true;\n        subSchema = { };\n        schemaPointer.push('additionalItems');\n      }\n    } else if (subSchema.type === 'object') {\n      if (isObject(subSchema.properties) && hasOwn(subSchema.properties, key)) {\n        subSchemaFound = true;\n        subSchema = subSchema.properties[key];\n        schemaPointer.push('properties', key);\n      } else if (isObject(subSchema.additionalProperties)) {\n        subSchemaFound = true;\n        subSchema = subSchema.additionalProperties;\n        schemaPointer.push('additionalProperties');\n      } else if (subSchema.additionalProperties !== false) {\n        subSchemaFound = true;\n        subSchema = { };\n        schemaPointer.push('additionalProperties');\n      }\n    }\n    if (!subSchemaFound) {\n      console.error(`getFromSchema error: Unable to find \"${key}\" item in schema.`);\n      console.error(schema);\n      console.error(dataPointer);\n      return;\n    }\n  }\n  return returnType.slice(-7) === 'Pointer' ? schemaPointer : subSchema;\n}\n\n/**\n * 'removeRecursiveReferences' function\n *\n * Checks a JSON Pointer against a map of recursive references and returns\n * a JSON Pointer to the shallowest equivalent location in the same object.\n *\n * Using this functions enables an object to be constructed with unlimited\n * recursion, while maintaing a fixed set of metadata, such as field data types.\n * The object can grow as large as it wants, and deeply recursed nodes can\n * just refer to the metadata for their shallow equivalents, instead of having\n * to add additional redundant metadata for each recursively added node.\n *\n * Example:\n *\n * pointer:         '/stuff/and/more/and/more/and/more/and/more/stuff'\n * recursiveRefMap: [['/stuff/and/more/and/more', '/stuff/and/more/']]\n * returned:        '/stuff/and/more/stuff'\n *\n * @param  { Pointer } pointer -\n * @param  { Map<string, string> } recursiveRefMap -\n * @param  { Map<string, number> = new Map() } arrayMap - optional\n * @return { string } -\n */\nexport function removeRecursiveReferences(\n  pointer, recursiveRefMap, arrayMap = new Map()\n) {\n  if (!pointer) { return ''; }\n  let genericPointer =\n    JsonPointer.toGenericPointer(JsonPointer.compile(pointer), arrayMap);\n  if (genericPointer.indexOf('/') === -1) { return genericPointer; }\n  let possibleReferences = true;\n  while (possibleReferences) {\n    possibleReferences = false;\n    recursiveRefMap.forEach((toPointer, fromPointer) => {\n      if (JsonPointer.isSubPointer(toPointer, fromPointer)) {\n        while (JsonPointer.isSubPointer(fromPointer, genericPointer, true)) {\n          genericPointer = JsonPointer.toGenericPointer(\n            toPointer + genericPointer.slice(fromPointer.length), arrayMap\n          );\n          possibleReferences = true;\n        }\n      }\n    });\n  }\n  return genericPointer;\n}\n\n/**\n * 'getInputType' function\n *\n * @param  { any } schema\n * @param  { any = null } layoutNode\n * @return { string }\n */\nexport function getInputType(schema, layoutNode: any = null) {\n  // x-schema-form = Angular Schema Form compatibility\n  // widget & component = React Jsonschema Form compatibility\n  const controlType = JsonPointer.getFirst([\n    [schema, '/x-schema-form/type'],\n    [schema, '/x-schema-form/widget/component'],\n    [schema, '/x-schema-form/widget'],\n    [schema, '/widget/component'],\n    [schema, '/widget']\n  ]);\n  if (isString(controlType)) { return checkInlineType(controlType, schema, layoutNode); }\n  let schemaType = schema.type;\n  if (schemaType) {\n    if (isArray(schemaType)) { // If multiple types listed, use most inclusive type\n      schemaType =\n        inArray('object', schemaType) && hasOwn(schema, 'properties') ? 'object' :\n        inArray('array', schemaType) && hasOwn(schema, 'items') ? 'array' :\n        inArray('array', schemaType) && hasOwn(schema, 'additionalItems') ? 'array' :\n        inArray('string', schemaType) ? 'string' :\n        inArray('number', schemaType) ? 'number' :\n        inArray('integer', schemaType) ? 'integer' :\n        inArray('boolean', schemaType) ? 'boolean' : 'unknown';\n    }\n    if (schemaType === 'boolean') { return 'checkbox'; }\n    if (schemaType === 'object') {\n      if (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) {\n        return 'section';\n      }\n      // TODO: Figure out how to handle additionalProperties\n      if (hasOwn(schema, '$ref')) { return '$ref'; }\n    }\n    if (schemaType === 'array') {\n      const itemsObject = JsonPointer.getFirst([\n        [schema, '/items'],\n        [schema, '/additionalItems']\n      ]) || {};\n      return hasOwn(itemsObject, 'enum') && schema.maxItems !== 1 ?\n        checkInlineType('checkboxes', schema, layoutNode) : 'array';\n    }\n    if (schemaType === 'null') { return 'none'; }\n    if (JsonPointer.has(layoutNode, '/options/titleMap') ||\n      hasOwn(schema, 'enum') || getTitleMapFromOneOf(schema, null, true)\n    ) { return 'select'; }\n    if (schemaType === 'number' || schemaType === 'integer') {\n      return (schemaType === 'integer' || hasOwn(schema, 'multipleOf')) &&\n        hasOwn(schema, 'maximum') && hasOwn(schema, 'minimum') ? 'range' : schemaType;\n    }\n    if (schemaType === 'string') {\n      return {\n        'color': 'color',\n        'date': 'date',\n        'date-time': 'datetime-local',\n        'email': 'email',\n        'uri': 'url',\n      }[schema.format] || 'text';\n    }\n  }\n  if (hasOwn(schema, '$ref')) { return '$ref'; }\n  if (isArray(schema.oneOf) || isArray(schema.anyOf)) { return 'one-of'; }\n  console.error(`getInputType error: Unable to determine input type for ${schemaType}`);\n  console.error('schema', schema);\n  if (layoutNode) { console.error('layoutNode', layoutNode); }\n  return 'none';\n}\n\n/**\n * 'checkInlineType' function\n *\n * Checks layout and schema nodes for 'inline: true', and converts\n * 'radios' or 'checkboxes' to 'radios-inline' or 'checkboxes-inline'\n *\n * @param  { string } controlType -\n * @param  { any } schema -\n * @param  { any = null } layoutNode -\n * @return { string }\n */\nexport function checkInlineType(controlType, schema, layoutNode: any = null) {\n  if (!isString(controlType) || (\n    controlType.slice(0, 8) !== 'checkbox' && controlType.slice(0, 5) !== 'radio'\n  )) {\n    return controlType;\n  }\n  if (\n    JsonPointer.getFirst([\n      [layoutNode, '/inline'],\n      [layoutNode, '/options/inline'],\n      [schema, '/inline'],\n      [schema, '/x-schema-form/inline'],\n      [schema, '/x-schema-form/options/inline'],\n      [schema, '/x-schema-form/widget/inline'],\n      [schema, '/x-schema-form/widget/component/inline'],\n      [schema, '/x-schema-form/widget/component/options/inline'],\n      [schema, '/widget/inline'],\n      [schema, '/widget/component/inline'],\n      [schema, '/widget/component/options/inline'],\n    ]) === true\n  ) {\n    return controlType.slice(0, 5) === 'radio' ?\n      'radios-inline' : 'checkboxes-inline';\n  } else {\n    return controlType;\n  }\n}\n\n/**\n * 'isInputRequired' function\n *\n * Checks a JSON Schema to see if an item is required\n *\n * @param  { any } schema - the schema to check\n * @param  { string } schemaPointer - the pointer to the item to check\n * @return { boolean } - true if the item is required, false if not\n */\nexport function isInputRequired(schema, schemaPointer) {\n  if (!isObject(schema)) {\n    console.error('isInputRequired error: Input schema must be an object.');\n    return false;\n  }\n  const listPointerArray = JsonPointer.parse(schemaPointer);\n  if (isArray(listPointerArray)) {\n    if (!listPointerArray.length) { return schema.required === true; }\n    const keyName = listPointerArray.pop();\n    const nextToLastKey = listPointerArray[listPointerArray.length - 1];\n    if (['properties', 'additionalProperties', 'patternProperties', 'items', 'additionalItems']\n      .includes(nextToLastKey)\n    ) {\n      listPointerArray.pop();\n    }\n    const parentSchema = JsonPointer.get(schema, listPointerArray) || {};\n    if (isArray(parentSchema.required)) {\n      return parentSchema.required.includes(keyName);\n    }\n    if (parentSchema.type === 'array') {\n      return hasOwn(parentSchema, 'minItems') &&\n        isNumber(keyName) &&\n        +parentSchema.minItems > +keyName;\n    }\n  }\n  return false;\n}\n\n/**\n * 'updateInputOptions' function\n *\n * @param  { any } layoutNode\n * @param  { any } schema\n * @param  { any } jsf\n * @return { void }\n */\nexport function updateInputOptions(layoutNode, schema, jsf) {\n  if (!isObject(layoutNode) || !isObject(layoutNode.options)) { return; }\n\n  // Set all option values in layoutNode.options\n  const newOptions: any = { };\n  const fixUiKeys = key => key.slice(0, 3).toLowerCase() === 'ui:' ? key.slice(3) : key;\n  mergeFilteredObject(newOptions, jsf.formOptions.defautWidgetOptions, [], fixUiKeys);\n  [ [ JsonPointer.get(schema, '/ui:widget/options'), [] ],\n    [ JsonPointer.get(schema, '/ui:widget'), [] ],\n    [ schema, [\n      'additionalProperties', 'additionalItems', 'properties', 'items',\n      'required', 'type', 'x-schema-form', '$ref'\n    ] ],\n    [ JsonPointer.get(schema, '/x-schema-form/options'), [] ],\n    [ JsonPointer.get(schema, '/x-schema-form'), ['items', 'options'] ],\n    [ layoutNode, [\n      '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n      'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n    ] ],\n    [ layoutNode.options, [] ],\n  ].forEach(([ object, excludeKeys ]) =>\n    mergeFilteredObject(newOptions, object, excludeKeys, fixUiKeys)\n  );\n  if (!hasOwn(newOptions, 'titleMap')) {\n    let newTitleMap: any = null;\n    newTitleMap = getTitleMapFromOneOf(schema, newOptions.flatList);\n    if (newTitleMap) { newOptions.titleMap = newTitleMap; }\n    if (!hasOwn(newOptions, 'titleMap') && !hasOwn(newOptions, 'enum') && hasOwn(schema, 'items')) {\n      if (JsonPointer.has(schema, '/items/titleMap')) {\n        newOptions.titleMap = schema.items.titleMap;\n      } else if (JsonPointer.has(schema, '/items/enum')) {\n        newOptions.enum = schema.items.enum;\n        if (!hasOwn(newOptions, 'enumNames') && JsonPointer.has(schema, '/items/enumNames')) {\n          newOptions.enumNames = schema.items.enumNames;\n        }\n      } else if (JsonPointer.has(schema, '/items/oneOf')) {\n        newTitleMap = getTitleMapFromOneOf(schema.items, newOptions.flatList);\n        if (newTitleMap) { newOptions.titleMap = newTitleMap; }\n      }\n    }\n  }\n\n  // If schema type is integer, enforce by setting multipleOf = 1\n  if (schema.type === 'integer' && !hasValue(newOptions.multipleOf)) {\n    newOptions.multipleOf = 1;\n  }\n\n  // Copy any typeahead word lists to options.typeahead.source\n  if (JsonPointer.has(newOptions, '/autocomplete/source')) {\n    newOptions.typeahead = newOptions.autocomplete;\n  } else if (JsonPointer.has(newOptions, '/tagsinput/source')) {\n    newOptions.typeahead = newOptions.tagsinput;\n  } else if (JsonPointer.has(newOptions, '/tagsinput/typeahead/source')) {\n    newOptions.typeahead = newOptions.tagsinput.typeahead;\n  }\n\n  layoutNode.options = newOptions;\n}\n\n/**\n * 'getTitleMapFromOneOf' function\n *\n * @param  { schema } schema\n * @param  { boolean = null } flatList\n * @param  { boolean = false } validateOnly\n * @return { validators }\n */\nexport function getTitleMapFromOneOf(\n  schema: any = {}, flatList: boolean = null, validateOnly = false\n) {\n  let titleMap = null;\n  const oneOf = schema.oneOf || schema.anyOf || null;\n  if (isArray(oneOf) && oneOf.every(item => item.title)) {\n    if (oneOf.every(item => isArray(item.enum) && item.enum.length === 1)) {\n      if (validateOnly) { return true; }\n      titleMap = oneOf.map(item => ({ name: item.title, value: item.enum[0] }));\n    } else if (oneOf.every(item => item.const)) {\n      if (validateOnly) { return true; }\n      titleMap = oneOf.map(item => ({ name: item.title, value: item.const }));\n    }\n\n    // if flatList !== false and some items have colons, make grouped map\n    if (flatList !== false && (titleMap || [])\n      .filter(title => ((title || {}).name || '').indexOf(': ')).length > 1\n    ) {\n\n      // Split name on first colon to create grouped map (name -> group: name)\n      const newTitleMap = titleMap.map(title => {\n        const [group, name] = title.name.split(/: (.+)/);\n        return group && name ? { ...title, group, name } : title;\n      });\n\n      // If flatList === true or at least one group has multiple items, use grouped map\n      if (flatList === true || newTitleMap.some((title, index) => index &&\n        hasOwn(title, 'group') && title.group === newTitleMap[index - 1].group\n      )) {\n        titleMap = newTitleMap;\n      }\n    }\n  }\n  return validateOnly ? false : titleMap;\n}\n\n/**\n * 'getControlValidators' function\n *\n * @param { any } schema\n * @return { validators }\n */\nexport function getControlValidators(schema) {\n  if (!isObject(schema)) { return null; }\n  const validators: any = { };\n  if (hasOwn(schema, 'type')) {\n    switch (schema.type) {\n      case 'string':\n        forEach(['pattern', 'format', 'minLength', 'maxLength'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'number': case 'integer':\n        forEach(['Minimum', 'Maximum'], (ucLimit) => {\n          const eLimit = 'exclusive' + ucLimit;\n          const limit = ucLimit.toLowerCase();\n          if (hasOwn(schema, limit)) {\n            const exclusive = hasOwn(schema, eLimit) && schema[eLimit] === true;\n            validators[limit] = [schema[limit], exclusive];\n          }\n        });\n        forEach(['multipleOf', 'type'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'object':\n        forEach(['minProperties', 'maxProperties', 'dependencies'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'array':\n        forEach(['minItems', 'maxItems', 'uniqueItems'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n    }\n  }\n  if (hasOwn(schema, 'enum')) { validators.enum = [schema.enum]; }\n  return validators;\n}\n\n/**\n * 'resolveSchemaReferences' function\n *\n * Find all $ref links in schema and save links and referenced schemas in\n * schemaRefLibrary, schemaRecursiveRefMap, and dataRecursiveRefMap\n *\n * @param { any } schema\n * @param { any } schemaRefLibrary\n * @param { Map<string, string> } schemaRecursiveRefMap\n * @param { Map<string, string> } dataRecursiveRefMap\n * @param { Map<string, number> } arrayMap\n * @return { any }\n */\nexport function resolveSchemaReferences(\n  schema, schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, arrayMap\n) {\n  if (!isObject(schema)) {\n    console.error('resolveSchemaReferences error: schema must be an object.');\n    return;\n  }\n  const refLinks = new Set<string>();\n  const refMapSet = new Set<string>();\n  const refMap = new Map<string, string>();\n  const recursiveRefMap = new Map<string, string>();\n  const refLibrary: any = {};\n\n  // Search schema for all $ref links, and build full refLibrary\n  JsonPointer.forEachDeep(schema, (subSchema, subSchemaPointer) => {\n    if (hasOwn(subSchema, '$ref') && isString(subSchema['$ref'])) {\n      const refPointer = JsonPointer.compile(subSchema['$ref']);\n      refLinks.add(refPointer);\n      refMapSet.add(subSchemaPointer + '~~' + refPointer);\n      refMap.set(subSchemaPointer, refPointer);\n    }\n  });\n  refLinks.forEach(ref => refLibrary[ref] = getSubSchema(schema, ref));\n\n  // Follow all ref links and save in refMapSet,\n  // to find any multi-link recursive refernces\n  let checkRefLinks = true;\n  while (checkRefLinks) {\n    checkRefLinks = false;\n    Array.from(refMap).forEach(([fromRef1, toRef1]) => Array.from(refMap)\n      .filter(([fromRef2, toRef2]) =>\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef2, toRef1, true) &&\n        !refMapSet.has(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2)\n      )\n      .forEach(([fromRef2, toRef2]) => {\n        refMapSet.add(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2);\n        checkRefLinks = true;\n      })\n    );\n  }\n\n  // Build full recursiveRefMap\n  // First pass - save all internally recursive refs from refMapSet\n  Array.from(refMapSet)\n    .map(refLink => refLink.split('~~'))\n    .filter(([fromRef, toRef]) => JsonPointer.isSubPointer(toRef, fromRef))\n    .forEach(([fromRef, toRef]) => recursiveRefMap.set(fromRef, toRef));\n  // Second pass - create recursive versions of any other refs that link to recursive refs\n  Array.from(refMap)\n    .filter(([fromRef1, toRef1]) => Array.from(recursiveRefMap.keys())\n      .every(fromRef2 => !JsonPointer.isSubPointer(fromRef1, fromRef2, true))\n    )\n    .forEach(([fromRef1, toRef1]) => Array.from(recursiveRefMap)\n      .filter(([fromRef2, toRef2]) =>\n        !recursiveRefMap.has(fromRef1 + fromRef2.slice(toRef1.length)) &&\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef1, fromRef1, true)\n      )\n      .forEach(([fromRef2, toRef2]) => recursiveRefMap.set(\n        fromRef1 + fromRef2.slice(toRef1.length),\n        fromRef1 + toRef2.slice(toRef1.length)\n      ))\n    );\n\n  // Create compiled schema by replacing all non-recursive $ref links with\n  // thieir linked schemas and, where possible, combining schemas in allOf arrays.\n  let compiledSchema = { ...schema };\n  delete compiledSchema.definitions;\n  compiledSchema =\n    getSubSchema(compiledSchema, '', refLibrary, recursiveRefMap);\n\n  // Make sure all remaining schema $refs are recursive, and build final\n  // schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap\n  JsonPointer.forEachDeep(compiledSchema, (subSchema, subSchemaPointer) => {\n    if (isString(subSchema['$ref'])) {\n      let refPointer = JsonPointer.compile(subSchema['$ref']);\n      if (!JsonPointer.isSubPointer(refPointer, subSchemaPointer, true)) {\n        refPointer = removeRecursiveReferences(subSchemaPointer, recursiveRefMap);\n        JsonPointer.set(compiledSchema, subSchemaPointer, { $ref: `#${refPointer}` });\n      }\n      if (!hasOwn(schemaRefLibrary, 'refPointer')) {\n        schemaRefLibrary[refPointer] = !refPointer.length ? compiledSchema :\n          getSubSchema(compiledSchema, refPointer, schemaRefLibrary, recursiveRefMap);\n      }\n      if (!schemaRecursiveRefMap.has(subSchemaPointer)) {\n        schemaRecursiveRefMap.set(subSchemaPointer, refPointer);\n      }\n      const fromDataRef = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);\n      if (!dataRecursiveRefMap.has(fromDataRef)) {\n        const toDataRef = JsonPointer.toDataPointer(refPointer, compiledSchema);\n        dataRecursiveRefMap.set(fromDataRef, toDataRef);\n      }\n    }\n    if (subSchema.type === 'array' &&\n      (hasOwn(subSchema, 'items') || hasOwn(subSchema, 'additionalItems'))\n    ) {\n      const dataPointer = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);\n      if (!arrayMap.has(dataPointer)) {\n        const tupleItems = isArray(subSchema.items) ? subSchema.items.length : 0;\n        arrayMap.set(dataPointer, tupleItems);\n      }\n    }\n  }, true);\n  return compiledSchema;\n}\n\n/**\n * 'getSubSchema' function\n *\n * @param  { any } schema\n * @param  { Pointer } pointer\n * @param  { object } schemaRefLibrary\n * @param  { Map<string, string> } schemaRecursiveRefMap\n * @param  { string[] = [] } usedPointers\n * @return { any }\n */\nexport function getSubSchema(\n  schema, pointer, schemaRefLibrary = null,\n  schemaRecursiveRefMap: Map<string, string> = null, usedPointers: string[] = []\n) {\n  if (!schemaRefLibrary || !schemaRecursiveRefMap) {\n    return JsonPointer.getCopy(schema, pointer);\n  }\n  if (typeof pointer !== 'string') { pointer = JsonPointer.compile(pointer); }\n  usedPointers = [ ...usedPointers, pointer ];\n  let newSchema: any = null;\n  if (pointer === '') {\n    newSchema = _.cloneDeep(schema);\n  } else {\n    const shortPointer = removeRecursiveReferences(pointer, schemaRecursiveRefMap);\n    if (shortPointer !== pointer) { usedPointers = [ ...usedPointers, shortPointer ]; }\n    newSchema = JsonPointer.getFirstCopy([\n      [schemaRefLibrary, [shortPointer]],\n      [schema, pointer],\n      [schema, shortPointer]\n    ]);\n  }\n  return JsonPointer.forEachDeepCopy(newSchema, (subSchema, subPointer) => {\n    if (isObject(subSchema)) {\n\n      // Replace non-recursive $ref links with referenced schemas\n      if (isString(subSchema.$ref)) {\n        const refPointer = JsonPointer.compile(subSchema.$ref);\n        if (refPointer.length && usedPointers.every(ptr =>\n          !JsonPointer.isSubPointer(refPointer, ptr, true)\n        )) {\n          const refSchema = getSubSchema(\n            schema, refPointer, schemaRefLibrary, schemaRecursiveRefMap, usedPointers\n          );\n          if (Object.keys(subSchema).length === 1) {\n            return refSchema;\n          } else {\n            const extraKeys = { ...subSchema };\n            delete extraKeys.$ref;\n            return mergeSchemas(refSchema, extraKeys);\n          }\n        }\n      }\n\n      // TODO: Convert schemas with 'type' arrays to 'oneOf'\n\n      // Combine allOf subSchemas\n      if (isArray(subSchema.allOf)) { return combineAllOf(subSchema); }\n\n      // Fix incorrectly placed array object required lists\n      if (subSchema.type === 'array' && isArray(subSchema.required)) {\n        return fixRequiredArrayProperties(subSchema);\n      }\n    }\n    return subSchema;\n  }, true, <string>pointer);\n}\n\n/**\n * 'combineAllOf' function\n *\n * Attempt to convert an allOf schema object into\n * a non-allOf schema object with equivalent rules.\n *\n * @param  { any } schema - allOf schema object\n * @return { any } - converted schema object\n */\nexport function combineAllOf(schema) {\n  if (!isObject(schema) || !isArray(schema.allOf)) { return schema; }\n  let mergedSchema = mergeSchemas(...schema.allOf);\n  if (Object.keys(schema).length > 1) {\n    const extraKeys = { ...schema };\n    delete extraKeys.allOf;\n    mergedSchema = mergeSchemas(mergedSchema, extraKeys);\n  }\n  return mergedSchema;\n}\n\n/**\n * 'fixRequiredArrayProperties' function\n *\n * Fixes an incorrectly placed required list inside an array schema, by moving\n * it into items.properties or additionalItems.properties, where it belongs.\n *\n * @param  { any } schema - allOf schema object\n * @return { any } - converted schema object\n */\nexport function fixRequiredArrayProperties(schema) {\n  if (schema.type === 'array' && isArray(schema.required)) {\n    const itemsObject = hasOwn(schema.items, 'properties') ? 'items' :\n      hasOwn(schema.additionalItems, 'properties') ? 'additionalItems' : null;\n    if (itemsObject && !hasOwn(schema[itemsObject], 'required') && (\n      hasOwn(schema[itemsObject], 'additionalProperties') ||\n      schema.required.every(key => hasOwn(schema[itemsObject].properties, key))\n    )) {\n      schema = _.cloneDeep(schema);\n      schema[itemsObject].required = schema.required;\n      delete schema.required;\n    }\n  }\n  return schema;\n}\n",
    "// tslint:disable max-line-length\n// updated from AJV fast format regular expressions:\n// https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n\nexport const jsonSchemaFormatTests = {\n\n  'date': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n\n  'time': /^[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // Modified to allow incomplete entries, such as\n  // \"2000-03-14T01:59:26.535\" (needs \"Z\") or \"2000-03-14T01:59\" (needs \":00Z\")\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d(?::[0-5]\\d)?(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  'email': /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n\n  'hostname': /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i,\n\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  'ipv4': /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  'ipv6': /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  'uri': /^(?:[a-z][a-z0-9+-.]*)(?::|\\/)\\/?[^\\s]*$/i,\n\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i,\n\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  'uri-template': /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  // @todo Delete current URL in favour of the commented out URL rule when this ajv issue is fixed https://github.com/eslint/eslint/issues/7983.\n  // URL: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  'url': /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i,\n\n  // uuid: http://tools.ietf.org/html/rfc4122\n  'uuid': /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\n  // optimized https://gist.github.com/olmokramer/82ccce673f86db7cda5e\n  'color': /^\\s*(#(?:[\\da-f]{3}){1,2}|rgb\\((?:\\d{1,3},\\s*){2}\\d{1,3}\\)|rgba\\((?:\\d{1,3},\\s*){3}\\d*\\.?\\d+\\)|hsl\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2}\\)|hsla\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2},\\s*\\d*\\.?\\d+\\))\\s*$/gi,\n\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\n  'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\n  'regex': function(str) {\n    if (/[^\\\\]\\\\Z/.test(str)) { return false; }\n    try {\n      // tslint:disable-next-line no-unused-expression\n      new RegExp(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n};\n\nexport type JsonSchemaFormatNames =\n  'date'|'time'|'date-time'|'email'|'hostname'|'ipv4'|'ipv6'|\n  'uri'|'uri-reference'|'uri-template'|'url'|'uuid'|'color'|\n  'json-pointer'|'relative-json-pointer'|'regex';\n",
    "import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\nimport { Observable } from 'rxjs-compat/Observable';\nimport { forkJoin } from 'rxjs-compat/observable/forkJoin';\nimport { map } from 'rxjs-compat/operator/map';\n\nimport * as _ from 'lodash';\n\nimport {\n  _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors,\n  isEmpty, isDefined, hasValue, isString, isNumber, isBoolean, isArray,\n  getType, isType, toJavaScriptType, toObservable, xor, SchemaPrimitiveType,\n  PlainObject, IValidatorFn, AsyncIValidatorFn\n} from './validator.functions';\nimport { forEachCopy } from './utility.functions';\nimport { jsonSchemaFormatTests, JsonSchemaFormatNames } from './format-regex.constants';\n\n/**\n * 'JsonValidators' class\n *\n * Provides an extended set of validators to be used by form controls,\n * compatible with standard JSON Schema validation options.\n * http://json-schema.org/latest/json-schema-validation.html\n *\n * Note: This library is designed as a drop-in replacement for the Angular\n * Validators library, and except for one small breaking change to the 'pattern'\n * validator (described below) it can even be imported as a substitute, like so:\n *\n *   import { JsonValidators as Validators } from 'json-validators';\n *\n * and it should work with existing code as a complete replacement.\n *\n * The one exception is the 'pattern' validator, which has been changed to\n * matche partial values by default (the standard 'pattern' validator wrapped\n * all patterns in '^' and '$', forcing them to always match an entire value).\n * However, the old behavior can be restored by simply adding '^' and '$'\n * around your patterns, or by passing an optional second parameter of TRUE.\n * This change is to make the 'pattern' validator match the behavior of a\n * JSON Schema pattern, which allows partial matches, rather than the behavior\n * of an HTML input control pattern, which does not.\n *\n * This library replaces Angular's validators and combination functions\n * with the following validators and transformation functions:\n *\n * Validators:\n *   For all formControls:     required (*), type, enum, const\n *   For text formControls:    minLength (*), maxLength (*), pattern (*), format\n *   For numeric formControls: maximum, exclusiveMaximum,\n *                             minimum, exclusiveMinimum, multipleOf\n *   For formGroup objects:    minProperties, maxProperties, dependencies\n *   For formArray arrays:     minItems, maxItems, uniqueItems, contains\n *   Not used by JSON Schema:  min (*), max (*), requiredTrue (*), email (*)\n * (Validators originally included with Angular are maked with (*).)\n *\n * NOTE / TODO: The dependencies validator is not complete.\n * NOTE / TODO: The contains validator is not complete.\n *\n * Validators not used by JSON Schema (but included for compatibility)\n * and their JSON Schema equivalents:\n *\n *   Angular validator | JSON Schema equivalent\n *   ------------------|-----------------------\n *     min(number)     |   minimum(number)\n *     max(number)     |   maximum(number)\n *     requiredTrue()  |   const(true)\n *     email()         |   format('email')\n *\n * Validator transformation functions:\n *   composeAnyOf, composeOneOf, composeAllOf, composeNot\n * (Angular's original combination funciton, 'compose', is also included for\n * backward compatibility, though it is functionally equivalent to composeAllOf,\n * asside from its more generic error message.)\n *\n * All validators have also been extended to accept an optional second argument\n * which, if passed a TRUE value, causes the validator to perform the opposite\n * of its original finction. (This is used internally to enable 'not' and\n * 'composeOneOf' to function and return useful error messages.)\n *\n * The 'required' validator has also been overloaded so that if called with\n * a boolean parameter (or no parameters) it returns the original validator\n * function (rather than executing it). However, if it is called with an\n * AbstractControl parameter (as was previously required), it behaves\n * exactly as before.\n *\n * This enables all validators (including 'required') to be constructed in\n * exactly the same way, so they can be automatically applied using the\n * equivalent key names and values taken directly from a JSON Schema.\n *\n * This source code is partially derived from Angular,\n * which is Copyright (c) 2014-2017 Google, Inc.\n * Use of this source code is therefore governed by the same MIT-style license\n * that can be found in the LICENSE file at https://angular.io/license\n *\n * Original Angular Validators:\n * https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n */\nexport class JsonValidators {\n\n  /**\n   * Validator functions:\n   *\n   * For all formControls:     required, type, enum, const\n   * For text formControls:    minLength, maxLength, pattern, format\n   * For numeric formControls: maximum, exclusiveMaximum,\n   *                           minimum, exclusiveMinimum, multipleOf\n   * For formGroup objects:    minProperties, maxProperties, dependencies\n   * For formArray arrays:     minItems, maxItems, uniqueItems, contains\n   *\n   * TODO: finish dependencies validator\n   */\n\n  /**\n   * 'required' validator\n   *\n   * This validator is overloaded, compared to the default required validator.\n   * If called with no parameters, or TRUE, this validator returns the\n   * 'required' validator function (rather than executing it). This matches\n   * the behavior of all other validators in this library.\n   *\n   * If this validator is called with an AbstractControl parameter\n   * (as was previously required) it behaves the same as Angular's default\n   * required validator, and returns an error if the control is empty.\n   *\n   * Old behavior: (if input type = AbstractControl)\n   * @param {AbstractControl} control - required control\n   * @return {{[key: string]: boolean}} - returns error message if no input\n   *\n   * New behavior: (if no input, or input type = boolean)\n   * @param {boolean = true} required? - true to validate, false to disable\n   * @return {IValidatorFn} - returns the 'required' validator function itself\n   */\n  static required(input: AbstractControl): ValidationErrors|null;\n  static required(input?: boolean): IValidatorFn;\n\n  static required(input?: AbstractControl|boolean): ValidationErrors|null|IValidatorFn {\n    if (input === undefined) { input = true; }\n    switch (input) {\n      case true: // Return required function (do not execute it yet)\n        return (control: AbstractControl, invert = false): ValidationErrors|null => {\n          if (invert) { return null; } // if not required, always return valid\n          return hasValue(control.value) ? null : { 'required': true };\n        };\n      case false: // Do nothing (if field is not required, it is always valid)\n        return JsonValidators.nullValidator;\n      default: // Execute required function\n        return hasValue((<AbstractControl>input).value) ? null : { 'required': true };\n    }\n  }\n\n  /**\n   * 'type' validator\n   *\n   * Requires a control to only accept values of a specified type,\n   * or one of an array of types.\n   *\n   * Note: SchemaPrimitiveType = 'string'|'number'|'integer'|'boolean'|'null'\n   *\n   * @param {SchemaPrimitiveType|SchemaPrimitiveType[]} type - type(s) to accept\n   * @return {IValidatorFn}\n   */\n  static type(requiredType: SchemaPrimitiveType|SchemaPrimitiveType[]): IValidatorFn {\n    if (!hasValue(requiredType)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isValid = isArray(requiredType) ?\n        (<SchemaPrimitiveType[]>requiredType).some(type => isType(currentValue, type)) :\n        isType(currentValue, <SchemaPrimitiveType>requiredType);\n      return xor(isValid, invert) ?\n        null : { 'type': { requiredType, currentValue } };\n    };\n  }\n\n  /**\n   * 'enum' validator\n   *\n   * Requires a control to have a value from an enumerated list of values.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null enum values.\n   *\n   * @param {any[]} allowedValues - array of acceptable values\n   * @return {IValidatorFn}\n   */\n  static enum(allowedValues: any[]): IValidatorFn {\n    if (!isArray(allowedValues)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqual = (enumValue, inputValue) =>\n        enumValue === inputValue ||\n        (isNumber(enumValue) && +inputValue === +enumValue) ||\n        (isBoolean(enumValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === enumValue) ||\n        (enumValue === null && !hasValue(inputValue)) ||\n        _.isEqual(enumValue, inputValue);\n      const isValid = isArray(currentValue) ?\n        currentValue.every(inputValue => allowedValues.some(enumValue =>\n          isEqual(enumValue, inputValue)\n        )) :\n        allowedValues.some(enumValue => isEqual(enumValue, currentValue));\n      return xor(isValid, invert) ?\n        null : { 'enum': { allowedValues, currentValue } };\n    };\n  }\n\n  /**\n   * 'const' validator\n   *\n   * Requires a control to have a specific value.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null values.\n   *\n   * TODO: modify to work with objects\n   *\n   * @param {any[]} requiredValue - required value\n   * @return {IValidatorFn}\n   */\n  static const(requiredValue: any): IValidatorFn {\n    if (!hasValue(requiredValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqual = (constValue, inputValue) =>\n        constValue === inputValue ||\n        isNumber(constValue) && +inputValue === +constValue ||\n        isBoolean(constValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === constValue ||\n        constValue === null && !hasValue(inputValue);\n      const isValid = isEqual(requiredValue, currentValue);\n      return xor(isValid, invert) ?\n        null : { 'const': { requiredValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minLength' validator\n   *\n   * Requires a control's text value to be greater than a specified length.\n   *\n   * @param {number} minimumLength - minimum allowed string length\n   * @param {boolean = false} invert - instead return error object only if valid\n   * @return {IValidatorFn}\n   */\n  static minLength(minimumLength: number): IValidatorFn {\n    if (!hasValue(minimumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength >= minimumLength;\n      return xor(isValid, invert) ?\n        null : { 'minLength': { minimumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'maxLength' validator\n   *\n   * Requires a control's text value to be less than a specified length.\n   *\n   * @param {number} maximumLength - maximum allowed string length\n   * @param {boolean = false} invert - instead return error object only if valid\n   * @return {IValidatorFn}\n   */\n  static maxLength(maximumLength: number): IValidatorFn {\n    if (!hasValue(maximumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength <= maximumLength;\n      return xor(isValid, invert) ?\n        null : { 'maxLength': { maximumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'pattern' validator\n   *\n   * Note: NOT the same as Angular's default pattern validator.\n   *\n   * Requires a control's value to match a specified regular expression pattern.\n   *\n   * This validator changes the behavior of default pattern validator\n   * by replacing RegExp(`^${pattern}$`) with RegExp(`${pattern}`),\n   * which allows for partial matches.\n   *\n   * To return to the default funcitonality, and match the entire string,\n   * pass TRUE as the optional second parameter.\n   *\n   * @param {string} pattern - regular expression pattern\n   * @param {boolean = false} wholeString - match whole value string?\n   * @return {IValidatorFn}\n   */\n  static pattern(pattern: string|RegExp, wholeString = false): IValidatorFn {\n    if (!hasValue(pattern)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let regex: RegExp;\n      let requiredPattern: string;\n      if (typeof pattern === 'string') {\n        requiredPattern = (wholeString) ? `^${pattern}$` : pattern;\n        regex = new RegExp(requiredPattern);\n      } else {\n        requiredPattern = pattern.toString();\n        regex = pattern;\n      }\n      const currentValue: string = control.value;\n      const isValid = isString(currentValue) ? regex.test(currentValue) : false;\n      return xor(isValid, invert) ?\n        null : { 'pattern': { requiredPattern, currentValue } };\n    };\n  }\n\n  /**\n   * 'format' validator\n   *\n   * Requires a control to have a value of a certain format.\n   *\n   * This validator currently checks the following formsts:\n   *   date, time, date-time, email, hostname, ipv4, ipv6,\n   *   uri, uri-reference, uri-template, url, uuid, color,\n   *   json-pointer, relative-json-pointer, regex\n   *\n   * Fast format regular expressions copied from AJV:\n   * https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n   *\n   * @param {JsonSchemaFormatNames} requiredFormat - format to check\n   * @return {IValidatorFn}\n   */\n  static format(requiredFormat: JsonSchemaFormatNames): IValidatorFn {\n    if (!hasValue(requiredFormat)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let isValid: boolean;\n      const currentValue: string|Date = control.value;\n      if (isString(currentValue)) {\n        const formatTest: Function|RegExp = jsonSchemaFormatTests[requiredFormat];\n        if (typeof formatTest === 'object') {\n          isValid = (<RegExp>formatTest).test(<string>currentValue);\n        } else if (typeof formatTest === 'function') {\n          isValid = (<Function>formatTest)(<string>currentValue);\n        } else {\n          console.error(`format validator error: \"${requiredFormat}\" is not a recognized format.`);\n          isValid = true;\n        }\n      } else {\n        // Allow JavaScript Date objects\n        isValid = ['date', 'time', 'date-time'].includes(requiredFormat) &&\n          Object.prototype.toString.call(currentValue) === '[object Date]';\n      }\n      return xor(isValid, invert) ?\n        null : { 'format': { requiredFormat, currentValue } };\n    };\n  }\n\n  /**\n   * 'minimum' validator\n   *\n   * Requires a control's numeric value to be greater than or equal to\n   * a minimum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a minimum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} minimum - minimum allowed value\n   * @return {IValidatorFn}\n   */\n  static minimum(minimumValue: number): IValidatorFn {\n    if (!hasValue(minimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || currentValue >= minimumValue;\n      return xor(isValid, invert) ?\n        null : { 'minimum': { minimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMinimum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} exclusiveMinimumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static exclusiveMinimum(exclusiveMinimumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMinimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMinimumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMinimum': { exclusiveMinimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'maximum' validator\n   *\n   * Requires a control's numeric value to be less than or equal to\n   * a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} maximumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static maximum(maximumValue: number): IValidatorFn {\n    if (!hasValue(maximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue <= maximumValue;\n      return xor(isValid, invert) ?\n        null : { 'maximum': { maximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMaximum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} exclusiveMaximumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static exclusiveMaximum(exclusiveMaximumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMaximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMaximumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMaximum': { exclusiveMaximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'multipleOf' validator\n   *\n   * Requires a control to have a numeric value that is a multiple\n   * of a specified number.\n   *\n   * @param {number} multipleOfValue - number value must be a multiple of\n   * @return {IValidatorFn}\n   */\n  static multipleOf(multipleOfValue: number): IValidatorFn {\n    if (!hasValue(multipleOfValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = isNumber(currentValue) &&\n        currentValue % multipleOfValue === 0;\n      return xor(isValid, invert) ?\n        null : { 'multipleOf': { multipleOfValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minProperties' validator\n   *\n   * Requires a form group to have a minimum number of properties (i.e. have\n   * values entered in a minimum number of controls within the group).\n   *\n   * @param {number} minimumProperties - minimum number of properties allowed\n   * @return {IValidatorFn}\n   */\n  static minProperties(minimumProperties: number): IValidatorFn {\n    if (!hasValue(minimumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties >= minimumProperties;\n      return xor(isValid, invert) ?\n        null : { 'minProperties': { minimumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'maxProperties' validator\n   *\n   * Requires a form group to have a maximum number of properties (i.e. have\n   * values entered in a maximum number of controls within the group).\n   *\n   * Note: Has no effect if the form group does not contain more than the\n   * maximum number of controls.\n   *\n   * @param {number} maximumProperties - maximum number of properties allowed\n   * @return {IValidatorFn}\n   */\n  static maxProperties(maximumProperties: number): IValidatorFn {\n    if (!hasValue(maximumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties <= maximumProperties;\n      return xor(isValid, invert) ?\n        null : { 'maxProperties': { maximumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'dependencies' validator\n   *\n   * Requires the controls in a form group to meet additional validation\n   * criteria, depending on the values of other controls in the group.\n   *\n   * Examples:\n   * https://spacetelescope.github.io/understanding-json-schema/reference/object.html#dependencies\n   *\n   * @param {any} dependencies - required dependencies\n   * @return {IValidatorFn}\n   */\n  static dependencies(dependencies: any): IValidatorFn {\n    if (getType(dependencies) !== 'object' || isEmpty(dependencies)) {\n      return JsonValidators.nullValidator;\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const allErrors = _mergeObjects(\n        forEachCopy(dependencies, (value, requiringField) => {\n          if (!hasValue(control.value[requiringField])) { return null; }\n          let requiringFieldErrors: ValidationErrors = { };\n          let requiredFields: string[];\n          let properties: ValidationErrors = { };\n          if (getType(dependencies[requiringField]) === 'array') {\n            requiredFields = dependencies[requiringField];\n          } else if (getType(dependencies[requiringField]) === 'object') {\n            requiredFields = dependencies[requiringField]['required'] || [];\n            properties = dependencies[requiringField]['properties'] || { };\n          }\n\n          // Validate property dependencies\n          for (const requiredField of requiredFields) {\n            if (xor(!hasValue(control.value[requiredField]), invert)) {\n              requiringFieldErrors[requiredField] = { 'required': true };\n            }\n          }\n\n          // Validate schema dependencies\n          requiringFieldErrors = _mergeObjects(requiringFieldErrors,\n            forEachCopy(properties, (requirements, requiredField) => {\n              const requiredFieldErrors = _mergeObjects(\n                forEachCopy(requirements, (requirement, parameter) => {\n                  let validator: IValidatorFn = null;\n                  if (requirement === 'maximum' || requirement === 'minimum') {\n                    const exclusive = !!requirements['exclusiveM' + requirement.slice(1)];\n                    validator = JsonValidators[requirement](parameter, exclusive);\n                  } else if (typeof JsonValidators[requirement] === 'function') {\n                    validator = JsonValidators[requirement](parameter);\n                  }\n                  return !isDefined(validator) ?\n                    null : validator(control.value[requiredField]);\n                })\n              );\n              return isEmpty(requiredFieldErrors) ?\n                null : { [requiredField]: requiredFieldErrors };\n            })\n          );\n          return isEmpty(requiringFieldErrors) ?\n            null : { [requiringField]: requiringFieldErrors };\n        })\n      );\n      return isEmpty(allErrors) ? null : allErrors;\n    };\n  }\n\n  /**\n   * 'minItems' validator\n   *\n   * Requires a form array to have a minimum number of values.\n   *\n   * @param {number} minimumItems - minimum number of items allowed\n   * @return {IValidatorFn}\n   */\n  static minItems(minimumItems: number): IValidatorFn {\n    if (!hasValue(minimumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems >= minimumItems;\n      return xor(isValid, invert) ?\n        null : { 'minItems': { minimumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'maxItems' validator\n   *\n   * Requires a form array to have a maximum number of values.\n   *\n   * @param {number} maximumItems - maximum number of items allowed\n   * @return {IValidatorFn}\n   */\n  static maxItems(maximumItems: number): IValidatorFn {\n    if (!hasValue(maximumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems <= maximumItems;\n      return xor(isValid, invert) ?\n        null : { 'maxItems': { maximumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'uniqueItems' validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param {boolean = true} unique? - true to validate, false to disable\n   * @return {IValidatorFn}\n   */\n  static uniqueItems(unique = true): IValidatorFn {\n    if (!unique) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const sorted: any[] = control.value.slice().sort();\n      const duplicateItems = [];\n      for (let i = 1; i < sorted.length; i++) {\n        if (sorted[i - 1] === sorted[i] && duplicateItems.includes(sorted[i])) {\n          duplicateItems.push(sorted[i]);\n        }\n      }\n      const isValid = !duplicateItems.length;\n      return xor(isValid, invert) ?\n        null : { 'uniqueItems': { duplicateItems } };\n    };\n  }\n\n  /**\n   * 'contains' validator\n   *\n   * TODO: Complete this validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param {boolean = true} unique? - true to validate, false to disable\n   * @return {IValidatorFn}\n   */\n  static contains(requiredItem = true): IValidatorFn {\n    if (!requiredItem) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value) || !isArray(control.value)) { return null; }\n      const currentItems = control.value;\n      // const isValid = currentItems.some(item =>\n      //\n      // );\n      const isValid = true;\n      return xor(isValid, invert) ?\n        null : { 'contains': { requiredItem, currentItems } };\n    };\n  }\n\n  /**\n   * No-op validator. Included for backward compatibility.\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null {\n    return null;\n  }\n\n  /**\n   * Validator transformation functions:\n   * composeAnyOf, composeOneOf, composeAllOf, composeNot,\n   * compose, composeAsync\n   *\n   * TODO: Add composeAnyOfAsync, composeOneOfAsync,\n   *           composeAllOfAsync, composeNotAsync\n   */\n\n  /**\n   * 'composeAnyOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid if any one or more of the submitted validators are\n   * valid. If every validator is invalid, it returns combined errors from\n   * all validators.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeAnyOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators, invert).filter(isDefined);\n      const isValid = validators.length > arrayOfErrors.length;\n      return xor(isValid, invert) ?\n        null : _mergeObjects(...arrayOfErrors, { 'anyOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeOneOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if exactly one of the submitted validators\n   * is valid. Otherwise returns combined information from all validators,\n   * both valid and invalid.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeOneOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators);\n      const validControls =\n        validators.length - arrayOfErrors.filter(isDefined).length;\n      const isValid = validControls === 1;\n      if (xor(isValid, invert)) { return null; }\n      const arrayOfValids =\n        _executeValidators(control, presentValidators, invert);\n      return _mergeObjects(...arrayOfErrors, ...arrayOfValids, { 'oneOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeAllOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if all the submitted validators are individually\n   * valid. Otherwise it returns combined errors from all invalid validators.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeAllOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const combinedErrors = _mergeErrors(\n        _executeValidators(control, presentValidators, invert)\n      );\n      const isValid = combinedErrors === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(combinedErrors, { 'allOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeNot' validator inversion function\n   *\n   * Accepts a single validator function and inverts its result.\n   * Returns valid if the submitted validator is invalid, and\n   * returns invalid if the submitted validator is valid.\n   * (Note: this function can itself be inverted\n   *   - e.g. composeNot(composeNot(validator)) -\n   *   but this can be confusing and is therefore not recommended.)\n   *\n   * @param {IValidatorFn[]} validators - validator(s) to invert\n   * @return {IValidatorFn} - new validator function that returns opposite result\n   */\n  static composeNot(validator: IValidatorFn): IValidatorFn {\n    if (!validator) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const error = validator(control, !invert);\n      const isValid = error === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(error, { 'not': !invert });\n    };\n  }\n\n  /**\n   * 'compose' validator combination function\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static compose(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null =>\n      _mergeErrors(_executeValidators(control, presentValidators, invert));\n  }\n\n  /**\n   * 'composeAsync' async validator combination function\n   *\n   * @param {AsyncIValidatorFn[]} async validators - array of async validators\n   * @return {AsyncIValidatorFn} - single combined async validator function\n   */\n  static composeAsync(validators: AsyncIValidatorFn[]): AsyncIValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl) => {\n      const observables =\n        _executeAsyncValidators(control, presentValidators).map(toObservable);\n      return map.call(forkJoin(observables), _mergeErrors);\n    };\n  }\n\n  // Additional angular validators (not used by Angualr JSON Schema Form)\n  // From https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   */\n  static min(min: number): ValidatorFn {\n    if (!hasValue(min)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(min)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return isNaN(value) || value >= min ? null : { 'min': { min, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   */\n  static max(max: number): ValidatorFn {\n    if (!hasValue(max)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(max)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return isNaN(value) || value <= max ? null : { 'max': { max, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    return control.value === true ? null : { 'required': true };\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    const EMAIL_REGEXP =\n      // tslint:disable-next-line max-line-length\n      /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n    return EMAIL_REGEXP.test(control.value) ? null : { 'email': true };\n  }\n}\n",
    "import {\n  AbstractControl, FormArray, FormControl, FormGroup, ValidatorFn\n} from '@angular/forms';\n\nimport * as _ from 'lodash';\n\nimport {\n  hasValue, inArray, isArray, isEmpty, isDate, isObject, isDefined, isPrimitive,\n  toJavaScriptType, toSchemaType, SchemaPrimitiveType\n} from './validator.functions';\nimport { forEach, hasOwn } from './utility.functions';\nimport { Pointer, JsonPointer } from './jsonpointer.functions';\nimport { JsonValidators } from './json.validators';\nimport {\n  combineAllOf, getControlValidators, getSubSchema, removeRecursiveReferences\n} from './json-schema.functions';\n\n/**\n * FormGroup function library:\n *\n * buildFormGroupTemplate:  Builds a FormGroupTemplate from schema\n *\n * buildFormGroup:          Builds an Angular FormGroup from a FormGroupTemplate\n *\n * mergeValues:\n *\n * setRequiredFields:\n *\n * formatFormData:\n *\n * getControl:\n *\n * ---- TODO: ----\n * TODO: add buildFormGroupTemplateFromLayout function\n * buildFormGroupTemplateFromLayout: Builds a FormGroupTemplate from a form layout\n */\n\n/**\n * 'buildFormGroupTemplate' function\n *\n * Builds a template for an Angular FormGroup from a JSON Schema.\n *\n * TODO: add support for pattern properties\n * https://spacetelescope.github.io/understanding-json-schema/reference/object.html\n *\n * @param  {any} jsf -\n * @param  {any = null} nodeValue -\n * @param  {boolean = true} mapArrays -\n * @param  {string = ''} schemaPointer -\n * @param  {string = ''} dataPointer -\n * @param  {any = ''} templatePointer -\n * @return {any} -\n */\nexport function buildFormGroupTemplate(\n  jsf: any, nodeValue: any = null, setValues = true,\n  schemaPointer = '', dataPointer = '', templatePointer = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer);\n  if (setValues) {\n    if (!isDefined(nodeValue) && (\n      jsf.formOptions.setSchemaDefaults === true ||\n      (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n    )) {\n      nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');\n    }\n  } else {\n    nodeValue = null;\n  }\n  // TODO: If nodeValue still not set, check layout for default value\n  const schemaType: string | string[] = JsonPointer.get(schema, '/type');\n  const controlType =\n    (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) &&\n      schemaType === 'object' ? 'FormGroup' :\n    (hasOwn(schema, 'items') || hasOwn(schema, 'additionalItems')) &&\n      schemaType === 'array' ? 'FormArray' :\n    !schemaType && hasOwn(schema, '$ref') ? '$ref' : 'FormControl';\n  const shortDataPointer =\n    removeRecursiveReferences(dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap);\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map());\n  }\n  const nodeOptions = jsf.dataMap.get(shortDataPointer);\n  if (!nodeOptions.has('schemaType')) {\n    nodeOptions.set('schemaPointer', schemaPointer);\n    nodeOptions.set('schemaType', schema.type);\n    if (schema.format) {\n      nodeOptions.set('schemaFormat', schema.format);\n      if (!schema.type) { nodeOptions.set('schemaType', 'string'); }\n    }\n    if (controlType) {\n      nodeOptions.set('templatePointer', templatePointer);\n      nodeOptions.set('templateType', controlType);\n    }\n  }\n  let controls: any;\n  const validators = getControlValidators(schema);\n  switch (controlType) {\n\n    case 'FormGroup':\n      controls = {};\n      if (hasOwn(schema, 'ui:order') || hasOwn(schema, 'properties')) {\n        const propertyKeys = schema['ui:order'] || Object.keys(schema.properties);\n        if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n          const unnamedKeys = Object.keys(schema.properties)\n            .filter(key => !propertyKeys.includes(key));\n          for (let i = propertyKeys.length - 1; i >= 0; i--) {\n            if (propertyKeys[i] === '*') {\n              propertyKeys.splice(i, 1, ...unnamedKeys);\n            }\n          }\n        }\n        propertyKeys\n          .filter(key => hasOwn(schema.properties, key) ||\n            hasOwn(schema, 'additionalProperties')\n          )\n          .forEach(key => controls[key] = buildFormGroupTemplate(\n            jsf, JsonPointer.get(nodeValue, [<string>key]), setValues,\n            schemaPointer + (hasOwn(schema.properties, key) ?\n              '/properties/' + key : '/additionalProperties'\n            ),\n            dataPointer + '/' + key,\n            templatePointer + '/controls/' + key\n          ));\n        jsf.formOptions.fieldsRequired = setRequiredFields(schema, controls);\n      }\n      return { controlType, controls, validators };\n\n    case 'FormArray':\n      controls = [];\n      const minItems =\n        Math.max(schema.minItems || 0, nodeOptions.get('minItems') || 0);\n      const maxItems =\n        Math.min(schema.maxItems || 1000, nodeOptions.get('maxItems') || 1000);\n      let additionalItemsPointer: string = null;\n      if (isArray(schema.items)) { // 'items' is an array = tuple items\n        const tupleItems = nodeOptions.get('tupleItems') ||\n          (isArray(schema.items) ? Math.min(schema.items.length, maxItems) : 0);\n        for (let i = 0; i < tupleItems; i++) {\n          if (i < minItems) {\n            controls.push(buildFormGroupTemplate(\n              jsf, isArray(nodeValue) ? nodeValue[i] : nodeValue, setValues,\n              schemaPointer + '/items/' + i,\n              dataPointer + '/' + i,\n              templatePointer + '/controls/' + i\n            ));\n          } else {\n            const schemaRefPointer = removeRecursiveReferences(\n              schemaPointer + '/items/' + i, jsf.schemaRecursiveRefMap\n            );\n            const itemRefPointer = removeRecursiveReferences(\n              shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n            );\n            const itemRecursive = itemRefPointer !== shortDataPointer + '/' + i;\n            if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n              jsf.templateRefLibrary[itemRefPointer] = null;\n              jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n                jsf, null, setValues,\n                schemaRefPointer,\n                itemRefPointer,\n                templatePointer + '/controls/' + i\n              );\n            }\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaPointer + '/items/' + i,\n                  dataPointer + '/' + i,\n                  templatePointer + '/controls/' + i\n                ) :\n              itemRecursive ?\n                null : _.cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            );\n          }\n        }\n\n        // If 'additionalItems' is an object = additional list items (after tuple items)\n        if (schema.items.length < maxItems && isObject(schema.additionalItems)) {\n          additionalItemsPointer = schemaPointer + '/additionalItems';\n        }\n\n      // If 'items' is an object = list items only (no tuple items)\n      } else {\n        additionalItemsPointer = schemaPointer + '/items';\n      }\n\n      if (additionalItemsPointer) {\n        const schemaRefPointer = removeRecursiveReferences(\n          additionalItemsPointer, jsf.schemaRecursiveRefMap\n        );\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        const itemRecursive = itemRefPointer !== shortDataPointer + '/-';\n        if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n          jsf.templateRefLibrary[itemRefPointer] = null;\n          jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n            jsf, null, setValues,\n            schemaRefPointer,\n            itemRefPointer,\n            templatePointer + '/controls/-'\n          );\n        }\n        // const itemOptions = jsf.dataMap.get(itemRefPointer) || new Map();\n        const itemOptions = nodeOptions;\n        if (!itemRecursive || hasOwn(validators, 'required')) {\n          const arrayLength = Math.min(Math.max(\n            itemRecursive ? 0 :\n              (itemOptions.get('tupleItems') + itemOptions.get('listItems')) || 0,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), maxItems);\n          for (let i = controls.length; i < arrayLength; i++) {\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaRefPointer,\n                  dataPointer + '/-',\n                  templatePointer + '/controls/-'\n                ) :\n                itemRecursive ?\n                  null : _.cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            );\n          }\n        }\n      }\n      return { controlType, controls, validators };\n\n    case '$ref':\n      const schemaRef = JsonPointer.compile(schema.$ref);\n      const dataRef = JsonPointer.toDataPointer(schemaRef, schema);\n      const refPointer = removeRecursiveReferences(\n        dataRef, jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      if (refPointer && !hasOwn(jsf.templateRefLibrary, refPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.templateRefLibrary[refPointer] = null;\n        const newTemplate = buildFormGroupTemplate(jsf, setValues, setValues, schemaRef);\n        if (newTemplate) {\n          jsf.templateRefLibrary[refPointer] = newTemplate;\n        } else {\n          delete jsf.templateRefLibrary[refPointer];\n        }\n      }\n      return null;\n\n    case 'FormControl':\n      const value = {\n        value: setValues && isPrimitive(nodeValue) ? nodeValue : null,\n        disabled: nodeOptions.get('disabled') || false\n      };\n      return { controlType, value, validators };\n\n    default:\n      return null;\n  }\n}\n\n/**\n * 'buildFormGroup' function\n *\n * @param {any} template -\n * @return {AbstractControl}\n*/\nexport function buildFormGroup(template: any): AbstractControl {\n  const validatorFns: ValidatorFn[] = [];\n  let validatorFn: ValidatorFn = null;\n  if (hasOwn(template, 'validators')) {\n    forEach(template.validators, (parameters, validator) => {\n      if (typeof JsonValidators[validator] === 'function') {\n        validatorFns.push(JsonValidators[validator].apply(null, parameters));\n      }\n    });\n    if (validatorFns.length &&\n      inArray(template.controlType, ['FormGroup', 'FormArray'])\n    ) {\n      validatorFn = validatorFns.length > 1 ?\n        JsonValidators.compose(validatorFns) : validatorFns[0];\n    }\n  }\n  if (hasOwn(template, 'controlType')) {\n    switch (template.controlType) {\n      case 'FormGroup':\n        const groupControls: { [key: string]: AbstractControl } = {};\n        forEach(template.controls, (controls, key) => {\n          const newControl: AbstractControl = buildFormGroup(controls);\n          if (newControl) { groupControls[key] = newControl; }\n        });\n        return new FormGroup(groupControls, validatorFn);\n      case 'FormArray':\n        return new FormArray(_.filter(_.map(template.controls,\n          controls => buildFormGroup(controls)\n        )), validatorFn);\n      case 'FormControl':\n        return new FormControl(template.value, validatorFns);\n    }\n  }\n  return null;\n}\n\n/**\n * 'mergeValues' function\n *\n * @param  {any[]} ...valuesToMerge - Multiple values to merge\n * @return {any} - Merged values\n */\nexport function mergeValues(...valuesToMerge) {\n  let mergedValues: any = null;\n  for (const currentValue of valuesToMerge) {\n    if (!isEmpty(currentValue)) {\n      if (typeof currentValue === 'object' &&\n        (isEmpty(mergedValues) || typeof mergedValues !== 'object')\n      ) {\n        if (isArray(currentValue)) {\n          mergedValues = [ ...currentValue ];\n        } else if (isObject(currentValue)) {\n          mergedValues = { ...currentValue };\n        }\n      } else if (typeof currentValue !== 'object') {\n        mergedValues = currentValue;\n      } else if (isObject(mergedValues) && isObject(currentValue)) {\n        Object.assign(mergedValues, currentValue);\n      } else if (isObject(mergedValues) && isArray(currentValue)) {\n        const newValues = [];\n        for (const value of currentValue) {\n          newValues.push(mergeValues(mergedValues, value));\n        }\n        mergedValues = newValues;\n      } else if (isArray(mergedValues) && isObject(currentValue)) {\n        const newValues = [];\n        for (const value of mergedValues) {\n          newValues.push(mergeValues(value, currentValue));\n        }\n        mergedValues = newValues;\n      } else if (isArray(mergedValues) && isArray(currentValue)) {\n        const newValues = [];\n        for (let i = 0; i < Math.max(mergedValues.length, currentValue.length); i++) {\n          if (i < mergedValues.length && i < currentValue.length) {\n            newValues.push(mergeValues(mergedValues[i], currentValue[i]));\n          } else if (i < mergedValues.length) {\n            newValues.push(mergedValues[i]);\n          } else if (i < currentValue.length) {\n            newValues.push(currentValue[i]);\n          }\n        }\n        mergedValues = newValues;\n      }\n    }\n  }\n  return mergedValues;\n}\n\n/**\n * 'setRequiredFields' function\n *\n * @param {schema} schema - JSON Schema\n * @param {object} formControlTemplate - Form Control Template object\n * @return {boolean} - true if any fields have been set to required, false if not\n */\nexport function setRequiredFields(schema: any, formControlTemplate: any): boolean {\n  let fieldsRequired = false;\n  if (hasOwn(schema, 'required') && !isEmpty(schema.required)) {\n    fieldsRequired = true;\n    let requiredArray = isArray(schema.required) ? schema.required : [schema.required];\n    requiredArray = forEach(requiredArray,\n      key => JsonPointer.set(formControlTemplate, '/' + key + '/validators/required', [])\n    );\n  }\n  return fieldsRequired;\n\n  // TODO: Add support for patternProperties\n  // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#pattern-properties\n}\n\n/**\n * 'formatFormData' function\n *\n * @param {any} formData - Angular FormGroup data object\n * @param {Map<string, any>} dataMap -\n * @param {Map<string, string>} recursiveRefMap -\n * @param {Map<string, number>} arrayMap -\n * @param {boolean = false} fixErrors - if TRUE, tries to fix data\n * @return {any} - formatted data object\n */\nexport function formatFormData(\n  formData: any, dataMap: Map<string, any>,\n  recursiveRefMap: Map<string, string>, arrayMap: Map<string, number>,\n  returnEmptyFields = false, fixErrors = false\n): any {\n  if (formData === null || typeof formData !== 'object') { return formData; }\n  const formattedData = isArray(formData) ? [] : {};\n  JsonPointer.forEachDeep(formData, (value, dataPointer) => {\n\n    // If returnEmptyFields === true,\n    // add empty arrays and objects to all allowed keys\n    if (returnEmptyFields && isArray(value)) {\n      JsonPointer.set(formattedData, dataPointer, []);\n    } else if (returnEmptyFields && isObject(value) && !isDate(value)) {\n      JsonPointer.set(formattedData, dataPointer, {});\n    } else {\n      const genericPointer =\n        JsonPointer.has(dataMap, [dataPointer, 'schemaType']) ? dataPointer :\n          removeRecursiveReferences(dataPointer, recursiveRefMap, arrayMap);\n      if (JsonPointer.has(dataMap, [genericPointer, 'schemaType'])) {\n        const schemaType: SchemaPrimitiveType | SchemaPrimitiveType[] =\n          dataMap.get(genericPointer).get('schemaType');\n        if (schemaType === 'null') {\n          JsonPointer.set(formattedData, dataPointer, null);\n        } else if ((hasValue(value) || returnEmptyFields) &&\n          inArray(schemaType, ['string', 'integer', 'number', 'boolean'])\n        ) {\n          const newValue = (fixErrors || (value === null && returnEmptyFields)) ?\n            toSchemaType(value, schemaType) : toJavaScriptType(value, schemaType);\n          if (isDefined(newValue) || returnEmptyFields) {\n            JsonPointer.set(formattedData, dataPointer, newValue);\n          }\n\n        // If returnEmptyFields === false,\n        // only add empty arrays and objects to required keys\n        } else if (schemaType === 'object' && !returnEmptyFields) {\n          (dataMap.get(genericPointer).get('required') || []).forEach(key => {\n            const keySchemaType =\n              dataMap.get(`${genericPointer}/${key}`).get('schemaType');\n            if (keySchemaType === 'array') {\n              JsonPointer.set(formattedData, `${dataPointer}/${key}`, []);\n            } else if (keySchemaType === 'object') {\n              JsonPointer.set(formattedData, `${dataPointer}/${key}`, {});\n            }\n          });\n        }\n\n        // Finish incomplete 'date-time' entries\n        if (dataMap.get(genericPointer).get('schemaFormat') === 'date-time') {\n          // \"2000-03-14T01:59:26.535\" -> \"2000-03-14T01:59:26.535Z\" (add \"Z\")\n          if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}Z`);\n          // \"2000-03-14T01:59\" -> \"2000-03-14T01:59:00Z\" (add \":00Z\")\n          } else if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00Z`);\n          // \"2000-03-14\" -> \"2000-03-14T00:00:00Z\" (add \"T00:00:00Z\")\n          } else if (fixErrors && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00:00:00Z`);\n          }\n        }\n      } else if (typeof value !== 'object' || isDate(value) ||\n        (value === null && returnEmptyFields)\n      ) {\n        console.error('formatFormData error: ' +\n          `Schema type not found for form value at ${genericPointer}`);\n        console.error('dataMap', dataMap);\n        console.error('recursiveRefMap', recursiveRefMap);\n        console.error('genericPointer', genericPointer);\n      }\n    }\n  });\n  return formattedData;\n}\n\n/**\n * 'getControl' function\n *\n * Uses a JSON Pointer for a data object to retrieve a control from\n * an Angular formGroup or formGroup template. (Note: though a formGroup\n * template is much simpler, its basic structure is idential to a formGroup).\n *\n * If the optional third parameter 'returnGroup' is set to TRUE, the group\n * containing the control is returned, rather than the control itself.\n *\n * @param {FormGroup} formGroup - Angular FormGroup to get value from\n * @param {Pointer} dataPointer - JSON Pointer (string or array)\n * @param {boolean = false} returnGroup - If true, return group containing control\n * @return {group} - Located value (or null, if no control found)\n */\nexport function getControl(\n  formGroup: any, dataPointer: Pointer, returnGroup = false\n): any {\n  if (!isObject(formGroup) || !JsonPointer.isJsonPointer(dataPointer)) {\n    if (!JsonPointer.isJsonPointer(dataPointer)) {\n      // If dataPointer input is not a valid JSON pointer, check to\n      // see if it is instead a valid object path, using dot notaion\n      if (typeof dataPointer === 'string') {\n        const formControl = formGroup.get(dataPointer);\n        if (formControl) { return formControl; }\n      }\n      console.error(`getControl error: Invalid JSON Pointer: ${dataPointer}`);\n    }\n    if (!isObject(formGroup)) {\n      console.error(`getControl error: Invalid formGroup: ${formGroup}`);\n    }\n    return null;\n  }\n  let dataPointerArray = JsonPointer.parse(dataPointer);\n  if (returnGroup) { dataPointerArray = dataPointerArray.slice(0, -1); }\n\n  // If formGroup input is a real formGroup (not a formGroup template)\n  // try using formGroup.get() to return the control\n  if (typeof formGroup.get === 'function' &&\n    dataPointerArray.every(key => key.indexOf('.') === -1)\n  ) {\n    const formControl = formGroup.get(dataPointerArray.join('.'));\n    if (formControl) { return formControl; }\n  }\n\n  // If formGroup input is a formGroup template,\n  // or formGroup.get() failed to return the control,\n  // search the formGroup object for dataPointer's control\n  let subGroup = formGroup;\n  for (const key of dataPointerArray) {\n    if (hasOwn(subGroup, 'controls')) { subGroup = subGroup.controls; }\n    if (isArray(subGroup) && (key === '-')) {\n      subGroup = subGroup[subGroup.length - 1];\n    } else if (hasOwn(subGroup, key)) {\n      subGroup = subGroup[key];\n    } else {\n      console.error(`getControl error: Unable to find \"${key}\" item in FormGroup.`);\n      console.error(dataPointer);\n      console.error(formGroup);\n      return;\n    }\n  }\n  return subGroup;\n}\n",
    "import { BehaviorSubject } from 'rxjs-compat/BehaviorSubject';\n\nimport * as _ from 'lodash';\n\nimport { TitleMapItem } from '../json-schema-form.service';\nimport {\n  inArray, isArray, isEmpty, isNumber, isObject, isDefined, isString\n} from './validator.functions';\nimport { copy, fixTitle, forEach, hasOwn } from './utility.functions';\nimport { Pointer, JsonPointer } from './jsonpointer.functions';\nimport {\n  getFromSchema, getInputType, getSubSchema, checkInlineType, isInputRequired,\n  removeRecursiveReferences, updateInputOptions\n} from './json-schema.functions';\nimport { buildFormGroupTemplate, getControl } from './form-group.functions';\n\n/**\n * Layout function library:\n *\n * buildLayout:            Builds a complete layout from an input layout and schema\n *\n * buildLayoutFromSchema:  Builds a complete layout entirely from an input schema\n *\n * mapLayout:\n *\n * getLayoutNode:\n *\n * buildTitleMap:\n */\n\n/**\n * 'buildLayout' function\n *\n * @param  { any } jsf\n * @param  { any } widgetLibrary\n * @return { any[] }\n */\nexport function buildLayout(jsf, widgetLibrary) {\n  let hasSubmitButton = !JsonPointer.get(jsf, '/formOptions/addSubmit');\n  const formLayout = mapLayout(jsf.layout, (layoutItem, index, layoutPointer) => {\n    const currentIndex = index;\n    const newNode: any = {\n      _id: _.uniqueId(),\n      options: {},\n    };\n    if (isObject(layoutItem)) {\n      Object.assign(newNode, layoutItem);\n      Object.keys(newNode)\n        .filter(option => !inArray(option, [\n          '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n          'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n        ]))\n        .forEach(option => {\n          newNode.options[option] = newNode[option];\n          delete newNode[option];\n        });\n      if (!hasOwn(newNode, 'type') && isString(newNode.widget)) {\n        newNode.type = newNode.widget;\n        delete newNode.widget;\n      }\n      if (!hasOwn(newNode.options, 'title')) {\n        if (hasOwn(newNode.options, 'legend')) {\n          newNode.options.title = newNode.options.legend;\n          delete newNode.options.legend;\n        }\n      }\n      if (!hasOwn(newNode.options, 'validationMessages')) {\n        if (hasOwn(newNode.options, 'errorMessages')) {\n          newNode.options.validationMessages = newNode.options.errorMessages;\n          delete newNode.options.errorMessages;\n\n        // Convert Angular Schema Form (AngularJS) 'validationMessage' to\n        // Angular JSON Schema Form 'validationMessages'\n        // TV4 codes from https://github.com/geraintluff/tv4/blob/master/source/api.js\n        } else if (hasOwn(newNode.options, 'validationMessage')) {\n          if (typeof newNode.options.validationMessage === 'string') {\n            newNode.options.validationMessages = newNode.options.validationMessage;\n          } else {\n            newNode.options.validationMessages = {};\n            Object.keys(newNode.options.validationMessage).forEach(key => {\n              const code = key + '';\n              const newKey =\n                code ===  '0'  ? 'type' :\n                code ===  '1'  ? 'enum' :\n                code === '100' ? 'multipleOf' :\n                code === '101' ? 'minimum' :\n                code === '102' ? 'exclusiveMinimum' :\n                code === '103' ? 'maximum' :\n                code === '104' ? 'exclusiveMaximum' :\n                code === '200' ? 'minLength' :\n                code === '201' ? 'maxLength' :\n                code === '202' ? 'pattern' :\n                code === '300' ? 'minProperties' :\n                code === '301' ? 'maxProperties' :\n                code === '302' ? 'required' :\n                code === '304' ? 'dependencies' :\n                code === '400' ? 'minItems' :\n                code === '401' ? 'maxItems' :\n                code === '402' ? 'uniqueItems' :\n                code === '500' ? 'format' : code + '';\n              newNode.options.validationMessages[newKey] = newNode.options.validationMessage[key];\n            });\n          }\n          delete newNode.options.validationMessage;\n        }\n      }\n    } else if (JsonPointer.isJsonPointer(layoutItem)) {\n      newNode.dataPointer = layoutItem;\n    } else if (isString(layoutItem)) {\n      newNode.key = layoutItem;\n    } else {\n      console.error('buildLayout error: Form layout element not recognized:');\n      console.error(layoutItem);\n      return null;\n    }\n    let nodeSchema: any = null;\n\n    // If newNode does not have a dataPointer, try to find an equivalent\n    if (!hasOwn(newNode, 'dataPointer')) {\n\n      // If newNode has a key, change it to a dataPointer\n      if (hasOwn(newNode, 'key')) {\n        newNode.dataPointer = newNode.key === '*' ? newNode.key :\n          JsonPointer.compile(JsonPointer.parseObjectPath(newNode.key), '-');\n        delete newNode.key;\n\n      // If newNode is an array, search for dataPointer in child nodes\n      } else if (hasOwn(newNode, 'type') && newNode.type.slice(-5) === 'array') {\n        const findDataPointer = (items) => {\n          if (items === null || typeof items !== 'object') { return; }\n          if (hasOwn(items, 'dataPointer')) { return items.dataPointer; }\n          if (isArray(items.items)) {\n            for (const item of items.items) {\n              if (hasOwn(item, 'dataPointer') && item.dataPointer.indexOf('/-') !== -1) {\n                return item.dataPointer;\n              }\n              if (hasOwn(item, 'items')) {\n                const searchItem = findDataPointer(item);\n                if (searchItem) { return searchItem; }\n              }\n            }\n          }\n        };\n        const childDataPointer = findDataPointer(newNode);\n        if (childDataPointer) {\n          newNode.dataPointer =\n            childDataPointer.slice(0, childDataPointer.lastIndexOf('/-'));\n        }\n      }\n    }\n\n    if (hasOwn(newNode, 'dataPointer')) {\n      if (newNode.dataPointer === '*') {\n        return buildLayoutFromSchema(jsf, widgetLibrary, jsf.formValues);\n      }\n      const nodeValue =\n        JsonPointer.get(jsf.formValues, newNode.dataPointer.replace(/\\/-/g, '/1'));\n\n      // TODO: Create function getFormValues(jsf, dataPointer, forRefLibrary)\n      // check formOptions.setSchemaDefaults and formOptions.setLayoutDefaults\n      // then set apropriate values from initialVaues, schema, or layout\n\n      newNode.dataPointer =\n        JsonPointer.toGenericPointer(newNode.dataPointer, jsf.arrayMap);\n      const LastKey = JsonPointer.toKey(newNode.dataPointer);\n      if (!newNode.name && isString(LastKey) && LastKey !== '-') {\n        newNode.name = LastKey;\n      }\n      const shortDataPointer = removeRecursiveReferences(\n        newNode.dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      const recursive = !shortDataPointer.length ||\n        shortDataPointer !== newNode.dataPointer;\n      let schemaPointer: string;\n      if (!jsf.dataMap.has(shortDataPointer)) {\n        jsf.dataMap.set(shortDataPointer, new Map());\n      }\n      const nodeDataMap = jsf.dataMap.get(shortDataPointer);\n      if (nodeDataMap.has('schemaPointer')) {\n        schemaPointer = nodeDataMap.get('schemaPointer');\n      } else {\n        schemaPointer = JsonPointer.toSchemaPointer(shortDataPointer, jsf.schema);\n        nodeDataMap.set('schemaPointer', schemaPointer);\n      }\n      nodeDataMap.set('disabled', !!newNode.options.disabled);\n      nodeSchema = JsonPointer.get(jsf.schema, schemaPointer);\n      if (nodeSchema) {\n        if (!hasOwn(newNode, 'type')) {\n          newNode.type = getInputType(nodeSchema, newNode);\n        } else if (!widgetLibrary.hasWidget(newNode.type)) {\n          const oldWidgetType = newNode.type;\n          newNode.type = getInputType(nodeSchema, newNode);\n          console.error(`error: widget type \"${oldWidgetType}\" ` +\n            `not found in library. Replacing with \"${newNode.type}\".`);\n        } else {\n          newNode.type = checkInlineType(newNode.type, nodeSchema, newNode);\n        }\n        if (nodeSchema.type === 'object' && isArray(nodeSchema.required)) {\n          nodeDataMap.set('required', nodeSchema.required);\n        }\n        newNode.dataType =\n          nodeSchema.type || (hasOwn(nodeSchema, '$ref') ? '$ref' : null);\n        updateInputOptions(newNode, nodeSchema, jsf);\n\n        // Present checkboxes as single control, rather than array\n        if (newNode.type === 'checkboxes' && hasOwn(nodeSchema, 'items')) {\n          updateInputOptions(newNode, nodeSchema.items, jsf);\n        } else if (newNode.dataType === 'array') {\n          newNode.options.maxItems = Math.min(\n            nodeSchema.maxItems || 1000, newNode.options.maxItems || 1000\n          );\n          newNode.options.minItems = Math.max(\n            nodeSchema.minItems || 0, newNode.options.minItems || 0\n          );\n          newNode.options.listItems = Math.max(\n            newNode.options.listItems || 0, isArray(nodeValue) ? nodeValue.length : 0\n          );\n          newNode.options.tupleItems =\n            isArray(nodeSchema.items) ? nodeSchema.items.length : 0;\n          if (newNode.options.maxItems < newNode.options.tupleItems) {\n            newNode.options.tupleItems = newNode.options.maxItems;\n            newNode.options.listItems = 0;\n          } else if (newNode.options.maxItems <\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.maxItems - newNode.options.tupleItems;\n          } else if (newNode.options.minItems >\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.minItems - newNode.options.tupleItems;\n          }\n          if (!nodeDataMap.has('maxItems')) {\n            nodeDataMap.set('maxItems', newNode.options.maxItems);\n            nodeDataMap.set('minItems', newNode.options.minItems);\n            nodeDataMap.set('tupleItems', newNode.options.tupleItems);\n            nodeDataMap.set('listItems', newNode.options.listItems);\n          }\n          if (!jsf.arrayMap.has(shortDataPointer)) {\n            jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);\n          }\n        }\n        if (isInputRequired(jsf.schema, schemaPointer)) {\n          newNode.options.required = true;\n          jsf.fieldsRequired = true;\n        }\n      } else {\n        // TODO: create item in FormGroup model from layout key (?)\n        updateInputOptions(newNode, {}, jsf);\n      }\n\n      if (!newNode.options.title && !/^\\d+$/.test(newNode.name)) {\n        newNode.options.title = fixTitle(newNode.name);\n      }\n\n      if (hasOwn(newNode.options, 'copyValueTo')) {\n        if (typeof newNode.options.copyValueTo === 'string') {\n          newNode.options.copyValueTo = [newNode.options.copyValueTo];\n        }\n        if (isArray(newNode.options.copyValueTo)) {\n          newNode.options.copyValueTo = newNode.options.copyValueTo.map(item =>\n            JsonPointer.compile(JsonPointer.parseObjectPath(item), '-')\n          );\n        }\n      }\n\n      newNode.widget = widgetLibrary.getWidget(newNode.type);\n      nodeDataMap.set('inputType', newNode.type);\n      nodeDataMap.set('widget', newNode.widget);\n\n      if (newNode.dataType === 'array' &&\n        (hasOwn(newNode, 'items') || hasOwn(newNode, 'additionalItems'))\n      ) {\n        const itemRefPointer = removeRecursiveReferences(\n          newNode.dataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        if (!jsf.dataMap.has(itemRefPointer)) {\n          jsf.dataMap.set(itemRefPointer, new Map());\n        }\n        jsf.dataMap.get(itemRefPointer).set('inputType', 'section');\n\n        // Fix insufficiently nested array item groups\n        if (newNode.items.length > 1) {\n          const arrayItemGroup = [];\n          const arrayItemGroupTemplate = [];\n          let newIndex = 0;\n          for (let i = newNode.items.length - 1; i >= 0; i--) {\n            const subItem = newNode.items[i];\n            if (hasOwn(subItem, 'dataPointer') &&\n              subItem.dataPointer.slice(0, itemRefPointer.length) === itemRefPointer\n            ) {\n              const arrayItem = newNode.items.splice(i, 1)[0];\n              arrayItem.dataPointer = newNode.dataPointer + '/-' +\n                arrayItem.dataPointer.slice(itemRefPointer.length);\n              arrayItemGroup.unshift(arrayItem);\n              newIndex++;\n            } else {\n              subItem.arrayItem = true;\n              // TODO: Check schema to get arrayItemType and removable\n              subItem.arrayItemType = 'list';\n              subItem.removable = newNode.options.removable !== false;\n            }\n          }\n          if (arrayItemGroup.length) {\n            newNode.items.push({\n              _id: _.uniqueId(),\n              arrayItem: true,\n              arrayItemType: newNode.options.tupleItems > newNode.items.length ?\n                'tuple' : 'list',\n              items: arrayItemGroup,\n              options: { removable: newNode.options.removable !== false, },\n              dataPointer: newNode.dataPointer + '/-',\n              type: 'section',\n              widget: widgetLibrary.getWidget('section'),\n            });\n          }\n        } else {\n          // TODO: Fix to hndle multiple items\n          newNode.items[0].arrayItem = true;\n          if (!newNode.items[0].dataPointer) {\n            newNode.items[0].dataPointer =\n              JsonPointer.toGenericPointer(itemRefPointer, jsf.arrayMap);\n          }\n          if (!JsonPointer.has(newNode, '/items/0/options/removable')) {\n            newNode.items[0].options.removable = true;\n          }\n          if (newNode.options.orderable === false) {\n            newNode.items[0].options.orderable = false;\n          }\n          newNode.items[0].arrayItemType =\n            newNode.options.tupleItems ? 'tuple' : 'list';\n        }\n\n        if (isArray(newNode.items)) {\n          const arrayListItems =\n            newNode.items.filter(item => item.type !== '$ref').length -\n              newNode.options.tupleItems;\n          if (arrayListItems > newNode.options.listItems) {\n            newNode.options.listItems = arrayListItems;\n            nodeDataMap.set('listItems', arrayListItems);\n          }\n        }\n\n        if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n          jsf.layoutRefLibrary[itemRefPointer] =\n            _.cloneDeep(newNode.items[newNode.items.length - 1]);\n          if (recursive) {\n            jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n          }\n          forEach(jsf.layoutRefLibrary[itemRefPointer], (item, key) => {\n            if (hasOwn(item, '_id')) { item._id = null; }\n            if (recursive) {\n              if (hasOwn(item, 'dataPointer')) {\n                item.dataPointer = item.dataPointer.slice(itemRefPointer.length);\n              }\n            }\n          }, 'top-down');\n        }\n\n        // Add any additional default items\n        if (!newNode.recursiveReference || newNode.options.required) {\n          const arrayLength = Math.min(Math.max(\n            newNode.options.tupleItems + newNode.options.listItems,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), newNode.options.maxItems);\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: newNode.dataPointer,\n              recursiveReference: newNode.recursiveReference,\n            }, jsf, widgetLibrary));\n          }\n        }\n\n        // If needed, add button to add items to array\n        if (newNode.options.addable !== false &&\n          newNode.options.minItems < newNode.options.maxItems &&\n          (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n        ) {\n          let buttonText = 'Add';\n          if (newNode.options.title) {\n            if (/^add\\b/i.test(newNode.options.title)) {\n              buttonText = newNode.options.title;\n            } else {\n              buttonText += ' ' + newNode.options.title;\n            }\n          } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n            if (/^add\\b/i.test(newNode.name)) {\n              buttonText += ' ' + fixTitle(newNode.name);\n            } else {\n              buttonText = fixTitle(newNode.name);\n            }\n\n          // If newNode doesn't have a title, look for title of parent array item\n          } else {\n            const parentSchema =\n              getFromSchema(jsf.schema, newNode.dataPointer, 'parentSchema');\n            if (hasOwn(parentSchema, 'title')) {\n              buttonText += ' to ' + parentSchema.title;\n            } else {\n              const pointerArray = JsonPointer.parse(newNode.dataPointer);\n              buttonText += ' to ' + fixTitle(pointerArray[pointerArray.length - 2]);\n            }\n          }\n          newNode.items.push({\n            _id: _.uniqueId(),\n            arrayItem: true,\n            arrayItemType: 'list',\n            dataPointer: newNode.dataPointer + '/-',\n            options: {\n              listItems: newNode.options.listItems,\n              maxItems: newNode.options.maxItems,\n              minItems: newNode.options.minItems,\n              removable: false,\n              title: buttonText,\n              tupleItems: newNode.options.tupleItems,\n            },\n            recursiveReference: recursive,\n            type: '$ref',\n            widget: widgetLibrary.getWidget('$ref'),\n            $ref: itemRefPointer,\n          });\n          if (isString(JsonPointer.get(newNode, '/style/add'))) {\n            newNode.items[newNode.items.length - 1].options.fieldStyle =\n              newNode.style.add;\n            delete newNode.style.add;\n            if (isEmpty(newNode.style)) { delete newNode.style; }\n          }\n        }\n      } else {\n        newNode.arrayItem = false;\n      }\n    } else if (hasOwn(newNode, 'type') || hasOwn(newNode, 'items')) {\n      const parentType: string =\n        JsonPointer.get(jsf.layout, layoutPointer, 0, -2).type;\n      if (!hasOwn(newNode, 'type')) {\n        newNode.type =\n          inArray(parentType, ['tabs', 'tabarray']) ? 'tab' : 'array';\n      }\n      newNode.arrayItem = parentType === 'array';\n      newNode.widget = widgetLibrary.getWidget(newNode.type);\n      updateInputOptions(newNode, {}, jsf);\n    }\n    if (newNode.type === 'submit') { hasSubmitButton = true; }\n    return newNode;\n  });\n  if (jsf.hasRootReference) {\n    const fullLayout = _.cloneDeep(formLayout);\n    if (fullLayout[fullLayout.length - 1].type === 'submit') { fullLayout.pop(); }\n    jsf.layoutRefLibrary[''] = {\n      _id: null,\n      dataPointer: '',\n      dataType: 'object',\n      items: fullLayout,\n      name: '',\n      options: _.cloneDeep(jsf.formOptions.defautWidgetOptions),\n      recursiveReference: true,\n      required: false,\n      type: 'section',\n      widget: widgetLibrary.getWidget('section'),\n    };\n  }\n  if (!hasSubmitButton) {\n    formLayout.push({\n      _id: _.uniqueId(),\n      options: { title: 'Submit' },\n      type: 'submit',\n      widget: widgetLibrary.getWidget('submit'),\n    });\n  }\n  return formLayout;\n}\n\n/**\n * 'buildLayoutFromSchema' function\n *\n * @param  { any } jsf -\n * @param  { any } widgetLibrary -\n * @param  { any } nodeValue -\n * @param  { string = '' } schemaPointer -\n * @param  { string = '' } dataPointer -\n * @param  { boolean = false } arrayItem -\n * @param  { string = null } arrayItemType -\n * @param  { boolean = null } removable -\n * @param  { boolean = false } forRefLibrary -\n * @param  { string = '' } dataPointerPrefix -\n * @return { any }\n */\nexport function buildLayoutFromSchema(\n  jsf, widgetLibrary, nodeValue = null, schemaPointer = '',\n  dataPointer = '', arrayItem = false, arrayItemType: string = null,\n  removable: boolean = null, forRefLibrary = false, dataPointerPrefix = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer);\n  if (!hasOwn(schema, 'type') && !hasOwn(schema, '$ref') &&\n    !hasOwn(schema, 'x-schema-form')\n  ) { return null; }\n  const newNodeType: string = getInputType(schema);\n  if (!isDefined(nodeValue) && (\n    jsf.formOptions.setSchemaDefaults === true ||\n    (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n  )) {\n    nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');\n  }\n  let newNode: any = {\n    _id: forRefLibrary ? null : _.uniqueId(),\n    arrayItem: arrayItem,\n    dataPointer: JsonPointer.toGenericPointer(dataPointer, jsf.arrayMap),\n    dataType: schema.type || (hasOwn(schema, '$ref') ? '$ref' : null),\n    options: {},\n    required: isInputRequired(jsf.schema, schemaPointer),\n    type: newNodeType,\n    widget: widgetLibrary.getWidget(newNodeType),\n  };\n  const lastDataKey = JsonPointer.toKey(newNode.dataPointer);\n  if (lastDataKey !== '-') { newNode.name = lastDataKey; }\n  if (newNode.arrayItem) {\n    newNode.arrayItemType = arrayItemType;\n    newNode.options.removable = removable !== false;\n  }\n  const shortDataPointer = removeRecursiveReferences(\n    dataPointerPrefix + dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n  );\n  const recursive = !shortDataPointer.length ||\n    shortDataPointer !== dataPointerPrefix + dataPointer;\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map());\n  }\n  const nodeDataMap = jsf.dataMap.get(shortDataPointer);\n  if (!nodeDataMap.has('inputType')) {\n    nodeDataMap.set('schemaPointer', schemaPointer);\n    nodeDataMap.set('inputType', newNode.type);\n    nodeDataMap.set('widget', newNode.widget);\n    nodeDataMap.set('disabled', !!newNode.options.disabled);\n  }\n  updateInputOptions(newNode, schema, jsf);\n  if (!newNode.options.title && newNode.name && !/^\\d+$/.test(newNode.name)) {\n    newNode.options.title = fixTitle(newNode.name);\n  }\n\n  if (newNode.dataType === 'object') {\n    if (isArray(schema.required) && !nodeDataMap.has('required')) {\n      nodeDataMap.set('required', schema.required);\n    }\n    if (isObject(schema.properties)) {\n      const newSection: any[] = [];\n      const propertyKeys = schema['ui:order'] || Object.keys(schema.properties);\n      if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n        const unnamedKeys = Object.keys(schema.properties)\n          .filter(key => !propertyKeys.includes(key));\n        for (let i = propertyKeys.length - 1; i >= 0; i--) {\n          if (propertyKeys[i] === '*') {\n            propertyKeys.splice(i, 1, ...unnamedKeys);\n          }\n        }\n      }\n      propertyKeys\n        .filter(key => hasOwn(schema.properties, key) ||\n          hasOwn(schema, 'additionalProperties')\n        )\n        .forEach(key => {\n          const keySchemaPointer = hasOwn(schema.properties, key) ?\n            '/properties/' + key : '/additionalProperties';\n          const innerItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isObject(nodeValue) ? nodeValue[key] : null,\n            schemaPointer + keySchemaPointer,\n            dataPointer + '/' + key,\n            false, null, null, forRefLibrary, dataPointerPrefix\n          );\n          if (innerItem) {\n            if (isInputRequired(schema, '/' + key)) {\n              innerItem.options.required = true;\n              jsf.fieldsRequired = true;\n            }\n            newSection.push(innerItem);\n          }\n        });\n      if (dataPointer === '' && !forRefLibrary) {\n        newNode = newSection;\n      } else {\n        newNode.items = newSection;\n      }\n    }\n    // TODO: Add patternProperties and additionalProperties inputs?\n    // ... possibly provide a way to enter both key names and values?\n    // if (isObject(schema.patternProperties)) { }\n    // if (isObject(schema.additionalProperties)) { }\n\n  } else if (newNode.dataType === 'array') {\n    newNode.items = [];\n    const templateArray: any[] = [];\n    newNode.options.maxItems = Math.min(\n      schema.maxItems || 1000, newNode.options.maxItems || 1000\n    );\n    newNode.options.minItems = Math.max(\n      schema.minItems || 0, newNode.options.minItems || 0\n    );\n    if (!newNode.options.minItems && isInputRequired(jsf.schema, schemaPointer)) {\n      newNode.options.minItems = 1;\n    }\n    if (!hasOwn(newNode.options, 'listItems')) { newNode.options.listItems = 1; }\n    newNode.options.tupleItems = isArray(schema.items) ? schema.items.length : 0;\n    if (newNode.options.maxItems <= newNode.options.tupleItems) {\n      newNode.options.tupleItems = newNode.options.maxItems;\n      newNode.options.listItems = 0;\n    } else if (newNode.options.maxItems <\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.maxItems - newNode.options.tupleItems;\n    } else if (newNode.options.minItems >\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.minItems - newNode.options.tupleItems;\n    }\n    if (!nodeDataMap.has('maxItems')) {\n      nodeDataMap.set('maxItems', newNode.options.maxItems);\n      nodeDataMap.set('minItems', newNode.options.minItems);\n      nodeDataMap.set('tupleItems', newNode.options.tupleItems);\n      nodeDataMap.set('listItems', newNode.options.listItems);\n    }\n    if (!jsf.arrayMap.has(shortDataPointer)) {\n      jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);\n    }\n    removable = newNode.options.removable !== false;\n    let additionalItemsSchemaPointer: string = null;\n\n    // If 'items' is an array = tuple items\n    if (isArray(schema.items)) {\n      newNode.items = [];\n      for (let i = 0; i < newNode.options.tupleItems; i++) {\n        let newItem: any;\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        const itemRecursive = !itemRefPointer.length ||\n          itemRefPointer !== shortDataPointer + '/' + i;\n\n        // If removable, add tuple item layout to layoutRefLibrary\n        if (removable && i >= newNode.options.minItems) {\n          if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n            // Set to null first to prevent recursive reference from causing endless loop\n            jsf.layoutRefLibrary[itemRefPointer] = null;\n            jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n              jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n              schemaPointer + '/items/' + i,\n              itemRecursive ? '' : dataPointer + '/' + i,\n              true, 'tuple', true, true, itemRecursive ? dataPointer + '/' + i : ''\n            );\n            if (itemRecursive) {\n              jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n            }\n          }\n          newItem = getLayoutNode({\n            $ref: itemRefPointer,\n            dataPointer: dataPointer + '/' + i,\n            recursiveReference: itemRecursive,\n          }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null);\n        } else {\n          newItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n            schemaPointer + '/items/' + i,\n            dataPointer + '/' + i,\n            true, 'tuple', false, forRefLibrary, dataPointerPrefix\n          );\n        }\n        if (newItem) { newNode.items.push(newItem); }\n      }\n\n      // If 'additionalItems' is an object = additional list items, after tuple items\n      if (isObject(schema.additionalItems)) {\n        additionalItemsSchemaPointer = schemaPointer + '/additionalItems';\n      }\n\n    // If 'items' is an object = list items only (no tuple items)\n    } else if (isObject(schema.items)) {\n      additionalItemsSchemaPointer = schemaPointer + '/items';\n    }\n\n    if (additionalItemsSchemaPointer) {\n      const itemRefPointer = removeRecursiveReferences(\n        shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      const itemRecursive = !itemRefPointer.length ||\n        itemRefPointer !== shortDataPointer + '/-';\n      const itemSchemaPointer = removeRecursiveReferences(\n        additionalItemsSchemaPointer, jsf.schemaRecursiveRefMap, jsf.arrayMap\n      );\n      // Add list item layout to layoutRefLibrary\n      if (itemRefPointer.length && !hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[itemRefPointer] = null;\n        jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n          jsf, widgetLibrary, null,\n          itemSchemaPointer,\n          itemRecursive ? '' : dataPointer + '/-',\n          true, 'list', removable, true, itemRecursive ? dataPointer + '/-' : ''\n        );\n        if (itemRecursive) {\n          jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n        }\n      }\n\n      // Add any additional default items\n      if (!itemRecursive || newNode.options.required) {\n        const arrayLength = Math.min(Math.max(\n          itemRecursive ? 0 :\n            newNode.options.tupleItems + newNode.options.listItems,\n          isArray(nodeValue) ? nodeValue.length : 0\n        ), newNode.options.maxItems);\n        if (newNode.items.length < arrayLength) {\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: dataPointer + '/-',\n              recursiveReference: itemRecursive,\n            }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null));\n          }\n        }\n      }\n\n      // If needed, add button to add items to array\n      if (newNode.options.addable !== false &&\n        newNode.options.minItems < newNode.options.maxItems &&\n        (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n      ) {\n        let buttonText =\n          ((jsf.layoutRefLibrary[itemRefPointer] || {}).options || {}).title;\n        const prefix = buttonText ? 'Add ' : 'Add to ';\n        if (!buttonText) {\n          buttonText = schema.title || fixTitle(JsonPointer.toKey(dataPointer));\n        }\n        if (!/^add\\b/i.test(buttonText)) { buttonText = prefix + buttonText; }\n        newNode.items.push({\n          _id: _.uniqueId(),\n          arrayItem: true,\n          arrayItemType: 'list',\n          dataPointer: newNode.dataPointer + '/-',\n          options: {\n            listItems: newNode.options.listItems,\n            maxItems: newNode.options.maxItems,\n            minItems: newNode.options.minItems,\n            removable: false,\n            title: buttonText,\n            tupleItems: newNode.options.tupleItems,\n          },\n          recursiveReference: itemRecursive,\n          type: '$ref',\n          widget: widgetLibrary.getWidget('$ref'),\n          $ref: itemRefPointer,\n        });\n      }\n    }\n\n  } else if (newNode.dataType === '$ref') {\n    const schemaRef = JsonPointer.compile(schema.$ref);\n    const dataRef = JsonPointer.toDataPointer(schemaRef, jsf.schema);\n    let buttonText = '';\n\n    // Get newNode title\n    if (newNode.options.add) {\n      buttonText = newNode.options.add;\n    } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n      buttonText =\n        (/^add\\b/i.test(newNode.name) ? '' : 'Add ') + fixTitle(newNode.name);\n\n    // If newNode doesn't have a title, look for title of parent array item\n    } else {\n      const parentSchema =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1);\n      if (hasOwn(parentSchema, 'title')) {\n        buttonText = 'Add to ' + parentSchema.title;\n      } else {\n        const pointerArray = JsonPointer.parse(newNode.dataPointer);\n        buttonText = 'Add to ' + fixTitle(pointerArray[pointerArray.length - 2]);\n      }\n    }\n    Object.assign(newNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n      $ref: dataRef,\n    });\n    Object.assign(newNode.options, {\n      removable: false,\n      title: buttonText,\n    });\n    if (isNumber(JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems)) {\n      newNode.options.maxItems =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems;\n    }\n\n    // Add layout template to layoutRefLibrary\n    if (dataRef.length) {\n      if (!hasOwn(jsf.layoutRefLibrary, dataRef)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[dataRef] = null;\n        const newLayout = buildLayoutFromSchema(\n          jsf, widgetLibrary, null, schemaRef, '',\n          newNode.arrayItem, newNode.arrayItemType, true, true, dataPointer\n        );\n        if (newLayout) {\n          newLayout.recursiveReference = true;\n          jsf.layoutRefLibrary[dataRef] = newLayout;\n        } else {\n          delete jsf.layoutRefLibrary[dataRef];\n        }\n      } else if (!jsf.layoutRefLibrary[dataRef].recursiveReference) {\n        jsf.layoutRefLibrary[dataRef].recursiveReference = true;\n      }\n    }\n  }\n  return newNode;\n}\n\n/**\n * 'mapLayout' function\n *\n * Creates a new layout by running each element in an existing layout through\n * an iteratee. Recursively maps within array elements 'items' and 'tabs'.\n * The iteratee is invoked with four arguments: (value, index, layout, path)\n *\n * The returned layout may be longer (or shorter) then the source layout.\n *\n * If an item from the source layout returns multiple items (as '*' usually will),\n * this function will keep all returned items in-line with the surrounding items.\n *\n * If an item from the source layout causes an error and returns null, it is\n * skipped without error, and the function will still return all non-null items.\n *\n * @param  { any[] } layout - the layout to map\n * @param  { (v: any, i?: number, l?: any, p?: string) => any }\n *   function - the funciton to invoke on each element\n * @param  { string|string[] = '' } layoutPointer - the layoutPointer to layout, inside rootLayout\n * @param  { any[] = layout } rootLayout - the root layout, which conatins layout\n * @return { any[] }\n */\nexport function mapLayout(layout, fn, layoutPointer = '', rootLayout = layout) {\n  let indexPad = 0;\n  let newLayout: any[] = [];\n  forEach(layout, (item, index) => {\n    const realIndex = +index + indexPad;\n    const newLayoutPointer = layoutPointer + '/' + realIndex;\n    let newNode: any = copy(item);\n    let itemsArray: any[] = [];\n    if (isObject(item)) {\n      if (hasOwn(item, 'tabs')) {\n        item.items = item.tabs;\n        delete item.tabs;\n      }\n      if (hasOwn(item, 'items')) {\n        itemsArray = isArray(item.items) ? item.items : [item.items];\n      }\n    }\n    if (itemsArray.length) {\n      newNode.items = mapLayout(itemsArray, fn, newLayoutPointer + '/items', rootLayout);\n    }\n    newNode = fn(newNode, realIndex, newLayoutPointer, rootLayout);\n    if (!isDefined(newNode)) {\n      indexPad--;\n    } else {\n      if (isArray(newNode)) { indexPad += newNode.length - 1; }\n      newLayout = newLayout.concat(newNode);\n    }\n  });\n  return newLayout;\n}\n\n/**\n * 'getLayoutNode' function\n * Copy a new layoutNode from layoutRefLibrary\n *\n * @param  { any } refNode -\n * @param  { any } layoutRefLibrary -\n * @param  { any = null } widgetLibrary -\n * @param  { any = null } nodeValue -\n * @return { any } copied layoutNode\n */\nexport function getLayoutNode(\n  refNode, jsf, widgetLibrary: any = null, nodeValue: any = null\n) {\n\n  // If recursive reference and building initial layout, return Add button\n  if (refNode.recursiveReference && widgetLibrary) {\n    const newLayoutNode = _.cloneDeep(refNode);\n    if (!newLayoutNode.options) { newLayoutNode.options = {}; }\n    Object.assign(newLayoutNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n    });\n    Object.assign(newLayoutNode.options, {\n      removable: false,\n      title: 'Add ' + newLayoutNode.$ref,\n    });\n    return newLayoutNode;\n\n  // Otherwise, return referenced layout\n} else {\n    let newLayoutNode = jsf.layoutRefLibrary[refNode.$ref];\n    // If value defined, build new node from schema (to set array lengths)\n    if (isDefined(nodeValue)) {\n      newLayoutNode = buildLayoutFromSchema(\n        jsf, widgetLibrary, nodeValue,\n        JsonPointer.toSchemaPointer(refNode.$ref, jsf.schema),\n        refNode.$ref, newLayoutNode.arrayItem,\n        newLayoutNode.arrayItemType, newLayoutNode.options.removable, false\n      );\n    } else {\n      // If value not defined, copy node from layoutRefLibrary\n      newLayoutNode = _.cloneDeep(newLayoutNode);\n      JsonPointer.forEachDeep(newLayoutNode, (subNode, pointer) => {\n\n        // Reset all _id's in newLayoutNode to unique values\n        if (hasOwn(subNode, '_id')) { subNode._id = _.uniqueId(); }\n\n        // If adding a recursive item, prefix current dataPointer\n        // to all dataPointers in new layoutNode\n        if (refNode.recursiveReference && hasOwn(subNode, 'dataPointer')) {\n          subNode.dataPointer = refNode.dataPointer + subNode.dataPointer;\n        }\n      });\n    }\n    return newLayoutNode;\n  }\n}\n\n/**\n * 'buildTitleMap' function\n *\n * @param  { any } titleMap -\n * @param  { any } enumList -\n * @param  { boolean = true } fieldRequired -\n * @param  { boolean = true } flatList -\n * @return { TitleMapItem[] }\n */\nexport function buildTitleMap(\n  titleMap, enumList, fieldRequired = true, flatList = true\n) {\n  let newTitleMap: TitleMapItem[] = [];\n  let hasEmptyValue = false;\n  if (titleMap) {\n    if (isArray(titleMap)) {\n      if (enumList) {\n        for (const i of Object.keys(titleMap)) {\n          if (isObject(titleMap[i])) { // JSON Form style\n            const value = titleMap[i].value;\n            if (enumList.includes(value)) {\n              const name = titleMap[i].name;\n              newTitleMap.push({ name, value });\n              if (value === undefined || value === null) { hasEmptyValue = true; }\n            }\n          } else if (isString(titleMap[i])) { // React Jsonschema Form style\n            if (i < enumList.length) {\n              const name = titleMap[i];\n              const value = enumList[i];\n              newTitleMap.push({ name, value });\n              if (value === undefined || value === null) { hasEmptyValue = true; }\n            }\n          }\n        }\n      } else { // If array titleMap and no enum list, just return the titleMap - Angular Schema Form style\n        newTitleMap = titleMap;\n        if (!fieldRequired) {\n          hasEmptyValue = !!newTitleMap\n            .filter(i => i.value === undefined || i.value === null)\n            .length;\n        }\n      }\n    } else if (enumList) { // Alternate JSON Form style, with enum list\n      for (const i of Object.keys(enumList)) {\n        const value = enumList[i];\n        if (hasOwn(titleMap, value)) {\n          const name = titleMap[value];\n          newTitleMap.push({ name, value });\n          if (value === undefined || value === null) { hasEmptyValue = true; }\n        }\n      }\n    } else { // Alternate JSON Form style, without enum list\n      for (const value of Object.keys(titleMap)) {\n        const name = titleMap[value];\n        newTitleMap.push({ name, value });\n        if (value === undefined || value === null) { hasEmptyValue = true; }\n      }\n    }\n  } else if (enumList) { // Build map from enum list alone\n    for (const i of Object.keys(enumList)) {\n      const name = enumList[i];\n      const value = enumList[i];\n      newTitleMap.push({ name, value});\n      if (value === undefined || value === null) { hasEmptyValue = true; }\n    }\n  } else { // If no titleMap and no enum list, return default map of boolean values\n    newTitleMap = [ { name: 'True', value: true }, { name: 'False', value: false } ];\n  }\n\n  // Does titleMap have groups?\n  if (newTitleMap.some(title => hasOwn(title, 'group'))) {\n    hasEmptyValue = false;\n\n    // If flatList = true, flatten items & update name to group: name\n    if (flatList) {\n      newTitleMap = newTitleMap.reduce((groupTitleMap, title) => {\n        if (hasOwn(title, 'group')) {\n          if (isArray(title.items)) {\n            groupTitleMap = [\n              ...groupTitleMap,\n              ...title.items.map(item =>\n                ({ ...item, ...{ name: `${title.group}: ${item.name}` } })\n              )\n            ];\n            if (title.items.some(item => item.value === undefined || item.value === null)) {\n              hasEmptyValue = true;\n            }\n          }\n          if (hasOwn(title, 'name') && hasOwn(title, 'value')) {\n            title.name = `${title.group}: ${title.name}`;\n            delete title.group;\n            groupTitleMap.push(title);\n            if (title.value === undefined || title.value === null) {\n              hasEmptyValue = true;\n            }\n          }\n        } else {\n          groupTitleMap.push(title);\n          if (title.value === undefined || title.value === null) {\n            hasEmptyValue = true;\n          }\n        }\n        return groupTitleMap;\n      }, []);\n\n    // If flatList = false, combine items from matching groups\n    } else {\n      newTitleMap = newTitleMap.reduce((groupTitleMap, title) => {\n        if (hasOwn(title, 'group')) {\n          if (title.group !== (groupTitleMap[groupTitleMap.length - 1] || {}).group) {\n            groupTitleMap.push({ group: title.group, items: title.items || [] });\n          }\n          if (hasOwn(title, 'name') && hasOwn(title, 'value')) {\n            groupTitleMap[groupTitleMap.length - 1].items\n              .push({ name: title.name, value: title.value });\n            if (title.value === undefined || title.value === null) {\n              hasEmptyValue = true;\n            }\n          }\n        } else {\n          groupTitleMap.push(title);\n          if (title.value === undefined || title.value === null) {\n            hasEmptyValue = true;\n          }\n        }\n        return groupTitleMap;\n      }, []);\n    }\n  }\n  if (!fieldRequired && !hasEmptyValue) {\n    newTitleMap.unshift({ name: '<em>None</em>', value: null });\n  }\n  return newTitleMap;\n}\n",
    "export const enValidationMessages: any = { // Default English error messages\n  required: 'This field is required.',\n  minLength: 'Must be {{minimumLength}} characters or longer (current length: {{currentLength}})',\n  maxLength: 'Must be {{maximumLength}} characters or shorter (current length: {{currentLength}})',\n  pattern: 'Must match pattern: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Must be a date, like \"2000-12-31\"';\n      case 'time':\n        return 'Must be a time, like \"16:20\" or \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Must be a date-time, like \"2000-03-14T01:59\" or \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Must be an email address, like \"name@example.com\"';\n      case 'hostname':\n        return 'Must be a hostname, like \"example.com\"';\n      case 'ipv4':\n        return 'Must be an IPv4 address, like \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Must be an IPv6 address, like \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Must be a url, like \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Must be a uuid, like \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Must be a color, like \"#FFFFFF\" or \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Must be a JSON Pointer, like \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Must be a relative JSON Pointer, like \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Must be a regular expression, like \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Must be a correctly formatted ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Must be {{minimumValue}} or more',\n  exclusiveMinimum: 'Must be more than {{exclusiveMinimumValue}}',\n  maximum: 'Must be {{maximumValue}} or less',\n  exclusiveMaximum: 'Must be less than {{exclusiveMaximumValue}}',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Must have ${decimals} or fewer decimal places.`;\n    } else {\n      return `Must be a multiple of ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Must have {{minimumProperties}} or more items (current items: {{currentProperties}})',\n  maxProperties: 'Must have {{maximumProperties}} or fewer items (current items: {{currentProperties}})',\n  minItems: 'Must have {{minimumItems}} or more items (current items: {{currentItems}})',\n  maxItems: 'Must have {{maximumItems}} or fewer items (current items: {{currentItems}})',\n  uniqueItems: 'All items must be unique',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n",
    "export const frValidationMessages: any = { // French error messages\n  required: 'Est obligatoire.',\n  minLength: 'Doit avoir minimum {{minimumLength}} caractères (actuellement: {{currentLength}})',\n  maxLength: 'Doit avoir maximum {{maximumLength}} caractères (actuellement: {{currentLength}})',\n  pattern: 'Doit respecter: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Doit être une date, tel que \"2000-12-31\"';\n      case 'time':\n        return 'Doit être une heure, tel que \"16:20\" ou \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Doit être une date et une heure, tel que \"2000-03-14T01:59\" ou \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Doit être une adresse e-mail, tel que \"name@example.com\"';\n      case 'hostname':\n        return 'Doit être un nom de domaine, tel que \"example.com\"';\n      case 'ipv4':\n        return 'Doit être une adresse IPv4, tel que \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Doit être une adresse IPv6, tel que \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Doit être une URL, tel que \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Doit être un UUID, tel que \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Doit être une couleur, tel que \"#FFFFFF\" or \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Doit être un JSON Pointer, tel que \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Doit être un relative JSON Pointer, tel que \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Doit être une expression régulière, tel que \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Doit être avoir le format correct: ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Doit être supérieur à {{minimumValue}}',\n  exclusiveMinimum: 'Doit avoir minimum {{exclusiveMinimumValue}} charactères',\n  maximum: 'Doit être inférieur à {{maximumValue}}',\n  exclusiveMaximum: 'Doit avoir maximum {{exclusiveMaximumValue}} charactères',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Doit comporter ${decimals} ou moins de decimales.`;\n    } else {\n      return `Doit être un multiple de ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Doit comporter au minimum {{minimumProperties}} éléments',\n  maxProperties: 'Doit comporter au maximum {{maximumProperties}} éléments',\n  minItems: 'Doit comporter au minimum {{minimumItems}} éléments',\n  maxItems: 'Doit comporter au maximum {{minimumItems}} éléments',\n  uniqueItems: 'Tous les éléments doivent être uniques',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n",
    "import { Injectable } from '@angular/core';\nimport { AbstractControl, FormArray, FormGroup } from '@angular/forms';\nimport { filter } from 'rxjs-compat/operators/filter';\nimport { Subject } from 'rxjs-compat/Subject';\n\nimport * as Ajv from 'ajv';\nimport * as _ from 'lodash';\n\nimport {\n  hasValue, isArray, isDefined, isEmpty, isObject, isString\n} from './shared/validator.functions';\nimport {\n  fixTitle, forEach, hasOwn, toTitleCase\n} from './shared/utility.functions';\nimport { JsonPointer } from './shared/jsonpointer.functions';\nimport {\n  buildSchemaFromData, buildSchemaFromLayout, removeRecursiveReferences,\n  resolveSchemaReferences\n} from './shared/json-schema.functions';\nimport {\n  buildFormGroup, buildFormGroupTemplate, formatFormData, getControl\n} from './shared/form-group.functions';\nimport { buildLayout, getLayoutNode } from './shared/layout.functions';\nimport { enValidationMessages } from './locale/en-validation-messages';\nimport { frValidationMessages } from './locale/fr-validation-messages';\n\nexport interface TitleMapItem {\n  name?: string; value?: any; checked?: boolean; group?: string; items?: TitleMapItem[];\n}\nexport interface ErrorMessages {\n  [control_name: string]: { message: string|Function|Object, code: string }[];\n}\n\n\n@Injectable()\nexport class JsonSchemaFormService {\n  JsonFormCompatibility = false;\n  ReactJsonSchemaFormCompatibility = false;\n  AngularSchemaFormCompatibility = false;\n  tpldata: any = {};\n\n  ajvOptions: any = { allErrors: true, jsonPointers: true, unknownFormats: 'ignore' };\n  ajv: any = new Ajv(this.ajvOptions); // AJV: Another JSON Schema Validator\n  validateFormData: any = null; // Compiled AJV function to validate active form's schema\n\n  formValues: any = {}; // Internal form data (may not have correct types)\n  data: any = {}; // Output form data (formValues, formatted with correct data types)\n  schema: any = {}; // Internal JSON Schema\n  layout: any[] = []; // Internal form layout\n  formGroupTemplate: any = {}; // Template used to create formGroup\n  formGroup: any = null; // Angular formGroup, which powers the reactive form\n  framework: any = null; // Active framework component\n  formOptions: any; // Active options, used to configure the form\n\n  validData: any = null; // Valid form data (or null) (=== isValid ? data : null)\n  isValid: boolean = null; // Is current form data valid?\n  ajvErrors: any = null; // Ajv errors for current data\n  validationErrors: any = null; // Any validation errors for current data\n  dataErrors: any = new Map(); //\n  formValueSubscription: any = null; // Subscription to formGroup.valueChanges observable (for un- and re-subscribing)\n  dataChanges: Subject<any> = new Subject(); // Form data observable\n  isValidChanges: Subject<any> = new Subject(); // isValid observable\n  validationErrorChanges: Subject<any> = new Subject(); // validationErrors observable\n\n  arrayMap: Map<string, number> = new Map(); // Maps arrays in data object and number of tuple values\n  dataMap: Map<string, any> = new Map(); // Maps paths in form data to schema and formGroup paths\n  dataRecursiveRefMap: Map<string, string> = new Map(); // Maps recursive reference points in form data\n  schemaRecursiveRefMap: Map<string, string> = new Map(); // Maps recursive reference points in schema\n  schemaRefLibrary: any = {}; // Library of schemas for resolving schema $refs\n  layoutRefLibrary: any = { '': null }; // Library of layout nodes for adding to form\n  templateRefLibrary: any = {}; // Library of formGroup templates for adding to form\n  hasRootReference = false; // Does the form include a recursive reference to itself?\n\n  language = 'en-US'; // Does the form include a recursive reference to itself?\n\n  // Default global form options\n  defaultFormOptions: any = {\n    addSubmit: 'auto', // Add a submit button if layout does not have one?\n      // for addSubmit: true = always, false = never,\n      // 'auto' = only if layout is undefined (form is built from schema alone)\n    debug: false, // Show debugging output?\n    disableInvalidSubmit: true, // Disable submit if form invalid?\n    formDisabled: false, // Set entire form as disabled? (not editable, and disables outputs)\n    formReadonly: false, // Set entire form as read only? (not editable, but outputs still enabled)\n    fieldsRequired: false, // (set automatically) Are there any required fields in the form?\n    framework: 'no-framework', // The framework to load\n    loadExternalAssets: false, // Load external css and JavaScript for framework?\n    pristine: { errors: true, success: true },\n    supressPropertyTitles: false,\n    setSchemaDefaults: 'auto', // Set fefault values from schema?\n      // true = always set (unless overridden by layout default or formValues)\n      // false = never set\n      // 'auto' = set in addable components, and everywhere if formValues not set\n    setLayoutDefaults: 'auto', // Set fefault values from layout?\n      // true = always set (unless overridden by formValues)\n      // false = never set\n      // 'auto' = set in addable components, and everywhere if formValues not set\n    validateOnRender: 'auto', // Validate fields immediately, before they are touched?\n      // true = validate all fields immediately\n      // false = only validate fields after they are touched by user\n      // 'auto' = validate fields with values immediately, empty fields after they are touched\n    widgets: {}, // Any custom widgets to load\n    defautWidgetOptions: { // Default options for form control widgets\n      listItems: 1, // Number of list items to initially add to arrays with no default value\n      addable: true, // Allow adding items to an array or $ref point?\n      orderable: true, // Allow reordering items within an array?\n      removable: true, // Allow removing items from an array or $ref point?\n      enableErrorState: true, // Apply 'has-error' class when field fails validation?\n      // disableErrorState: false, // Don't apply 'has-error' class when field fails validation?\n      enableSuccessState: true, // Apply 'has-success' class when field validates?\n      // disableSuccessState: false, // Don't apply 'has-success' class when field validates?\n      feedback: false, // Show inline feedback icons?\n      feedbackOnRender: false, // Show errorMessage on Render?\n      notitle: false, // Hide title?\n      disabled: false, // Set control as disabled? (not editable, and excluded from output)\n      readonly: false, // Set control as read only? (not editable, but included in output)\n      returnEmptyFields: true, // return values for fields that contain no data?\n      validationMessages: {} // set by setLanguage()\n    },\n  };\n\n  constructor() {\n    this.setLanguage(this.language);\n  }\n\n  setLanguage(language: string = 'en-US') {\n    this.language = language;\n    const validationMessages = language.slice(0, 2) === 'fr' ?\n      frValidationMessages : enValidationMessages;\n    this.defaultFormOptions.defautWidgetOptions.validationMessages =\n      _.cloneDeep(validationMessages);\n  }\n\n  getData() { return this.data; }\n\n  getSchema() { return this.schema; }\n\n  getLayout() { return this.layout; }\n\n  resetAllValues() {\n    this.JsonFormCompatibility = false;\n    this.ReactJsonSchemaFormCompatibility = false;\n    this.AngularSchemaFormCompatibility = false;\n    this.tpldata = {};\n    this.validateFormData = null;\n    this.formValues = {};\n    this.schema = {};\n    this.layout = [];\n    this.formGroupTemplate = {};\n    this.formGroup = null;\n    this.framework = null;\n    this.data = {};\n    this.validData = null;\n    this.isValid = null;\n    this.validationErrors = null;\n    this.arrayMap = new Map();\n    this.dataMap = new Map();\n    this.dataRecursiveRefMap = new Map();\n    this.schemaRecursiveRefMap = new Map();\n    this.layoutRefLibrary = {};\n    this.schemaRefLibrary = {};\n    this.templateRefLibrary = {};\n    this.formOptions = _.cloneDeep(this.defaultFormOptions);\n  }\n\n  /**\n   * 'buildRemoteError' function\n   *\n   * Example errors:\n   * {\n   *   last_name: [ {\n   *     message: 'Last name must by start with capital letter.',\n   *     code: 'capital_letter'\n   *   } ],\n   *   email: [ {\n   *     message: 'Email must be from example.com domain.',\n   *     code: 'special_domain'\n   *   }, {\n   *     message: 'Email must contain an @ symbol.',\n   *     code: 'at_symbol'\n   *   } ]\n   * }\n   * @param {ErrorMessages} errors\n   */\n  buildRemoteError(errors: ErrorMessages) {\n    forEach(errors, (value, key) => {\n      if (key in this.formGroup.controls) {\n        for (const error of value) {\n          const err = {};\n          err[error['code']] = error['message'];\n          this.formGroup.get(key).setErrors(err, { emitEvent: true });\n        }\n      }\n    });\n  }\n\n  validateData(newValue: any, updateSubscriptions = true): void {\n\n    // Format raw form data to correct data types\n    this.data = formatFormData(\n      newValue, this.dataMap, this.dataRecursiveRefMap,\n      this.arrayMap, this.formOptions.returnEmptyFields\n    );\n    this.isValid = this.validateFormData(this.data);\n    this.validData = this.isValid ? this.data : null;\n    const compileErrors = errors => {\n      const compiledErrors = {};\n      (errors || []).forEach(error => {\n        if (!compiledErrors[error.dataPath]) { compiledErrors[error.dataPath] = []; }\n        compiledErrors[error.dataPath].push(error.message);\n      });\n      return compiledErrors;\n    };\n    this.ajvErrors = this.validateFormData.errors;\n    this.validationErrors = compileErrors(this.validateFormData.errors);\n    if (updateSubscriptions) {\n      this.dataChanges.next(this.data);\n      this.isValidChanges.next(this.isValid);\n      this.validationErrorChanges.next(this.ajvErrors);\n    }\n  }\n\n  buildFormGroupTemplate(formValues: any = null, setValues = true) {\n    this.formGroupTemplate = buildFormGroupTemplate(this, formValues, setValues);\n  }\n\n  buildFormGroup() {\n    this.formGroup = <FormGroup>buildFormGroup(this.formGroupTemplate);\n    if (this.formGroup) {\n      this.compileAjvSchema();\n      this.validateData(this.formGroup.value);\n\n      // Set up observables to emit data and validation info when form data changes\n      if (this.formValueSubscription) { this.formValueSubscription.unsubscribe(); }\n      this.formValueSubscription = this.formGroup.valueChanges\n        .subscribe(formValue => this.validateData(formValue));\n    }\n  }\n\n  buildLayout(widgetLibrary: any) {\n    this.layout = buildLayout(this, widgetLibrary);\n  }\n\n  setOptions(newOptions: any) {\n    if (isObject(newOptions)) {\n      const addOptions = _.cloneDeep(newOptions);\n      // Backward compatibility for 'defaultOptions' (renamed 'defautWidgetOptions')\n      if (isObject(addOptions.defaultOptions)) {\n        Object.assign(this.formOptions.defautWidgetOptions, addOptions.defaultOptions);\n        delete addOptions.defaultOptions;\n      }\n      if (isObject(addOptions.defautWidgetOptions)) {\n        Object.assign(this.formOptions.defautWidgetOptions, addOptions.defautWidgetOptions);\n        delete addOptions.defautWidgetOptions;\n      }\n      Object.assign(this.formOptions, addOptions);\n\n      // convert disableErrorState / disableSuccessState to enable...\n      const globalDefaults = this.formOptions.defautWidgetOptions;\n      ['ErrorState', 'SuccessState']\n        .filter(suffix => hasOwn(globalDefaults, 'disable' + suffix))\n        .forEach(suffix => {\n          globalDefaults['enable' + suffix] = !globalDefaults['disable' + suffix];\n          delete globalDefaults['disable' + suffix];\n        });\n    }\n  }\n\n  compileAjvSchema() {\n    if (!this.validateFormData) {\n\n      // if 'ui:order' exists in properties, move it to root before compiling with ajv\n      if (Array.isArray(this.schema.properties['ui:order'])) {\n        this.schema['ui:order'] = this.schema.properties['ui:order'];\n        delete this.schema.properties['ui:order'];\n      }\n      this.ajv.removeSchema(this.schema);\n      this.validateFormData = this.ajv.compile(this.schema);\n    }\n  }\n\n  buildSchemaFromData(data?: any, requireAllFields = false): any {\n    if (data) { return buildSchemaFromData(data, requireAllFields); }\n    this.schema = buildSchemaFromData(this.formValues, requireAllFields);\n  }\n\n  buildSchemaFromLayout(layout?: any): any {\n    if (layout) { return buildSchemaFromLayout(layout); }\n    this.schema = buildSchemaFromLayout(this.layout);\n  }\n\n\n  setTpldata(newTpldata: any = {}): void {\n    this.tpldata = newTpldata;\n  }\n\n  parseText(\n    text = '', value: any = {}, values: any = {}, key: number|string = null\n  ): string {\n    if (!text || !/{{.+?}}/.test(text)) { return text; }\n    return text.replace(/{{(.+?)}}/g, (...a) =>\n      this.parseExpression(a[1], value, values, key, this.tpldata)\n    );\n  }\n\n  parseExpression(\n    expression = '', value: any = {}, values: any = {},\n    key: number|string = null, tpldata: any = null\n  ) {\n    if (typeof expression !== 'string') { return ''; }\n    const index = typeof key === 'number' ? (key + 1) + '' : (key || '');\n    expression = expression.trim();\n    if ((expression[0] === '\\'' || expression[0] === '\"') &&\n      expression[0] === expression[expression.length - 1] &&\n      expression.slice(1, expression.length - 1).indexOf(expression[0]) === -1\n    ) {\n      return expression.slice(1, expression.length - 1);\n    }\n    if (expression === 'idx' || expression === '$index') { return index; }\n    if (expression === 'value' && !hasOwn(values, 'value')) { return value; }\n    if (['\"', '\\'', ' ', '||', '&&', '+'].every(delim => expression.indexOf(delim) === -1)) {\n      const pointer = JsonPointer.parseObjectPath(expression);\n      return pointer[0] === 'value' && JsonPointer.has(value, pointer.slice(1)) ?\n          JsonPointer.get(value, pointer.slice(1)) :\n        pointer[0] === 'values' && JsonPointer.has(values, pointer.slice(1)) ?\n          JsonPointer.get(values, pointer.slice(1)) :\n        pointer[0] === 'tpldata' && JsonPointer.has(tpldata, pointer.slice(1)) ?\n          JsonPointer.get(tpldata, pointer.slice(1)) :\n        JsonPointer.has(values, pointer) ? JsonPointer.get(values, pointer) : '';\n    }\n    if (expression.indexOf('[idx]') > -1) {\n      expression = expression.replace(/\\[idx\\]/g, <string>index);\n    }\n    if (expression.indexOf('[$index]') > -1) {\n      expression = expression.replace(/\\[$index\\]/g, <string>index);\n    }\n    // TODO: Improve expression evaluation by parsing quoted strings first\n    // let expressionArray = expression.match(/([^\"']+|\"[^\"]+\"|'[^']+')/g);\n    if (expression.indexOf('||') > -1) {\n      return expression.split('||').reduce((all, term) =>\n        all || this.parseExpression(term, value, values, key, tpldata), ''\n      );\n    }\n    if (expression.indexOf('&&') > -1) {\n      return expression.split('&&').reduce((all, term) =>\n        all && this.parseExpression(term, value, values, key, tpldata), ' '\n      ).trim();\n    }\n    if (expression.indexOf('+') > -1) {\n      return expression.split('+')\n        .map(term => this.parseExpression(term, value, values, key, tpldata))\n        .join('');\n    }\n    return '';\n  }\n\n  setArrayItemTitle(\n    parentCtx: any = {}, childNode: any = null, index: number = null\n  ): string {\n    const parentNode = parentCtx.layoutNode;\n    const parentValues: any = this.getFormControlValue(parentCtx);\n    const isArrayItem =\n      (parentNode.type || '').slice(-5) === 'array' && isArray(parentValues);\n    const text = JsonPointer.getFirst(\n      isArrayItem && childNode.type !== '$ref' ? [\n        [childNode, '/options/legend'],\n        [childNode, '/options/title'],\n        [parentNode, '/options/title'],\n        [parentNode, '/options/legend'],\n      ] : [\n        [childNode, '/options/title'],\n        [childNode, '/options/legend'],\n        [parentNode, '/options/title'],\n        [parentNode, '/options/legend']\n      ]\n    );\n    if (!text) { return text; }\n    const childValue = isArray(parentValues) && index < parentValues.length ?\n      parentValues[index] : parentValues;\n    return this.parseText(text, childValue, parentValues, index);\n  }\n\n  setItemTitle(ctx: any) {\n    return !ctx.options.title && /^(\\d+|-)$/.test(ctx.layoutNode.name) ?\n      null :\n      this.parseText(\n        ctx.options.title || toTitleCase(ctx.layoutNode.name),\n        this.getFormControlValue(this),\n        (this.getFormControlGroup(this) || <any>{}).value,\n        ctx.dataIndex[ctx.dataIndex.length - 1]\n      );\n  }\n\n  evaluateCondition(layoutNode: any, dataIndex: number[]): boolean {\n    const arrayIndex = dataIndex && dataIndex[dataIndex.length - 1];\n    let result = true;\n    if (hasValue((layoutNode.options || {}).condition)) {\n      if (typeof layoutNode.options.condition === 'string') {\n        let pointer = layoutNode.options.condition;\n        if (hasValue(arrayIndex)) {\n          pointer = pointer.replace('[arrayIndex]', `[${arrayIndex}]`);\n        }\n        pointer = JsonPointer.parseObjectPath(pointer);\n        result = !!JsonPointer.get(this.data, pointer);\n        if (!result && pointer[0] === 'model') {\n          result = !!JsonPointer.get({ model: this.data }, pointer);\n        }\n      } else if (typeof layoutNode.options.condition === 'function') {\n        result = layoutNode.options.condition(this.data);\n      } else if (typeof layoutNode.options.condition.functionBody === 'string') {\n        try {\n          const dynFn = new Function(\n            'model', 'arrayIndices', layoutNode.options.condition.functionBody\n          );\n          result = dynFn(this.data, dataIndex);\n        } catch (e) {\n          result = true;\n          console.error('condition functionBody errored out on evaluation: ' + layoutNode.options.condition.functionBody);\n        }\n      }\n    }\n    return result;\n  }\n\n  initializeControl(ctx: any, bind = true): boolean {\n    if (!isObject(ctx)) { return false; }\n    if (isEmpty(ctx.options)) {\n      ctx.options = !isEmpty((ctx.layoutNode || {}).options) ?\n        ctx.layoutNode.options : _.cloneDeep(this.formOptions);\n    }\n    ctx.formControl = this.getFormControl(ctx);\n    ctx.boundControl = bind && !!ctx.formControl;\n    if (ctx.formControl) {\n      ctx.controlName = this.getFormControlName(ctx);\n      ctx.controlValue = ctx.formControl.value;\n      ctx.controlDisabled = ctx.formControl.disabled;\n      ctx.options.errorMessage = ctx.formControl.status === 'VALID' ? null :\n        this.formatErrors(ctx.formControl.errors, ctx.options.validationMessages);\n      ctx.options.showErrors = this.formOptions.validateOnRender === true ||\n        (this.formOptions.validateOnRender === 'auto' && hasValue(ctx.controlValue));\n      ctx.formControl.statusChanges.subscribe(status =>\n        ctx.options.errorMessage = status === 'VALID' ? null :\n          this.formatErrors(ctx.formControl.errors, ctx.options.validationMessages)\n      );\n      ctx.formControl.valueChanges.subscribe(value => {\n        if (!_.isEqual(ctx.controlValue, value)) { ctx.controlValue = value; }\n      });\n    } else {\n      ctx.controlName = ctx.layoutNode.name;\n      ctx.controlValue = ctx.layoutNode.value || null;\n      const dataPointer = this.getDataPointer(ctx);\n      if (bind && dataPointer) {\n        console.error(`warning: control \"${dataPointer}\" is not bound to the Angular FormGroup.`);\n      }\n    }\n    return ctx.boundControl;\n  }\n\n  formatErrors(errors: any, validationMessages: any = {}): string {\n    if (isEmpty(errors)) { return null; }\n    if (!isObject(validationMessages)) { validationMessages = {}; }\n    const addSpaces = string => string[0].toUpperCase() + (string.slice(1) || '')\n      .replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' ');\n    const formatError = (error) => typeof error === 'object' ?\n      Object.keys(error).map(key =>\n        error[key] === true ? addSpaces(key) :\n        error[key] === false ? 'Not ' + addSpaces(key) :\n        addSpaces(key) + ': ' + formatError(error[key])\n      ).join(', ') :\n      addSpaces(error.toString());\n    const messages = [];\n    return Object.keys(errors)\n      // Hide 'required' error, unless it is the only one\n      .filter(errorKey => errorKey !== 'required' || Object.keys(errors).length === 1)\n      .map(errorKey =>\n        // If validationMessages is a string, return it\n        typeof validationMessages === 'string' ? validationMessages :\n        // If custom error message is a function, return function result\n        typeof validationMessages[errorKey] === 'function' ?\n          validationMessages[errorKey](errors[errorKey]) :\n        // If custom error message is a string, replace placeholders and return\n        typeof validationMessages[errorKey] === 'string' ?\n          // Does error message have any {{property}} placeholders?\n          !/{{.+?}}/.test(validationMessages[errorKey]) ?\n            validationMessages[errorKey] :\n            // Replace {{property}} placeholders with values\n            Object.keys(errors[errorKey])\n              .reduce((errorMessage, errorProperty) => errorMessage.replace(\n                new RegExp('{{' + errorProperty + '}}', 'g'),\n                errors[errorKey][errorProperty]\n              ), validationMessages[errorKey]) :\n          // If no custom error message, return formatted error data instead\n          addSpaces(errorKey) + ' Error: ' + formatError(errors[errorKey])\n      ).join('<br>');\n  }\n\n  updateValue(ctx: any, value: any): void {\n\n    // Set value of current control\n    ctx.controlValue = value;\n    if (ctx.boundControl) {\n      ctx.formControl.setValue(value);\n      ctx.formControl.markAsDirty();\n    }\n    ctx.layoutNode.value = value;\n\n    // Set values of any related controls in copyValueTo array\n    if (isArray(ctx.options.copyValueTo)) {\n      for (const item of ctx.options.copyValueTo) {\n        const targetControl = getControl(this.formGroup, item);\n        if (isObject(targetControl) && typeof targetControl.setValue === 'function') {\n          targetControl.setValue(value);\n          targetControl.markAsDirty();\n        }\n      }\n    }\n  }\n\n  updateArrayCheckboxList(ctx: any, checkboxList: TitleMapItem[]): void {\n    const formArray = <FormArray>this.getFormControl(ctx);\n\n    // Remove all existing items\n    while (formArray.value.length) { formArray.removeAt(0); }\n\n    // Re-add an item for each checked box\n    const refPointer = removeRecursiveReferences(\n      ctx.layoutNode.dataPointer + '/-', this.dataRecursiveRefMap, this.arrayMap\n    );\n    for (const checkboxItem of checkboxList) {\n      if (checkboxItem.checked) {\n        const newFormControl = buildFormGroup(this.templateRefLibrary[refPointer]);\n        newFormControl.setValue(checkboxItem.value);\n        formArray.push(newFormControl);\n      }\n    }\n    formArray.markAsDirty();\n  }\n\n  getFormControl(ctx: any): AbstractControl {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      ctx.layoutNode.type === '$ref'\n    ) { return null; }\n    return getControl(this.formGroup, this.getDataPointer(ctx));\n  }\n\n  getFormControlValue(ctx: any): AbstractControl {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      ctx.layoutNode.type === '$ref'\n    ) { return null; }\n    const control = getControl(this.formGroup, this.getDataPointer(ctx));\n    return control ? control.value : null;\n  }\n\n  getFormControlGroup(ctx: any): FormArray | FormGroup {\n    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer)) { return null; }\n    return getControl(this.formGroup, this.getDataPointer(ctx), true);\n  }\n\n  getFormControlName(ctx: any): string {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)\n    ) { return null; }\n    return JsonPointer.toKey(this.getDataPointer(ctx));\n  }\n\n  getLayoutArray(ctx: any): any[] {\n    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -1);\n  }\n\n  getParentNode(ctx: any): any {\n    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -2);\n  }\n\n  getDataPointer(ctx: any): string {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)\n    ) { return null; }\n    return JsonPointer.toIndexedPointer(\n      ctx.layoutNode.dataPointer, ctx.dataIndex, this.arrayMap\n    );\n  }\n\n  getLayoutPointer(ctx: any): string {\n    if (!hasValue(ctx.layoutIndex)) { return null; }\n    return '/' + ctx.layoutIndex.join('/items/');\n  }\n\n  isControlBound(ctx: any): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)\n    ) { return false; }\n    const controlGroup = this.getFormControlGroup(ctx);\n    const name = this.getFormControlName(ctx);\n    return controlGroup ? hasOwn(controlGroup.controls, name) : false;\n  }\n\n  addItem(ctx: any, name?: string): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.$ref) ||\n      !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex)\n    ) { return false; }\n\n    // Create a new Angular form control from a template in templateRefLibrary\n    const newFormGroup = buildFormGroup(this.templateRefLibrary[ctx.layoutNode.$ref]);\n\n    // Add the new form control to the parent formArray or formGroup\n    if (ctx.layoutNode.arrayItem) { // Add new array item to formArray\n      (<FormArray>this.getFormControlGroup(ctx)).push(newFormGroup);\n    } else { // Add new $ref item to formGroup\n      (<FormGroup>this.getFormControlGroup(ctx))\n        .addControl(name || this.getFormControlName(ctx), newFormGroup);\n    }\n\n    // Copy a new layoutNode from layoutRefLibrary\n    const newLayoutNode = getLayoutNode(ctx.layoutNode, this);\n    newLayoutNode.arrayItem = ctx.layoutNode.arrayItem;\n    if (ctx.layoutNode.arrayItemType) {\n      newLayoutNode.arrayItemType = ctx.layoutNode.arrayItemType;\n    } else {\n      delete newLayoutNode.arrayItemType;\n    }\n    if (name) {\n      newLayoutNode.name = name;\n      newLayoutNode.dataPointer += '/' + JsonPointer.escape(name);\n      newLayoutNode.options.title = fixTitle(name);\n    }\n\n    // Add the new layoutNode to the form layout\n    JsonPointer.insert(this.layout, this.getLayoutPointer(ctx), newLayoutNode);\n\n    return true;\n  }\n\n  moveArrayItem(ctx: any, oldIndex: number, newIndex: number): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex) ||\n      !isDefined(oldIndex) || !isDefined(newIndex) || oldIndex === newIndex\n    ) { return false; }\n\n    // Move item in the formArray\n    const formArray = <FormArray>this.getFormControlGroup(ctx);\n    const arrayItem = formArray.at(oldIndex);\n    formArray.removeAt(oldIndex);\n    formArray.insert(newIndex, arrayItem);\n    formArray.updateValueAndValidity();\n\n    // Move layout item\n    const layoutArray = this.getLayoutArray(ctx);\n    layoutArray.splice(newIndex, 0, layoutArray.splice(oldIndex, 1)[0]);\n    return true;\n  }\n\n  removeItem(ctx: any): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex)\n    ) { return false; }\n\n    // Remove the Angular form control from the parent formArray or formGroup\n    if (ctx.layoutNode.arrayItem) { // Remove array item from formArray\n      (<FormArray>this.getFormControlGroup(ctx))\n        .removeAt(ctx.dataIndex[ctx.dataIndex.length - 1]);\n    } else { // Remove $ref item from formGroup\n      (<FormGroup>this.getFormControlGroup(ctx))\n        .removeControl(this.getFormControlName(ctx));\n    }\n\n    // Remove layoutNode from layout\n    JsonPointer.remove(this.layout, this.getLayoutPointer(ctx));\n    return true;\n  }\n}\n",
    "import { ChangeDetectionStrategy, Component, Input, OnInit } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'add-reference-widget',\n  template: `\n    <button *ngIf=\"showAddButton\"\n      [class]=\"options?.fieldHtmlClass || ''\"\n      [disabled]=\"options?.readonly\"\n      (click)=\"addItem($event)\">\n      <span *ngIf=\"options?.icon\" [class]=\"options?.icon\"></span>\n      <span *ngIf=\"options?.title\" [innerHTML]=\"buttonText\"></span>\n    </button>`,\n    changeDetection: ChangeDetectionStrategy.Default,\n})\nexport class AddReferenceComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  previousLayoutIndex: number[];\n  previousDataIndex: number[];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n  }\n\n  get showAddButton(): boolean {\n    return !this.layoutNode.arrayItem ||\n      this.layoutIndex[this.layoutIndex.length - 1] < this.options.maxItems;\n  }\n\n  addItem(event) {\n    event.preventDefault();\n    this.jsf.addItem(this);\n  }\n\n  get buttonText(): string {\n    const parent: any = {\n      dataIndex: this.dataIndex.slice(0, -1),\n      layoutIndex: this.layoutIndex.slice(0, -1),\n      layoutNode: this.jsf.getParentNode(this)\n    };\n    return parent.layoutNode.add ||\n      this.jsf.setArrayItemTitle(parent, this.layoutNode, this.itemCount);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'one-of-widget',\n  template: ``,\n})\nexport class OneOfComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'button-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <button\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n        <span *ngIf=\"options?.icon || options?.title\"\n          [class]=\"options?.icon\"\n          [innerHTML]=\"options?.title\"></span>\n      </button>\n    </div>`,\n})\nexport class ButtonComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    if (typeof this.options.onClick === 'function') {\n      this.options.onClick(event);\n    } else {\n      this.jsf.updateValue(this, event.target.value);\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'checkbox-widget',\n  template: `\n    <label\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.itemLabelHtmlClass || ''\">\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        type=\"checkbox\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [checked]=\"isChecked ? 'checked' : null\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [value]=\"controlValue\"\n        type=\"checkbox\"\n        (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </label>`,\n})\nexport class CheckboxComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  trueValue: any = true;\n  falseValue: any = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (this.controlValue === null || this.controlValue === undefined) {\n      this.controlValue = this.options.title;\n    }\n  }\n\n  updateValue(event) {\n    event.preventDefault();\n    this.jsf.updateValue(this, event.target.checked ? this.trueValue : this.falseValue);\n  }\n\n  get isChecked() {\n    return this.jsf.getFormControlValue(this) === this.trueValue;\n  }\n}\n",
    "import { Directive, ElementRef, HostListener, Input, NgZone, OnInit } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { JsonPointer } from '../shared/jsonpointer.functions';\n\n/**\n * OrderableDirective\n *\n * Enables array elements to be reordered by dragging and dropping.\n *\n * Only works for arrays that have at least two elements.\n *\n * Also detects arrays-within-arrays, and correctly moves either\n * the child array element or the parent array element,\n * depending on the drop targert.\n *\n * Listeners for movable element being dragged:\n * - dragstart: add 'dragging' class to element, set effectAllowed = 'move'\n * - dragover: set dropEffect = 'move'\n * - dragend: remove 'dragging' class from element\n *\n * Listeners for stationary items being dragged over:\n * - dragenter: add 'drag-target-...' classes to element\n * - dragleave: remove 'drag-target-...' classes from element\n * - drop: remove 'drag-target-...' classes from element, move dropped array item\n */\n@Directive({\n  selector: '[orderable]',\n})\nexport class OrderableDirective implements OnInit {\n  arrayLayoutIndex: string;\n  element: any;\n  overParentElement = false;\n  overChildElement = false;\n  @Input() orderable: boolean;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private elementRef: ElementRef,\n    private jsf: JsonSchemaFormService,\n    private ngZone: NgZone\n  ) { }\n\n  ngOnInit() {\n    if (this.orderable && this.layoutNode && this.layoutIndex && this.dataIndex) {\n      this.element = this.elementRef.nativeElement;\n      this.element.draggable = true;\n      this.arrayLayoutIndex = 'move:' + this.layoutIndex.slice(0, -1).toString();\n\n      this.ngZone.runOutsideAngular(() => {\n\n        // Listeners for movable element being dragged:\n\n        this.element.addEventListener('dragstart', (event) => {\n          event.dataTransfer.effectAllowed = 'move';\n          // Hack to bypass stupid HTML drag-and-drop dataTransfer protection\n          // so drag source info will be available on dragenter\n          const sourceArrayIndex = this.dataIndex[this.dataIndex.length - 1];\n          sessionStorage.setItem(this.arrayLayoutIndex, sourceArrayIndex + '');\n        });\n\n        this.element.addEventListener('dragover', (event) => {\n          if (event.preventDefault) { event.preventDefault(); }\n          event.dataTransfer.dropEffect = 'move';\n          return false;\n        });\n\n        // Listeners for stationary items being dragged over:\n\n        this.element.addEventListener('dragenter', (event) => {\n          // Part 1 of a hack, inspired by Dragster, to simulate mouseover and mouseout\n          // behavior while dragging items - http://bensmithett.github.io/dragster/\n          if (this.overParentElement) {\n            return this.overChildElement = true;\n          } else {\n            this.overParentElement = true;\n          }\n\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          if (sourceArrayIndex !== null) {\n            if (this.dataIndex[this.dataIndex.length - 1] < +sourceArrayIndex) {\n              this.element.classList.add('drag-target-top');\n            } else if (this.dataIndex[this.dataIndex.length - 1] > +sourceArrayIndex) {\n              this.element.classList.add('drag-target-bottom');\n            }\n          }\n        });\n\n        this.element.addEventListener('dragleave', (event) => {\n          // Part 2 of the Dragster hack\n          if (this.overChildElement) {\n            this.overChildElement = false;\n          } else if (this.overParentElement) {\n            this.overParentElement = false;\n          }\n\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          if (!this.overParentElement && !this.overChildElement && sourceArrayIndex !== null) {\n            this.element.classList.remove('drag-target-top');\n            this.element.classList.remove('drag-target-bottom');\n          }\n        });\n\n        this.element.addEventListener('drop', (event) => {\n          this.element.classList.remove('drag-target-top');\n          this.element.classList.remove('drag-target-bottom');\n          // Confirm that drop target is another item in the same array as source item\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          const destArrayIndex = this.dataIndex[this.dataIndex.length - 1];\n          if (sourceArrayIndex !== null && +sourceArrayIndex !== destArrayIndex) {\n            // Move array item\n            this.jsf.moveArrayItem(this, +sourceArrayIndex, destArrayIndex);\n          }\n          sessionStorage.removeItem(this.arrayLayoutIndex);\n          return false;\n        });\n\n      });\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { FormArray, AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService, TitleMapItem } from '../json-schema-form.service';\nimport { buildTitleMap } from '../shared';\n\n@Component({\n  selector: 'checkboxes-widget',\n  template: `\n    <label *ngIf=\"options?.title\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = checkboxes-inline or checkboxbuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\" [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let checkboxItem of checkboxList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"checkbox\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"checkboxItem.checked\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [name]=\"checkboxItem?.name\"\n          [readonly]=\"options?.readonly ? 'readonly' : null\"\n          [value]=\"checkboxItem.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"checkboxItem.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular checkboxes -->\n    <div *ngIf=\"layoutOrientation === 'vertical'\">\n      <div *ngFor=\"let checkboxItem of checkboxList\" [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"checkbox\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"checkboxItem.checked\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"options?.name + '/' + checkboxItem.value\"\n            [name]=\"checkboxItem?.name\"\n            [readonly]=\"options?.readonly ? 'readonly' : null\"\n            [value]=\"checkboxItem.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"checkboxItem?.name\"></span>\n        </label>\n      </div>\n    </div>`,\n})\nexport class CheckboxesComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  layoutOrientation: string;\n  formArray: AbstractControl;\n  checkboxList: TitleMapItem[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.layoutOrientation = (this.layoutNode.type === 'checkboxes-inline' ||\n      this.layoutNode.type === 'checkboxbuttons') ? 'horizontal' : 'vertical';\n    this.jsf.initializeControl(this);\n    this.checkboxList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames, this.options.enum, true\n    );\n    if (this.boundControl) {\n      const formArray = this.jsf.getFormControl(this);\n      this.checkboxList.forEach(checkboxItem =>\n        checkboxItem.checked = formArray.value.includes(checkboxItem.value)\n      );\n    }\n  }\n\n  updateValue(event) {\n    for (const checkboxItem of this.checkboxList) {\n      if (event.target.value === checkboxItem.value) {\n        checkboxItem.checked = event.target.checked;\n      }\n    }\n    if (this.boundControl) {\n      this.jsf.updateArrayCheckboxList(this, this.checkboxList);\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'file-widget',\n  template: ``,\n})\nexport class FileComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'input-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n        <datalist *ngIf=\"options?.typeahead?.source\"\n          [id]=\"'control' + layoutNode?._id + 'Autocomplete'\">\n          <option *ngFor=\"let word of options?.typeahead?.source\" [value]=\"word\">\n        </datalist>\n    </div>`,\n})\nexport class InputComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: string;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  autoCompleteList: string[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'message-widget',\n  template: `\n    <span *ngIf=\"message\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [innerHTML]=\"message\"></span>`,\n})\nexport class MessageComponent implements OnInit {\n  options: any;\n  message: string = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.message = this.options.help || this.options.helpvalue ||\n      this.options.msg || this.options.message;\n  }\n}\n",
    "import { Component, Input } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'none-widget',\n  template: ``,\n})\nexport class NoneComponent {\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'number-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n      <span *ngIf=\"layoutNode?.type === 'range'\" [innerHTML]=\"controlValue\"></span>\n    </div>`,\n})\nexport class NumberComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  allowNegative = true;\n  allowDecimal = true;\n  allowExponents = false;\n  lastValidNumber = '';\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (this.layoutNode.dataType === 'integer') { this.allowDecimal = false; }\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { buildTitleMap } from '../shared';\n\n@Component({\n  selector: 'radios-widget',\n  template: `\n    <label *ngIf=\"options?.title\"\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = radios-inline or radiobuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\"\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let radioItem of radiosList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') +\n          ((controlValue + '' === radioItem?.value + '') ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"radio\"\n          [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n          [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"radioItem?.value === controlValue\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [name]=\"controlName\"\n          [value]=\"radioItem?.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"radioItem?.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular radios -->\n    <div *ngIf=\"layoutOrientation !== 'horizontal'\">\n      <div *ngFor=\"let radioItem of radiosList\"\n        [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') +\n            ((controlValue + '' === radioItem?.value + '') ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"radio\"\n            [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n            [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"radioItem?.value === controlValue\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n            [name]=\"controlName\"\n            [value]=\"radioItem?.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </label>\n      </div>\n    </div>`,\n})\nexport class RadiosComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  layoutOrientation = 'vertical';\n  radiosList: any[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    if (this.layoutNode.type === 'radios-inline' ||\n      this.layoutNode.type === 'radiobuttons'\n    ) {\n      this.layoutOrientation = 'horizontal';\n    }\n    this.radiosList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, true\n    );\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, Host } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { hasValue, JsonPointer } from '../shared';\n\n@Component({\n  selector: 'root-widget',\n  template: `\n    <div *ngFor=\"let layoutItem of layout; let i = index\"\n      [class.form-flex-item]=\"isFlexItem\"\n      [style.align-self]=\"(layoutItem.options || {})['align-self']\"\n      [style.flex-basis]=\"getFlexAttribute(layoutItem, 'flex-basis')\"\n      [style.flex-grow]=\"getFlexAttribute(layoutItem, 'flex-grow')\"\n      [style.flex-shrink]=\"getFlexAttribute(layoutItem, 'flex-shrink')\"\n      [style.order]=\"(layoutItem.options || {}).order\">\n      <div\n        [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"\n        [orderable]=\"isDraggable(layoutItem)\">\n        <select-framework-widget *ngIf=\"showWidget(layoutItem)\"\n          [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n          [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n          [layoutNode]=\"layoutItem\"></select-framework-widget>\n      </div>\n    </div>`,\n  styles: [`\n    [draggable=true] {\n      transition: all 150ms cubic-bezier(.4, 0, .2, 1);\n    }\n    [draggable=true]:hover {\n      cursor: move;\n      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);\n      position: relative; z-index: 10;\n      margin-top: -1px;\n      margin-left: -1px;\n      margin-right: 1px;\n      margin-bottom: 1px;\n    }\n    [draggable=true].drag-target-top {\n      box-shadow: 0 -2px 0 #000;\n      position: relative; z-index: 20;\n    }\n    [draggable=true].drag-target-bottom {\n      box-shadow: 0 2px 0 #000;\n      position: relative; z-index: 20;\n    }\n  `],\n})\nexport class RootComponent {\n  options: any;\n  @Input() dataIndex: number[];\n  @Input() layoutIndex: number[];\n  @Input() layout: any[];\n  @Input() isOrderable: boolean;\n  @Input() isFlexItem = false;\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  isDraggable(node: any): boolean {\n    return node.arrayItem && node.type !== '$ref' &&\n      node.arrayItemType === 'list' && this.isOrderable !== false;\n  }\n\n  // Set attributes for flexbox child\n  // (container attributes are set in section.component)\n  getFlexAttribute(node: any, attribute: string) {\n    const index = ['flex-grow', 'flex-shrink', 'flex-basis'].indexOf(attribute);\n    return ((node.options || {}).flex || '').split(/\\s+/)[index] ||\n      (node.options || {})[attribute] || ['1', '1', 'auto'][index];\n  }\n\n  showWidget(layoutNode: any): boolean {\n    return this.jsf.evaluateCondition(layoutNode, this.dataIndex);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\n\nimport { toTitleCase } from '../shared';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'section-widget',\n  template: `\n    <div *ngIf=\"containerType === 'div'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <label *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></label>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n    </div>\n    <fieldset *ngIf=\"containerType === 'fieldset'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\"\n      [disabled]=\"options?.readonly\">\n      <legend *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></legend>\n      <div *ngIf=\"options?.messageLocation !== 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n      <div *ngIf=\"options?.messageLocation === 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n    </fieldset>`,\n  styles: [`\n    .legend { font-weight: bold; }\n    .expandable > legend:before, .expandable > label:before  { content: '▶'; padding-right: .3em; }\n    .expanded > legend:before, .expanded > label:before  { content: '▼'; padding-right: .2em; }\n  `],\n})\nexport class SectionComponent implements OnInit {\n  options: any;\n  expanded = true;\n  containerType: string;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  get sectionTitle() {\n    return this.options.notitle ? null : this.jsf.setItemTitle(this);\n  }\n\n  ngOnInit() {\n    this.jsf.initializeControl(this);\n    this.options = this.layoutNode.options || {};\n    this.expanded = typeof this.options.expanded === 'boolean' ?\n      this.options.expanded : !this.options.expandable;\n    switch (this.layoutNode.type) {\n      case 'fieldset': case 'array': case 'tab': case 'advancedfieldset':\n      case 'authfieldset': case 'optionfieldset': case 'selectfieldset':\n        this.containerType = 'fieldset';\n      break;\n      default: // 'div', 'flex', 'section', 'conditional', 'actions', 'tagsinput'\n        this.containerType = 'div';\n      break;\n    }\n  }\n\n  toggleExpanded() {\n    if (this.options.expandable) { this.expanded = !this.expanded; }\n  }\n\n  // Set attributes for flexbox container\n  // (child attributes are set in root.component)\n  getFlexAttribute(attribute: string) {\n    const flexActive: boolean =\n      this.layoutNode.type === 'flex' ||\n      !!this.options.displayFlex ||\n      this.options.display === 'flex';\n    if (attribute !== 'flex' && !flexActive) { return null; }\n    switch (attribute) {\n      case 'is-flex':\n        return flexActive;\n      case 'display':\n        return flexActive ? 'flex' : 'initial';\n      case 'flex-direction': case 'flex-wrap':\n        const index = ['flex-direction', 'flex-wrap'].indexOf(attribute);\n        return (this.options['flex-flow'] || '').split(/\\s+/)[index] ||\n          this.options[attribute] || ['column', 'nowrap'][index];\n      case 'justify-content': case 'align-items': case 'align-content':\n        return this.options[attribute];\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { buildTitleMap, isArray } from '../shared';\n\n@Component({\n  selector: 'select-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <select *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n      <select *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        (change)=\"updateValue($event)\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [selected]=\"selectItem?.value === controlValue\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [attr.selected]=\"subItem?.value === controlValue\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n    </div>`,\n})\nexport class SelectComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  selectList: any[] = [];\n  isArray = isArray;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.selectList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, !!this.options.required, !!this.options.flatList\n    );\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'select-framework-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class SelectFrameworkComponent implements OnChanges, OnInit {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (!this.newComponent && this.jsf.framework) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.jsf.framework)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n",
    "import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'select-widget-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class SelectWidgetComponent implements OnChanges, OnInit {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (!this.newComponent && (this.layoutNode || {}).widget) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.layoutNode.widget)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { hasOwn } from '../shared/utility.functions';\n\n@Component({\n  selector: 'submit-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <input\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n    </div>`,\n})\nexport class SubmitComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (hasOwn(this.options, 'disabled')) {\n      this.controlDisabled = this.options.disabled;\n    } else if (this.jsf.formOptions.disableInvalidSubmit) {\n      this.controlDisabled = !this.jsf.isValid;\n      this.jsf.isValidChanges.subscribe(isValid => this.controlDisabled = !isValid);\n    }\n    if (this.controlValue === null || this.controlValue === undefined) {\n      this.controlValue = this.options.title;\n    }\n  }\n\n  updateValue(event) {\n    if (typeof this.options.onClick === 'function') {\n      this.options.onClick(event);\n    } else {\n      this.jsf.updateValue(this, event.target.value);\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'tabs-widget',\n  template: `\n    <ul\n      [class]=\"options?.labelHtmlClass || ''\">\n      <li *ngFor=\"let item of layoutNode?.items; let i = index\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (selectedItem === i ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + options?.style?.unselected))\"\n        role=\"presentation\"\n        data-tabs>\n        <a *ngIf=\"showAddTab || item.type !== '$ref'\"\n           [class]=\"'nav-link' + (selectedItem === i ? (' ' + options?.activeClass + ' ' + options?.style?.selected) :\n            (' ' + options?.style?.unselected))\"\n          [innerHTML]=\"setTabTitle(item, i)\"\n          (click)=\"select(i)\"></a>\n      </li>\n    </ul>\n\n    <div *ngFor=\"let layoutItem of layoutNode?.items; let i = index\"\n      [class]=\"options?.htmlClass || ''\">\n\n      <select-framework-widget *ngIf=\"selectedItem === i\"\n        [class]=\"(options?.fieldHtmlClass || '') +\n          ' ' + (options?.activeClass || '') +\n          ' ' + (options?.style?.selected || '')\"\n        [dataIndex]=\"layoutNode?.dataType === 'array' ? (dataIndex || []).concat(i) : dataIndex\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"></select-framework-widget>\n\n    </div>`,\n  styles: [` a { cursor: pointer; } `],\n})\nexport class TabsComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  selectedItem = 0;\n  showAddTab = true;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.itemCount = this.layoutNode.items.length - 1;\n    this.updateControl();\n  }\n\n  select(index) {\n    if (this.layoutNode.items[index].type === '$ref') {\n      this.itemCount = this.layoutNode.items.length;\n      this.jsf.addItem({\n        layoutNode: this.layoutNode.items[index],\n        layoutIndex: this.layoutIndex.concat(index),\n        dataIndex: this.dataIndex.concat(index)\n      });\n      this.updateControl();\n    }\n    this.selectedItem = index;\n  }\n\n  updateControl() {\n    const lastItem = this.layoutNode.items[this.layoutNode.items.length - 1];\n    if (lastItem.type === '$ref' &&\n      this.itemCount >= (lastItem.options.maxItems || 1000)\n    ) {\n      this.showAddTab = false;\n    }\n  }\n\n  setTabTitle(item: any, index: number): string {\n    return this.jsf.setArrayItemTitle(this, item, index);\n  }\n}\n",
    "import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'template-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class TemplateComponent implements OnInit, OnChanges {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (!this.newComponent && this.layoutNode.options.template) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.layoutNode.options.template)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'textarea-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <textarea *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"></textarea>\n      <textarea *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">{{controlValue}}</textarea>\n    </div>`,\n})\nexport class TextareaComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { hasOwn } from '../shared/utility.functions';\n\nimport { AddReferenceComponent } from './add-reference.component';\nimport { OneOfComponent } from './one-of.component';\nimport { ButtonComponent } from './button.component';\nimport { CheckboxComponent } from './checkbox.component';\nimport { CheckboxesComponent } from './checkboxes.component';\nimport { FileComponent } from './file.component';\nimport { HiddenComponent } from './hidden.component';\nimport { InputComponent } from './input.component';\nimport { MessageComponent } from './message.component';\nimport { NoneComponent } from './none.component';\nimport { NumberComponent } from './number.component';\nimport { RadiosComponent } from './radios.component';\nimport { RootComponent } from './root.component';\nimport { SectionComponent } from './section.component';\nimport { SelectComponent } from './select.component';\nimport { SelectFrameworkComponent } from './select-framework.component';\nimport { SelectWidgetComponent } from './select-widget.component';\nimport { SubmitComponent } from './submit.component';\nimport { TabComponent } from './tab.component';\nimport { TabsComponent } from './tabs.component';\nimport { TemplateComponent } from './template.component';\nimport { TextareaComponent } from './textarea.component';\n\n@Injectable()\nexport class WidgetLibraryService {\n\n  defaultWidget = 'text';\n  widgetLibrary: any = {\n\n  // Angular JSON Schema Form administrative widgets\n    'none': NoneComponent, // Placeholder, for development - displays nothing\n    'root': RootComponent, // Form root, renders a complete layout\n    'select-framework': SelectFrameworkComponent, // Applies the selected framework to a specified widget\n    'select-widget': SelectWidgetComponent, // Displays a specified widget\n    '$ref': AddReferenceComponent, // Button to add a new array item or $ref element\n\n  // Free-form text HTML 'input' form control widgets <input type=\"...\">\n    'email': 'text',\n    'integer': 'number', // Note: 'integer' is not a recognized HTML input type\n    'number': NumberComponent,\n    'password': 'text',\n    'search': 'text',\n    'tel': 'text',\n    'text': InputComponent,\n    'url': 'text',\n\n  // Controlled text HTML 'input' form control widgets <input type=\"...\">\n    'color': 'text',\n    'date': 'text',\n    'datetime': 'text',\n    'datetime-local': 'text',\n    'month': 'text',\n    'range': 'number',\n    'time': 'text',\n    'week': 'text',\n\n  // Non-text HTML 'input' form control widgets <input type=\"...\">\n    // 'button': <input type=\"button\"> not used, use <button> instead\n    'checkbox': CheckboxComponent, // TODO: Set ternary = true for 3-state ??\n    'file': FileComponent, // TODO: Finish 'file' widget\n    'hidden': 'text',\n    'image': 'text', // TODO: Figure out how to handle these\n    'radio': 'radios',\n    'reset': 'submit', // TODO: Figure out how to handle these\n    'submit': SubmitComponent,\n\n  // Other (non-'input') HTML form control widgets\n    'button': ButtonComponent,\n    'select': SelectComponent,\n    // 'option': automatically generated by select widgets\n    // 'optgroup': automatically generated by select widgets\n    'textarea': TextareaComponent,\n\n  // HTML form control widget sets\n    'checkboxes': CheckboxesComponent, // Grouped list of checkboxes\n    'checkboxes-inline': 'checkboxes', // Checkboxes in one line\n    'checkboxbuttons': 'checkboxes', // Checkboxes as html buttons\n    'radios': RadiosComponent, // Grouped list of radio buttons\n    'radios-inline': 'radios', // Radio controls in one line\n    'radiobuttons': 'radios', // Radio controls as html buttons\n\n  // HTML Layout widgets\n    // 'label': automatically added to data widgets\n    // 'legend': automatically added to fieldsets\n    'section': SectionComponent, // Just a div <div>\n    'div': 'section', // Still just a div <div>\n    'fieldset': 'section', // A fieldset, with an optional legend <fieldset>\n    'flex': 'section', // A flexbox container <div style=\"display: flex\">\n\n  // Non-HTML layout widgets\n    'one-of': OneOfComponent, // A select box that changes another input\n                              // TODO: Finish 'one-of' widget\n    'array': 'section', // A list you can add, remove and reorder <fieldset>\n    'tabarray': 'tabs', // A tabbed version of array\n    'tab': 'section', // A tab group, similar to a fieldset or section <fieldset>\n    'tabs': TabsComponent, // A tabbed set of panels with different controls\n    'message': MessageComponent, // Insert arbitrary html\n    'help': 'message', // Insert arbitrary html\n    'msg': 'message', // Insert arbitrary html\n    'html': 'message', // Insert arbitrary html\n    'template': TemplateComponent, // Insert a custom Angular component\n\n  // Widgets included for compatibility with JSON Form API\n    'advancedfieldset': 'section', // Adds 'Advanced settings' title <fieldset>\n    'authfieldset': 'section', // Adds 'Authentication settings' title <fieldset>\n    'optionfieldset': 'one-of', // Option control, displays selected sub-item <fieldset>\n    'selectfieldset': 'one-of', // Select control, displays selected sub-item <fieldset>\n    'conditional': 'section', // Identical to 'section' (depeciated) <div>\n    'actions': 'section', // Horizontal button list, can only submit, uses buttons as items <div>\n    'tagsinput': 'section', // For entering short text tags <div>\n    // See: http://ulion.github.io/jsonform/playground/?example=fields-checkboxbuttons\n\n  // Widgets included for compatibility with React JSON Schema Form API\n    'updown': 'number',\n    'date-time': 'datetime-local',\n    'alt-datetime': 'datetime-local',\n    'alt-date': 'date',\n\n  // Widgets included for compatibility with Angular Schema Form API\n    'wizard': 'section', // TODO: Sequential panels with \"Next\" and \"Previous\" buttons\n\n  // Widgets included for compatibility with other libraries\n    'textline': 'text',\n\n  // Recommended 3rd-party add-on widgets (TODO: create wrappers for these...)\n    // 'ng2-select': Select control replacement - http://valor-software.com/ng2-select/\n    // 'flatpickr': Flatpickr date picker - https://github.com/chmln/flatpickr\n    // 'pikaday': Pikaday date picker - https://github.com/dbushell/Pikaday\n    // 'spectrum': Spectrum color picker - http://bgrins.github.io/spectrum\n    // 'bootstrap-slider': Bootstrap Slider range control - https://github.com/seiyria/bootstrap-slider\n    // 'ace': ACE code editor - https://ace.c9.io\n    // 'ckeditor': CKEditor HTML / rich text editor - http://ckeditor.com\n    // 'tinymce': TinyMCE HTML / rich text editor - https://www.tinymce.com\n    // 'imageselect': Bootstrap drop-down image selector - http://silviomoreto.github.io/bootstrap-select\n    // 'wysihtml5': HTML editor - http://jhollingworth.github.io/bootstrap-wysihtml5\n    // 'quill': Quill HTML / rich text editor (?) - https://quilljs.com\n  };\n  registeredWidgets: any = { };\n  frameworkWidgets: any = { };\n  activeWidgets: any = { };\n\n  constructor() {\n    this.setActiveWidgets();\n  }\n\n  setActiveWidgets(): boolean {\n    this.activeWidgets = Object.assign(\n      { }, this.widgetLibrary, this.frameworkWidgets, this.registeredWidgets\n    );\n    for (const widgetName of Object.keys(this.activeWidgets)) {\n      let widget: any = this.activeWidgets[widgetName];\n      // Resolve aliases\n      if (typeof widget === 'string') {\n        const usedAliases: string[] = [];\n        while (typeof widget === 'string' && !usedAliases.includes(widget)) {\n          usedAliases.push(widget);\n          widget = this.activeWidgets[widget];\n        }\n        if (typeof widget !== 'string') {\n          this.activeWidgets[widgetName] = widget;\n        }\n      }\n    }\n    return true;\n  }\n\n  setDefaultWidget(type: string): boolean {\n    if (!this.hasWidget(type)) { return false; }\n    this.defaultWidget = type;\n    return true;\n  }\n\n  hasWidget(type: string, widgetSet = 'activeWidgets'): boolean {\n    if (!type || typeof type !== 'string') { return false; }\n    return hasOwn(this[widgetSet], type);\n  }\n\n  hasDefaultWidget(type: string): boolean {\n    return this.hasWidget(type, 'widgetLibrary');\n  }\n\n  registerWidget(type: string, widget: any): boolean {\n    if (!type || !widget || typeof type !== 'string') { return false; }\n    this.registeredWidgets[type] = widget;\n    return this.setActiveWidgets();\n  }\n\n  unRegisterWidget(type: string): boolean {\n    if (!hasOwn(this.registeredWidgets, type)) { return false; }\n    delete this.registeredWidgets[type];\n    return this.setActiveWidgets();\n  }\n\n  unRegisterAllWidgets(unRegisterFrameworkWidgets = true): boolean {\n    this.registeredWidgets = { };\n    if (unRegisterFrameworkWidgets) { this.frameworkWidgets = { }; }\n    return this.setActiveWidgets();\n  }\n\n  registerFrameworkWidgets(widgets: any): boolean {\n    if (widgets === null || typeof widgets !== 'object') { widgets = { }; }\n    this.frameworkWidgets = widgets;\n    return this.setActiveWidgets();\n  }\n\n  unRegisterFrameworkWidgets(): boolean {\n    if (Object.keys(this.frameworkWidgets).length) {\n      this.frameworkWidgets = { };\n      return this.setActiveWidgets();\n    }\n    return false;\n  }\n\n  getWidget(type?: string, widgetSet = 'activeWidgets'): any {\n    if (this.hasWidget(type, widgetSet)) {\n      return this[widgetSet][type];\n    } else if (this.hasWidget(this.defaultWidget, widgetSet)) {\n      return this[widgetSet][this.defaultWidget];\n    } else {\n      return null;\n    }\n  }\n\n  getAllWidgets(): any {\n    return {\n      widgetLibrary: this.widgetLibrary,\n      registeredWidgets: this.registeredWidgets,\n      frameworkWidgets: this.frameworkWidgets,\n      activeWidgets: this.activeWidgets,\n    };\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class Framework {\n  name: string;\n  framework: any;\n  widgets?: { [key: string]: any } = {};\n  stylesheets?: string[] = [];\n  scripts?: string[] = [];\n}\n",
    "import { Inject, Injectable } from '@angular/core';\n\nimport { WidgetLibraryService } from '../widget-library/widget-library.service';\nimport { hasOwn } from '../shared/utility.functions';\n\nimport { Framework } from './framework';\n\n// Possible future frameworks:\n// - Foundation 6:\n//   http://justindavis.co/2017/06/15/using-foundation-6-in-angular-4/\n//   https://github.com/zurb/foundation-sites\n// - Semantic UI:\n//   https://github.com/edcarroll/ng2-semantic-ui\n//   https://github.com/vladotesanovic/ngSemantic\n\n@Injectable()\nexport class FrameworkLibraryService {\n  activeFramework: Framework = null;\n  stylesheets: (HTMLStyleElement|HTMLLinkElement)[];\n  scripts: HTMLScriptElement[];\n  loadExternalAssets = false;\n  defaultFramework: string;\n  frameworkLibrary: { [name: string]: Framework } = {};\n\n  constructor(\n    @Inject(Framework) private frameworks: any[],\n    @Inject(WidgetLibraryService) private widgetLibrary: WidgetLibraryService\n  ) {\n    this.frameworks.forEach(framework =>\n      this.frameworkLibrary[framework.name] = framework\n    );\n    this.defaultFramework = this.frameworks[0].name;\n    this.setFramework(this.defaultFramework);\n  }\n\n  public setLoadExternalAssets(loadExternalAssets = true): void {\n    this.loadExternalAssets = !!loadExternalAssets;\n  }\n\n  public setFramework(\n    framework: string|Framework = this.defaultFramework,\n    loadExternalAssets = this.loadExternalAssets\n  ): boolean {\n    this.activeFramework =\n      typeof framework === 'string' && this.hasFramework(framework) ?\n        this.frameworkLibrary[framework] :\n      typeof framework === 'object' && hasOwn(framework, 'framework') ?\n        framework :\n        this.frameworkLibrary[this.defaultFramework];\n    return this.registerFrameworkWidgets(this.activeFramework);\n  }\n\n  registerFrameworkWidgets(framework: Framework): boolean {\n    return hasOwn(framework, 'widgets') ?\n      this.widgetLibrary.registerFrameworkWidgets(framework.widgets) :\n      this.widgetLibrary.unRegisterFrameworkWidgets();\n  }\n\n  public hasFramework(type: string): boolean {\n    return hasOwn(this.frameworkLibrary, type);\n  }\n\n  public getFramework(): any {\n    if (!this.activeFramework) { this.setFramework('default', true); }\n    return this.activeFramework.framework;\n  }\n\n  public getFrameworkWidgets(): any {\n    return this.activeFramework.widgets || {};\n  }\n\n  public getFrameworkStylesheets(load: boolean = this.loadExternalAssets): string[] {\n    return (load && this.activeFramework.stylesheets) || [];\n  }\n\n  public getFrameworkScripts(load: boolean = this.loadExternalAssets): string[] {\n    return (load && this.activeFramework.scripts) || [];\n  }\n}\n",
    "import {\n  ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter,\n  forwardRef, Input, Output, OnChanges, OnInit\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';\n\nimport * as _ from 'lodash';\n\nimport { FrameworkLibraryService } from './framework-library/framework-library.service';\nimport { WidgetLibraryService } from './widget-library/widget-library.service';\nimport { JsonSchemaFormService } from './json-schema-form.service';\nimport { convertSchemaToDraft6 } from './shared/convert-schema-to-draft6.function';\nimport { resolveSchemaReferences } from './shared/json-schema.functions';\nimport {\n  hasValue, inArray, isArray, isEmpty, isNumber, isObject\n} from './shared/validator.functions';\nimport { forEach, hasOwn } from './shared/utility.functions';\nimport { JsonPointer } from './shared/jsonpointer.functions';\n\nexport const JSON_SCHEMA_FORM_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  // tslint:disable-next-line no-use-before-declare\n  useExisting: forwardRef(() => JsonSchemaFormComponent),\n  multi: true,\n};\n\n/**\n * @module 'JsonSchemaFormComponent' - Angular JSON Schema Form\n *\n * Root module of the Angular JSON Schema Form client-side library,\n * an Angular library which generates an HTML form from a JSON schema\n * structured data model and/or a JSON Schema Form layout description.\n *\n * This library also validates input data by the user, using both validators on\n * individual controls to provide real-time feedback while the user is filling\n * out the form, and then validating the entire input against the schema when\n * the form is submitted to make sure the returned JSON data object is valid.\n *\n * This library is similar to, and mostly API compatible with:\n *\n * - JSON Schema Form's Angular Schema Form library for AngularJs\n *   http://schemaform.io\n *   http://schemaform.io/examples/bootstrap-example.html (examples)\n *\n * - Mozilla's react-jsonschema-form library for React\n *   https://github.com/mozilla-services/react-jsonschema-form\n *   https://mozilla-services.github.io/react-jsonschema-form (examples)\n *\n * - Joshfire's JSON Form library for jQuery\n *   https://github.com/joshfire/jsonform\n *   http://ulion.github.io/jsonform/playground (examples)\n *\n * This library depends on:\n *  - Angular (obviously)                  https://angular.io\n *  - lodash, JavaScript utility library   https://github.com/lodash/lodash\n *  - ajv, Another JSON Schema validator   https://github.com/epoberezkin/ajv\n *\n * In addition, the Example Playground also depends on:\n *  - brace, Browserified Ace editor       http://thlorenz.github.io/brace\n */\n@Component({\n  selector: 'json-schema-form',\n  template: `\n    <div *ngFor=\"let stylesheet of stylesheets\">\n      <link rel=\"stylesheet\" [href]=\"stylesheet\">\n    </div>\n    <div *ngFor=\"let script of scripts\">\n      <script type=\"text/javascript\" [src]=\"script\"></script>\n    </div>\n    <form class=\"json-schema-form\" (ngSubmit)=\"submitForm()\">\n      <root-widget [layout]=\"jsf?.layout\"></root-widget>\n    </form>\n    <div *ngIf=\"debug || jsf?.formOptions?.debug\">\n      Debug output: <pre>{{debugOutput}}</pre>\n    </div>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  // Adding 'JsonSchemaFormService' here, instead of in the module,\n  // creates a separate instance of the service for each component\n  providers:  [ JsonSchemaFormService, JSON_SCHEMA_FORM_VALUE_ACCESSOR ],\n})\nexport class JsonSchemaFormComponent implements ControlValueAccessor, OnChanges, OnInit {\n  debugOutput: any; // Debug information, if requested\n  formValueSubscription: any = null;\n  formInitialized = false;\n  objectWrap = false; // Is non-object input schema wrapped in an object?\n\n  formValuesInput: string; // Name of the input providing the form data\n  previousInputs: { // Previous input values, to detect which input triggers onChanges\n    schema: any, layout: any[], data: any, options: any, framework: any|string,\n    widgets: any, form: any, model: any, JSONSchema: any, UISchema: any,\n    formData: any, loadExternalAssets: boolean, debug: boolean,\n  } = {\n    schema: null, layout: null, data: null, options: null, framework: null,\n    widgets: null, form: null, model: null, JSONSchema: null, UISchema: null,\n    formData: null, loadExternalAssets: null, debug: null,\n  };\n\n  // Recommended inputs\n  @Input() schema: any; // The JSON Schema\n  @Input() layout: any[]; // The form layout\n  @Input() data: any; // The form data\n  @Input() options: any; // The global form options\n  @Input() framework: any|string; // The framework to load\n  @Input() widgets: any; // Any custom widgets to load\n\n  // Alternate combined single input\n  @Input() form: any; // For testing, and JSON Schema Form API compatibility\n\n  // Angular Schema Form API compatibility input\n  @Input() model: any; // Alternate input for form data\n\n  // React JSON Schema Form API compatibility inputs\n  @Input() JSONSchema: any; // Alternate input for JSON Schema\n  @Input() UISchema: any; // UI schema - alternate form layout format\n  @Input() formData: any; // Alternate input for form data\n\n  @Input() ngModel: any; // Alternate input for Angular forms\n\n  @Input() language: string; // Language\n\n  // Development inputs, for testing and debugging\n  @Input() loadExternalAssets: boolean; // Load external framework assets?\n  @Input() debug: boolean; // Show debug information?\n\n  @Input()\n  get value(): any {\n    return this.objectWrap ? this.jsf.data['1'] : this.jsf.data;\n  }\n  set value(value: any) {\n    this.setFormValues(value, false);\n  }\n\n  // Outputs\n  // tslint:disable no-output-on-prefix\n  @Output() onChanges = new EventEmitter<any>(); // Live unvalidated internal form data\n  @Output() onSubmit = new EventEmitter<any>(); // Complete validated form data\n  // tslint:enable no-output-on-prefix\n  @Output() isValid = new EventEmitter<boolean>(); // Is current data valid?\n  @Output() validationErrors = new EventEmitter<any>(); // Validation errors (if any)\n  @Output() formSchema = new EventEmitter<any>(); // Final schema used to create form\n  @Output() formLayout = new EventEmitter<any>(); // Final layout used to create form\n\n  // Outputs for possible 2-way data binding\n  // Only the one input providing the initial form data will be bound.\n  // If there is no inital data, input '{}' to activate 2-way data binding.\n  // There is no 2-way binding if inital data is combined inside the 'form' input.\n  @Output() dataChange = new EventEmitter<any>();\n  @Output() modelChange = new EventEmitter<any>();\n  @Output() formDataChange = new EventEmitter<any>();\n  @Output() ngModelChange = new EventEmitter<any>();\n\n  onChange: Function;\n  onTouched: Function;\n\n  constructor(\n    private changeDetector: ChangeDetectorRef,\n    private frameworkLibrary: FrameworkLibraryService,\n    private widgetLibrary: WidgetLibraryService,\n    public jsf: JsonSchemaFormService,\n    private sanitizer: DomSanitizer\n  ) { }\n\n  get stylesheets(): SafeResourceUrl[] {\n    const stylesheets = this.frameworkLibrary.getFrameworkStylesheets();\n    const load = this.sanitizer.bypassSecurityTrustResourceUrl;\n    return stylesheets.map(stylesheet => load(stylesheet));\n  }\n\n  get scripts(): SafeResourceUrl[] {\n    const scripts = this.frameworkLibrary.getFrameworkScripts();\n    const load = this.sanitizer.bypassSecurityTrustResourceUrl;\n    return scripts.map(script => load(script));\n  }\n\n  ngOnInit() {\n    this.updateForm();\n  }\n\n  ngOnChanges() {\n    this.updateForm();\n  }\n\n  writeValue(value: any) {\n    this.setFormValues(value, false);\n    if (!this.formValuesInput) { this.formValuesInput = 'ngModel'; }\n  }\n\n  registerOnChange(fn: Function) {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: Function) {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean) {\n    if (this.jsf.formOptions.formDisabled !== !!isDisabled) {\n      this.jsf.formOptions.formDisabled = !!isDisabled;\n      this.initializeForm();\n    }\n  }\n\n  updateForm() {\n    if (!this.formInitialized || !this.formValuesInput ||\n      (this.language && this.language !== this.jsf.language)\n    ) {\n      this.initializeForm();\n    } else {\n      if (this.language && this.language !== this.jsf.language) {\n        this.jsf.setLanguage(this.language);\n      }\n\n      // Get names of changed inputs\n      let changedInput = Object.keys(this.previousInputs)\n        .filter(input => this.previousInputs[input] !== this[input]);\n      let resetFirst = true;\n      if (changedInput.length === 1 && changedInput[0] === 'form' &&\n        this.formValuesInput.startsWith('form.')\n      ) {\n        // If only 'form' input changed, get names of changed keys\n        changedInput = Object.keys(this.previousInputs.form || {})\n          .filter(key => !_.isEqual(this.previousInputs.form[key], this.form[key]))\n          .map(key => `form.${key}`);\n        resetFirst = false;\n      }\n\n      // If only input values have changed, update the form values\n      if (changedInput.length === 1 && changedInput[0] === this.formValuesInput) {\n        if (this.formValuesInput.indexOf('.') === -1) {\n          this.setFormValues(this[this.formValuesInput], resetFirst);\n        } else {\n          const [input, key] = this.formValuesInput.split('.');\n          this.setFormValues(this[input][key], resetFirst);\n        }\n\n      // If anything else has changed, re-render the entire form\n      } else if (changedInput.length) {\n        this.initializeForm();\n        if (this.onChange) { this.onChange(this.jsf.formValues); }\n        if (this.onTouched) { this.onTouched(this.jsf.formValues); }\n      }\n\n      // Update previous inputs\n      Object.keys(this.previousInputs)\n        .filter(input => this.previousInputs[input] !== this[input])\n        .forEach(input => this.previousInputs[input] = this[input]);\n    }\n  }\n\n  setFormValues(formValues: any, resetFirst = true) {\n    if (formValues) {\n      const newFormValues = this.objectWrap ? formValues['1'] : formValues;\n      if (!this.jsf.formGroup) {\n        this.jsf.formValues = formValues;\n        this.activateForm();\n      } else if (resetFirst) {\n        this.jsf.formGroup.reset();\n      }\n      if (this.jsf.formGroup) {\n        this.jsf.formGroup.patchValue(newFormValues);\n      }\n      if (this.onChange) { this.onChange(newFormValues); }\n      if (this.onTouched) { this.onTouched(newFormValues); }\n    } else {\n      this.jsf.formGroup.reset();\n    }\n  }\n\n  submitForm() {\n    const validData = this.jsf.validData;\n    this.onSubmit.emit(this.objectWrap ? validData['1'] : validData);\n  }\n\n  /**\n   * 'initializeForm' function\n   *\n   * - Update 'schema', 'layout', and 'formValues', from inputs.\n   *\n   * - Create 'schemaRefLibrary' and 'schemaRecursiveRefMap'\n   *   to resolve schema $ref links, including recursive $ref links.\n   *\n   * - Create 'dataRecursiveRefMap' to resolve recursive links in data\n   *   and corectly set output formats for recursively nested values.\n   *\n   * - Create 'layoutRefLibrary' and 'templateRefLibrary' to store\n   *   new layout nodes and formGroup elements to use when dynamically\n   *   adding form components to arrays and recursive $ref points.\n   *\n   * - Create 'dataMap' to map the data to the schema and template.\n   *\n   * - Create the master 'formGroupTemplate' then from it 'formGroup'\n   *   the Angular formGroup used to control the reactive form.\n   */\n  initializeForm() {\n    if (\n      this.schema || this.layout || this.data || this.form || this.model ||\n      this.JSONSchema || this.UISchema || this.formData || this.ngModel ||\n      this.jsf.data\n    ) {\n\n      this.jsf.resetAllValues();  // Reset all form values to defaults\n      this.initializeOptions();   // Update options\n      this.initializeSchema();    // Update schema, schemaRefLibrary,\n                                  // schemaRecursiveRefMap, & dataRecursiveRefMap\n      this.initializeLayout();    // Update layout, layoutRefLibrary,\n      this.initializeData();      // Update formValues\n      this.activateForm();        // Update dataMap, templateRefLibrary,\n                                  // formGroupTemplate, formGroup\n\n      // Uncomment individual lines to output debugging information to console:\n      // (These always work.)\n      // console.log('loading form...');\n      // console.log('schema', this.jsf.schema);\n      // console.log('layout', this.jsf.layout);\n      // console.log('options', this.options);\n      // console.log('formValues', this.jsf.formValues);\n      // console.log('formGroupTemplate', this.jsf.formGroupTemplate);\n      // console.log('formGroup', this.jsf.formGroup);\n      // console.log('formGroup.value', this.jsf.formGroup.value);\n      // console.log('schemaRefLibrary', this.jsf.schemaRefLibrary);\n      // console.log('layoutRefLibrary', this.jsf.layoutRefLibrary);\n      // console.log('templateRefLibrary', this.jsf.templateRefLibrary);\n      // console.log('dataMap', this.jsf.dataMap);\n      // console.log('arrayMap', this.jsf.arrayMap);\n      // console.log('schemaRecursiveRefMap', this.jsf.schemaRecursiveRefMap);\n      // console.log('dataRecursiveRefMap', this.jsf.dataRecursiveRefMap);\n\n      // Uncomment individual lines to output debugging information to browser:\n      // (These only work if the 'debug' option has also been set to 'true'.)\n      if (this.debug || this.jsf.formOptions.debug) {\n        const vars: any[] = [];\n        // vars.push(this.jsf.schema);\n        // vars.push(this.jsf.layout);\n        // vars.push(this.options);\n        // vars.push(this.jsf.formValues);\n        // vars.push(this.jsf.formGroup.value);\n        // vars.push(this.jsf.formGroupTemplate);\n        // vars.push(this.jsf.formGroup);\n        // vars.push(this.jsf.schemaRefLibrary);\n        // vars.push(this.jsf.layoutRefLibrary);\n        // vars.push(this.jsf.templateRefLibrary);\n        // vars.push(this.jsf.dataMap);\n        // vars.push(this.jsf.arrayMap);\n        // vars.push(this.jsf.schemaRecursiveRefMap);\n        // vars.push(this.jsf.dataRecursiveRefMap);\n        this.debugOutput = vars.map(v => JSON.stringify(v, null, 2)).join('\\n');\n      }\n      this.formInitialized = true;\n    }\n  }\n\n  /**\n   * 'initializeOptions' function\n   *\n   * Initialize 'options' (global form options) and set framework\n   * Combine available inputs:\n   * 1. options - recommended\n   * 2. form.options - Single input style\n   */\n  private initializeOptions() {\n    if (this.language && this.language !== this.jsf.language) {\n      this.jsf.setLanguage(this.language);\n    }\n    this.jsf.setOptions({ debug: !!this.debug });\n    let loadExternalAssets: boolean = this.loadExternalAssets || false;\n    let framework: any = this.framework || 'default';\n    if (isObject(this.options)) {\n      this.jsf.setOptions(this.options);\n      loadExternalAssets = this.options.loadExternalAssets || loadExternalAssets;\n      framework = this.options.framework || framework;\n    }\n    if (isObject(this.form) && isObject(this.form.options)) {\n      this.jsf.setOptions(this.form.options);\n      loadExternalAssets = this.form.options.loadExternalAssets || loadExternalAssets;\n      framework = this.form.options.framework || framework;\n    }\n    if (isObject(this.widgets)) {\n      this.jsf.setOptions({ widgets: this.widgets });\n    }\n    this.frameworkLibrary.setLoadExternalAssets(loadExternalAssets);\n    this.frameworkLibrary.setFramework(framework);\n    this.jsf.framework = this.frameworkLibrary.getFramework();\n    if (isObject(this.jsf.formOptions.widgets)) {\n      for (const widget of Object.keys(this.jsf.formOptions.widgets)) {\n        this.widgetLibrary.registerWidget(widget, this.jsf.formOptions.widgets[widget]);\n      }\n    }\n    if (isObject(this.form) && isObject(this.form.tpldata)) {\n      this.jsf.setTpldata(this.form.tpldata);\n    }\n  }\n\n  /**\n   * 'initializeSchema' function\n   *\n   * Initialize 'schema'\n   * Use first available input:\n   * 1. schema - recommended / Angular Schema Form style\n   * 2. form.schema - Single input / JSON Form style\n   * 3. JSONSchema - React JSON Schema Form style\n   * 4. form.JSONSchema - For testing single input React JSON Schema Forms\n   * 5. form - For testing single schema-only inputs\n   *\n   * ... if no schema input found, the 'activateForm' function, below,\n   *     will make two additional attempts to build a schema\n   * 6. If layout input - build schema from layout\n   * 7. If data input - build schema from data\n   */\n  private initializeSchema() {\n\n    // TODO: update to allow non-object schemas\n\n    if (isObject(this.schema)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.schema = _.cloneDeep(this.schema);\n    } else if (hasOwn(this.form, 'schema') && isObject(this.form.schema)) {\n      this.jsf.schema = _.cloneDeep(this.form.schema);\n    } else if (isObject(this.JSONSchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.schema = _.cloneDeep(this.JSONSchema);\n    } else if (hasOwn(this.form, 'JSONSchema') && isObject(this.form.JSONSchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.schema = _.cloneDeep(this.form.JSONSchema);\n    } else if (hasOwn(this.form, 'properties') && isObject(this.form.properties)) {\n      this.jsf.schema = _.cloneDeep(this.form);\n    } else if (isObject(this.form)) {\n      // TODO: Handle other types of form input\n    }\n\n    if (!isEmpty(this.jsf.schema)) {\n\n      // If other types also allowed, render schema as an object\n      if (inArray('object', this.jsf.schema.type)) {\n        this.jsf.schema.type = 'object';\n      }\n\n      // Wrap non-object schemas in object.\n      if (hasOwn(this.jsf.schema, 'type') && this.jsf.schema.type !== 'object') {\n        this.jsf.schema = {\n          'type': 'object',\n          'properties': { 1: this.jsf.schema }\n        };\n        this.objectWrap = true;\n      } else if (!hasOwn(this.jsf.schema, 'type')) {\n\n        // Add type = 'object' if missing\n        if (isObject(this.jsf.schema.properties) ||\n          isObject(this.jsf.schema.patternProperties) ||\n          isObject(this.jsf.schema.additionalProperties)\n        ) {\n          this.jsf.schema.type = 'object';\n\n        // Fix JSON schema shorthand (JSON Form style)\n        } else {\n          this.jsf.JsonFormCompatibility = true;\n          this.jsf.schema = {\n            'type': 'object',\n            'properties': this.jsf.schema\n          };\n        }\n      }\n\n      // If needed, update JSON Schema to draft 6 format, including\n      // draft 3 (JSON Form style) and draft 4 (Angular Schema Form style)\n      this.jsf.schema = convertSchemaToDraft6(this.jsf.schema);\n\n      // Initialize ajv and compile schema\n      this.jsf.compileAjvSchema();\n\n      // Create schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap\n      this.jsf.schema = resolveSchemaReferences(\n        this.jsf.schema, this.jsf.schemaRefLibrary, this.jsf.schemaRecursiveRefMap,\n        this.jsf.dataRecursiveRefMap, this.jsf.arrayMap\n      );\n      if (hasOwn(this.jsf.schemaRefLibrary, '')) {\n        this.jsf.hasRootReference = true;\n      }\n\n      // TODO: (?) Resolve external $ref links\n      // // Create schemaRefLibrary & schemaRecursiveRefMap\n      // this.parser.bundle(this.schema)\n      //   .then(schema => this.schema = resolveSchemaReferences(\n      //     schema, this.jsf.schemaRefLibrary,\n      //     this.jsf.schemaRecursiveRefMap, this.jsf.dataRecursiveRefMap\n      //   ));\n    }\n  }\n\n  /**\n   * 'initializeData' function\n   *\n   * Initialize 'formValues'\n   * defulat or previously submitted values used to populate form\n   * Use first available input:\n   * 1. data - recommended\n   * 2. model - Angular Schema Form style\n   * 3. form.value - JSON Form style\n   * 4. form.data - Single input style\n   * 5. formData - React JSON Schema Form style\n   * 6. form.formData - For easier testing of React JSON Schema Forms\n   * 7. (none) no data - initialize data from schema and layout defaults only\n   */\n  private initializeData() {\n    if (hasValue(this.data)) {\n      this.jsf.formValues = _.cloneDeep(this.data);\n      this.formValuesInput = 'data';\n    } else if (hasValue(this.model)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.model);\n      this.formValuesInput = 'model';\n    } else if (hasValue(this.ngModel)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.ngModel);\n      this.formValuesInput = 'ngModel';\n    } else if (isObject(this.form) && hasValue(this.form.value)) {\n      this.jsf.JsonFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.form.value);\n      this.formValuesInput = 'form.value';\n    } else if (isObject(this.form) && hasValue(this.form.data)) {\n      this.jsf.formValues = _.cloneDeep(this.form.data);\n      this.formValuesInput = 'form.data';\n    } else if (hasValue(this.formData)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.formValuesInput = 'formData';\n    } else if (hasOwn(this.form, 'formData') && hasValue(this.form.formData)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.form.formData);\n      this.formValuesInput = 'form.formData';\n    } else {\n      this.formValuesInput = null;\n    }\n  }\n\n  /**\n   * 'initializeLayout' function\n   *\n   * Initialize 'layout'\n   * Use first available array input:\n   * 1. layout - recommended\n   * 2. form - Angular Schema Form style\n   * 3. form.form - JSON Form style\n   * 4. form.layout - Single input style\n   * 5. (none) no layout - set default layout instead\n   *    (full layout will be built later from the schema)\n   *\n   * Also, if alternate layout formats are available,\n   * import from 'UISchema' or 'customFormItems'\n   * used for React JSON Schema Form and JSON Form API compatibility\n   * Use first available input:\n   * 1. UISchema - React JSON Schema Form style\n   * 2. form.UISchema - For testing single input React JSON Schema Forms\n   * 2. form.customFormItems - JSON Form style\n   * 3. (none) no input - don't import\n   */\n  private initializeLayout() {\n\n    // Rename JSON Form-style 'options' lists to\n    // Angular Schema Form-style 'titleMap' lists.\n    const fixJsonFormOptions = (layout: any): any => {\n      if (isObject(layout) || isArray(layout)) {\n        forEach(layout, (value, key) => {\n          if (hasOwn(value, 'options') && isObject(value.options)) {\n            value.titleMap = value.options;\n            delete value.options;\n          }\n        }, 'top-down');\n      }\n      return layout;\n    };\n\n    // Check for layout inputs and, if found, initialize form layout\n    if (isArray(this.layout)) {\n      this.jsf.layout = _.cloneDeep(this.layout);\n    } else if (isArray(this.form)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.layout = _.cloneDeep(this.form);\n    } else if (this.form && isArray(this.form.form)) {\n      this.jsf.JsonFormCompatibility = true;\n      this.jsf.layout = fixJsonFormOptions(_.cloneDeep(this.form.form));\n    } else if (this.form && isArray(this.form.layout)) {\n      this.jsf.layout = _.cloneDeep(this.form.layout);\n    } else {\n      this.jsf.layout = ['*'];\n    }\n\n    // Check for alternate layout inputs\n    let alternateLayout: any = null;\n    if (isObject(this.UISchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = _.cloneDeep(this.UISchema);\n    } else if (hasOwn(this.form, 'UISchema')) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = _.cloneDeep(this.form.UISchema);\n    } else if (hasOwn(this.form, 'uiSchema')) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = _.cloneDeep(this.form.uiSchema);\n    } else if (hasOwn(this.form, 'customFormItems')) {\n      this.jsf.JsonFormCompatibility = true;\n      alternateLayout = fixJsonFormOptions(_.cloneDeep(this.form.customFormItems));\n    }\n\n    // if alternate layout found, copy alternate layout options into schema\n    if (alternateLayout) {\n      JsonPointer.forEachDeep(alternateLayout, (value, pointer) => {\n        const schemaPointer = pointer\n          .replace(/\\//g, '/properties/')\n          .replace(/\\/properties\\/items\\/properties\\//g, '/items/properties/')\n          .replace(/\\/properties\\/titleMap\\/properties\\//g, '/titleMap/properties/');\n        if (hasValue(value) && hasValue(pointer)) {\n          let key = JsonPointer.toKey(pointer);\n          const groupPointer = (JsonPointer.parse(schemaPointer) || []).slice(0, -2);\n          let itemPointer: string | string[];\n\n          // If 'ui:order' object found, copy into object schema root\n          if (key.toLowerCase() === 'ui:order') {\n            itemPointer = [...groupPointer, 'ui:order'];\n\n          // Copy other alternate layout options to schema 'x-schema-form',\n          // (like Angular Schema Form options) and remove any 'ui:' prefixes\n          } else {\n            if (key.slice(0, 3).toLowerCase() === 'ui:') { key = key.slice(3); }\n            itemPointer = [...groupPointer, 'x-schema-form', key];\n          }\n          if (JsonPointer.has(this.jsf.schema, groupPointer) &&\n            !JsonPointer.has(this.jsf.schema, itemPointer)\n          ) {\n            JsonPointer.set(this.jsf.schema, itemPointer, value);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * 'activateForm' function\n   *\n   * ...continued from 'initializeSchema' function, above\n   * If 'schema' has not been initialized (i.e. no schema input found)\n   * 6. If layout input - build schema from layout input\n   * 7. If data input - build schema from data input\n   *\n   * Create final layout,\n   * build the FormGroup template and the Angular FormGroup,\n   * subscribe to changes,\n   * and activate the form.\n   */\n  private activateForm() {\n\n    // If 'schema' not initialized\n    if (isEmpty(this.jsf.schema)) {\n\n      // TODO: If full layout input (with no '*'), build schema from layout\n      // if (!this.jsf.layout.includes('*')) {\n      //   this.jsf.buildSchemaFromLayout();\n      // } else\n\n      // If data input, build schema from data\n      if (!isEmpty(this.jsf.formValues)) {\n        this.jsf.buildSchemaFromData();\n      }\n    }\n\n    if (!isEmpty(this.jsf.schema)) {\n\n      // If not already initialized, initialize ajv and compile schema\n      this.jsf.compileAjvSchema();\n\n      // Update all layout elements, add values, widgets, and validators,\n      // replace any '*' with a layout built from all schema elements,\n      // and update the FormGroup template with any new validators\n      this.jsf.buildLayout(this.widgetLibrary);\n\n      // Build the Angular FormGroup template from the schema\n      this.jsf.buildFormGroupTemplate(this.jsf.formValues);\n\n      // Build the real Angular FormGroup from the FormGroup template\n      this.jsf.buildFormGroup();\n    }\n\n    if (this.jsf.formGroup) {\n\n      // Reset initial form values\n      if (!isEmpty(this.jsf.formValues) &&\n        this.jsf.formOptions.setSchemaDefaults !== true &&\n        this.jsf.formOptions.setLayoutDefaults !== true\n      ) {\n        this.setFormValues(this.jsf.formValues);\n      }\n\n      // TODO: Figure out how to display calculated values without changing object data\n      // See http://ulion.github.io/jsonform/playground/?example=templating-values\n      // Calculate references to other fields\n      // if (!isEmpty(this.jsf.formGroup.value)) {\n      //   forEach(this.jsf.formGroup.value, (value, key, object, rootObject) => {\n      //     if (typeof value === 'string') {\n      //       object[key] = this.jsf.parseText(value, value, rootObject, key);\n      //     }\n      //   }, 'top-down');\n      // }\n\n      // Subscribe to form changes to output live data, validation, and errors\n      this.jsf.dataChanges.subscribe(data => {\n        this.onChanges.emit(this.objectWrap ? data['1'] : data);\n        if (this.formValuesInput && this.formValuesInput.indexOf('.') === -1) {\n          this[`${this.formValuesInput}Change`].emit(this.objectWrap ? data['1'] : data);\n        }\n      });\n\n      // Trigger change detection on statusChanges to show updated errors\n      this.jsf.formGroup.statusChanges.subscribe(() => this.changeDetector.markForCheck());\n      this.jsf.isValidChanges.subscribe(isValid => this.isValid.emit(isValid));\n      this.jsf.validationErrorChanges.subscribe(err => this.validationErrors.emit(err));\n\n      // Output final schema, final layout, and initial data\n      this.formSchema.emit(this.jsf.schema);\n      this.formLayout.emit(this.jsf.layout);\n      this.onChanges.emit(this.objectWrap ? this.jsf.data['1'] : this.jsf.data);\n\n      // If validateOnRender, output initial validation and any errors\n      const validateOnRender =\n        JsonPointer.get(this.jsf, '/formOptions/validateOnRender');\n      if (validateOnRender) { // validateOnRender === 'auto' || true\n        const touchAll = (control) => {\n          if (validateOnRender === true || hasValue(control.value)) {\n            control.markAsTouched();\n          }\n          Object.keys(control.controls || {})\n            .forEach(key => touchAll(control.controls[key]));\n        };\n        touchAll(this.jsf.formGroup);\n        this.isValid.emit(this.jsf.isValid);\n        this.validationErrors.emit(this.jsf.ajvErrors);\n      }\n    }\n  }\n}\n",
    "import * as _ from 'lodash';\n\n/**\n * 'convertSchemaToDraft6' function\n *\n * Converts a JSON Schema from draft 1 through 4 format to draft 6 format\n *\n * Inspired by on geraintluff's JSON Schema 3 to 4 compatibility function:\n *   https://github.com/geraintluff/json-schema-compatibility\n * Also uses suggestions from AJV's JSON Schema 4 to 6 migration guide:\n *   https://github.com/epoberezkin/ajv/releases/tag/5.0.0\n * And additional details from the official JSON Schema documentation:\n *   http://json-schema.org\n *\n * @param  { object } originalSchema - JSON schema (draft 1, 2, 3, 4, or 6)\n * @param  { OptionObject = {} } options - options: parent schema changed?, schema draft number?\n * @return { object } - JSON schema (draft 6)\n */\nexport interface OptionObject { changed?: boolean; draft?: number; }\nexport function convertSchemaToDraft6(schema, options: OptionObject = {}) {\n  let draft: number = options.draft || null;\n  let changed: boolean = options.changed || false;\n\n  if (typeof schema !== 'object') { return schema; }\n  if (typeof schema.map === 'function') {\n    return [ ...schema.map(subSchema => convertSchemaToDraft6(subSchema, { changed, draft })) ];\n  }\n  let newSchema = { ...schema };\n  const simpleTypes = ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'];\n\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0\\d\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    draft = newSchema.$schema[30];\n  }\n\n  // Convert v1-v2 'contentEncoding' to 'media.binaryEncoding'\n  // Note: This is only used in JSON hyper-schema (not regular JSON schema)\n  if (newSchema.contentEncoding) {\n    newSchema.media = { binaryEncoding: newSchema.contentEncoding };\n    delete newSchema.contentEncoding;\n    changed = true;\n  }\n\n  // Convert v1-v3 'extends' to 'allOf'\n  if (typeof newSchema.extends === 'object') {\n    newSchema.allOf = typeof newSchema.extends.map === 'function' ?\n      newSchema.extends.map(subSchema => convertSchemaToDraft6(subSchema, { changed, draft })) :\n      [ convertSchemaToDraft6(newSchema.extends, { changed, draft }) ];\n    delete newSchema.extends;\n    changed = true;\n  }\n\n  // Convert v1-v3 'disallow' to 'not'\n  if (newSchema.disallow) {\n    if (typeof newSchema.disallow === 'string') {\n      newSchema.not = { type: newSchema.disallow };\n    } else if (typeof newSchema.disallow.map === 'function') {\n      newSchema.not = {\n        anyOf: newSchema.disallow\n          .map(type => typeof type === 'object' ? type : { type })\n      };\n    }\n    delete newSchema.disallow;\n    changed = true;\n  }\n\n  // Convert v3 string 'dependencies' properties to arrays\n  if (typeof newSchema.dependencies === 'object' &&\n    Object.keys(newSchema.dependencies)\n      .some(key => typeof newSchema.dependencies[key] === 'string')\n  ) {\n    newSchema.dependencies = { ...newSchema.dependencies };\n    Object.keys(newSchema.dependencies)\n      .filter(key => typeof newSchema.dependencies[key] === 'string')\n      .forEach(key => newSchema.dependencies[key] = [ newSchema.dependencies[key] ]);\n    changed = true;\n  }\n\n  // Convert v1 'maxDecimal' to 'multipleOf'\n  if (typeof newSchema.maxDecimal === 'number') {\n    newSchema.multipleOf = 1 / Math.pow(10, newSchema.maxDecimal);\n    delete newSchema.divisibleBy;\n    changed = true;\n    if (!draft || draft === 2) { draft = 1; }\n  }\n\n  // Convert v2-v3 'divisibleBy' to 'multipleOf'\n  if (typeof newSchema.divisibleBy === 'number') {\n    newSchema.multipleOf = newSchema.divisibleBy;\n    delete newSchema.divisibleBy;\n    changed = true;\n  }\n\n  // Convert v1-v2 boolean 'minimumCanEqual' to 'exclusiveMinimum'\n  if (typeof newSchema.minimum === 'number' && newSchema.minimumCanEqual === false) {\n    newSchema.exclusiveMinimum = newSchema.minimum;\n    delete newSchema.minimum;\n    changed = true;\n    if (!draft) { draft = 2; }\n  } else if (typeof newSchema.minimumCanEqual === 'boolean') {\n    delete newSchema.minimumCanEqual;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMinimum' to numeric\n  if (typeof newSchema.minimum === 'number' && newSchema.exclusiveMinimum === true) {\n    newSchema.exclusiveMinimum = newSchema.minimum;\n    delete newSchema.minimum;\n    changed = true;\n  } else if (typeof newSchema.exclusiveMinimum === 'boolean') {\n    delete newSchema.exclusiveMinimum;\n    changed = true;\n  }\n\n  // Convert v1-v2 boolean 'maximumCanEqual' to 'exclusiveMaximum'\n  if (typeof newSchema.maximum === 'number' && newSchema.maximumCanEqual === false) {\n    newSchema.exclusiveMaximum = newSchema.maximum;\n    delete newSchema.maximum;\n    changed = true;\n    if (!draft) { draft = 2; }\n  } else if (typeof newSchema.maximumCanEqual === 'boolean') {\n    delete newSchema.maximumCanEqual;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMaximum' to numeric\n  if (typeof newSchema.maximum === 'number' && newSchema.exclusiveMaximum === true) {\n    newSchema.exclusiveMaximum = newSchema.maximum;\n    delete newSchema.maximum;\n    changed = true;\n  } else if (typeof newSchema.exclusiveMaximum === 'boolean') {\n    delete newSchema.exclusiveMaximum;\n    changed = true;\n  }\n\n  // Search object 'properties' for 'optional', 'required', and 'requires' items,\n  // and convert them into object 'required' arrays and 'dependencies' objects\n  if (typeof newSchema.properties === 'object') {\n    const properties = { ...newSchema.properties };\n    const requiredKeys = Array.isArray(newSchema.required) ?\n      new Set(newSchema.required) : new Set();\n\n    // Convert v1-v2 boolean 'optional' properties to 'required' array\n    if (draft === 1 || draft === 2 ||\n      Object.keys(properties).some(key => properties[key].optional === true)\n    ) {\n      Object.keys(properties)\n        .filter(key => properties[key].optional !== true)\n        .forEach(key => requiredKeys.add(key));\n      changed = true;\n      if (!draft) { draft = 2; }\n    }\n\n    // Convert v3 boolean 'required' properties to 'required' array\n    if (Object.keys(properties).some(key => properties[key].required === true)) {\n      Object.keys(properties)\n        .filter(key => properties[key].required === true)\n        .forEach(key => requiredKeys.add(key));\n      changed = true;\n    }\n\n    if (requiredKeys.size) { newSchema.required = Array.from(requiredKeys); }\n\n    // Convert v1-v2 array or string 'requires' properties to 'dependencies' object\n    if (Object.keys(properties).some(key => properties[key].requires)) {\n      const dependencies = typeof newSchema.dependencies === 'object' ?\n        { ...newSchema.dependencies } : {};\n      Object.keys(properties)\n        .filter(key => properties[key].requires)\n        .forEach(key => dependencies[key] =\n          typeof properties[key].requires === 'string' ?\n            [ properties[key].requires ] : properties[key].requires\n        );\n      newSchema.dependencies = dependencies;\n      changed = true;\n      if (!draft) { draft = 2; }\n    }\n\n    newSchema.properties = properties;\n  }\n\n  // Revove v1-v2 boolean 'optional' key\n  if (typeof newSchema.optional === 'boolean') {\n    delete newSchema.optional;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Revove v1-v2 'requires' key\n  if (newSchema.requires) {\n    delete newSchema.requires;\n  }\n\n  // Revove v3 boolean 'required' key\n  if (typeof newSchema.required === 'boolean') {\n    delete newSchema.required;\n  }\n\n  // Convert id to $id\n  if (typeof newSchema.id === 'string' && !newSchema.$id) {\n    if (newSchema.id.slice(-1) === '#') {\n      newSchema.id = newSchema.id.slice(0, -1);\n    }\n    newSchema.$id = newSchema.id + '-CONVERTED-TO-DRAFT-06#';\n    delete newSchema.id;\n    changed = true;\n  }\n\n  // Check if v1-v3 'any' or object types will be converted\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n    !newSchema.type.every(type => simpleTypes.includes(type)) :\n    !simpleTypes.includes(newSchema.type)\n  )) {\n    changed = true;\n  }\n\n  // If schema changed, update or remove $schema identifier\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0[1-4]\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    newSchema.$schema = 'http://json-schema.org/draft-06/schema#';\n    changed = true;\n  } else if (changed && typeof newSchema.$schema === 'string') {\n    const addToDescription = 'Converted to draft 6 from ' + newSchema.$schema;\n    if (typeof newSchema.description === 'string' && newSchema.description.length) {\n      newSchema.description += '\\n' + addToDescription;\n    } else {\n      newSchema.description = addToDescription;\n    }\n    delete newSchema.$schema;\n  }\n\n  // Convert v1-v3 'any' and object types\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n    !newSchema.type.every(type => simpleTypes.includes(type)) :\n    !simpleTypes.includes(newSchema.type)\n  )) {\n    if (newSchema.type.length === 1) { newSchema.type = newSchema.type[0]; }\n    if (typeof newSchema.type === 'string') {\n      // Convert string 'any' type to array of all standard types\n      if (newSchema.type === 'any') {\n        newSchema.type = simpleTypes;\n      // Delete non-standard string type\n      } else {\n        delete newSchema.type;\n      }\n    } else if (typeof newSchema.type === 'object') {\n      if (typeof newSchema.type.every === 'function') {\n        // If array of strings, only allow standard types\n        if (newSchema.type.every(type => typeof type === 'string')) {\n          newSchema.type = newSchema.type.some(type => type === 'any') ?\n            newSchema.type = simpleTypes :\n            newSchema.type.filter(type => simpleTypes.includes(type));\n        // If type is an array with objects, convert the current schema to an 'anyOf' array\n        } else if (newSchema.type.length > 1) {\n          const arrayKeys = [ 'additionalItems', 'items', 'maxItems', 'minItems', 'uniqueItems', 'contains'];\n          const numberKeys = [ 'multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum'];\n          const objectKeys = [ 'maxProperties', 'minProperties', 'required', 'additionalProperties',\n            'properties', 'patternProperties', 'dependencies', 'propertyNames'];\n          const stringKeys = [ 'maxLength', 'minLength', 'pattern', 'format'];\n          const filterKeys = {\n            'array':   [ ...numberKeys, ...objectKeys, ...stringKeys ],\n            'integer': [  ...arrayKeys, ...objectKeys, ...stringKeys ],\n            'number':  [  ...arrayKeys, ...objectKeys, ...stringKeys ],\n            'object':  [  ...arrayKeys, ...numberKeys, ...stringKeys ],\n            'string':  [  ...arrayKeys, ...numberKeys, ...objectKeys ],\n            'all':     [  ...arrayKeys, ...numberKeys, ...objectKeys, ...stringKeys ],\n          };\n          const anyOf = [];\n          for (const type of newSchema.type) {\n            const newType = typeof type === 'string' ? { type } : { ...type };\n            Object.keys(newSchema)\n              .filter(key => !newType.hasOwnProperty(key) &&\n                ![ ...(filterKeys[newType.type] || filterKeys.all), 'type', 'default' ]\n                  .includes(key)\n              )\n              .forEach(key => newType[key] = newSchema[key]);\n            anyOf.push(newType);\n          }\n          newSchema = newSchema.hasOwnProperty('default') ?\n            { anyOf, default: newSchema.default } : { anyOf };\n        // If type is an object, merge it with the current schema\n        } else {\n          const typeSchema = newSchema.type;\n          delete newSchema.type;\n          Object.assign(newSchema, typeSchema);\n        }\n      }\n    } else {\n      delete newSchema.type;\n    }\n  }\n\n  // Convert sub schemas\n  Object.keys(newSchema)\n    .filter(key => typeof newSchema[key] === 'object')\n    .forEach(key => {\n      if (\n        [ 'definitions', 'dependencies', 'properties', 'patternProperties' ]\n          .includes(key) && typeof newSchema[key].map !== 'function'\n      ) {\n        const newKey = {};\n        Object.keys(newSchema[key]).forEach(subKey => newKey[subKey] =\n          convertSchemaToDraft6(newSchema[key][subKey], { changed, draft })\n        );\n        newSchema[key] = newKey;\n      } else if (\n        [ 'items', 'additionalItems', 'additionalProperties',\n          'allOf', 'anyOf', 'oneOf', 'not' ].includes(key)\n      ) {\n        newSchema[key] = convertSchemaToDraft6(newSchema[key], { changed, draft });\n      } else {\n        newSchema[key] = _.cloneDeep(newSchema[key]);\n      }\n    });\n\n  return newSchema;\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'hidden-widget',\n  template: `\n    <input *ngIf=\"boundControl\"\n      [formControl]=\"formControl\"\n      [id]=\"'control' + layoutNode?._id\"\n      [name]=\"controlName\"\n      type=\"hidden\">\n    <input *ngIf=\"!boundControl\"\n      [disabled]=\"controlDisabled\"\n      [name]=\"controlName\"\n      [id]=\"'control' + layoutNode?._id\"\n      type=\"hidden\"\n      [value]=\"controlValue\">`,\n})\nexport class HiddenComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.jsf.initializeControl(this);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'tab-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <root-widget\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [layout]=\"layoutNode.items\"></root-widget>\n    </div>`,\n})\nexport class TabComponent implements OnInit {\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n  }\n}\n",
    "import { AddReferenceComponent } from './add-reference.component';\nimport { OneOfComponent } from './one-of.component';\nimport { ButtonComponent } from './button.component';\nimport { CheckboxComponent } from './checkbox.component';\nimport { CheckboxesComponent } from './checkboxes.component';\nimport { FileComponent } from './file.component';\nimport { HiddenComponent } from './hidden.component';\nimport { InputComponent } from './input.component';\nimport { MessageComponent } from './message.component';\nimport { NoneComponent } from './none.component';\nimport { NumberComponent } from './number.component';\nimport { RadiosComponent } from './radios.component';\nimport { RootComponent } from './root.component';\nimport { SectionComponent } from './section.component';\nimport { SelectComponent } from './select.component';\nimport { SelectFrameworkComponent } from './select-framework.component';\nimport { SelectWidgetComponent } from './select-widget.component';\nimport { SubmitComponent } from './submit.component';\nimport { TabComponent } from './tab.component';\nimport { TabsComponent } from './tabs.component';\nimport { TemplateComponent } from './template.component';\nimport { TextareaComponent } from './textarea.component';\n\nexport const BASIC_WIDGETS = [\n  AddReferenceComponent, OneOfComponent, ButtonComponent, CheckboxComponent,\n  CheckboxesComponent, FileComponent, HiddenComponent, InputComponent,\n  MessageComponent, NoneComponent, NumberComponent, RadiosComponent,\n  RootComponent, SectionComponent, SelectComponent, SelectFrameworkComponent,\n  SelectWidgetComponent, SubmitComponent, TabComponent, TabsComponent,\n  TemplateComponent, TextareaComponent\n];\n\nexport { AddReferenceComponent } from './add-reference.component';\nexport { OneOfComponent } from './one-of.component';\nexport { ButtonComponent } from './button.component';\nexport { CheckboxComponent } from './checkbox.component';\nexport { CheckboxesComponent } from './checkboxes.component';\nexport { FileComponent } from './file.component';\nexport { HiddenComponent } from './hidden.component';\nexport { InputComponent } from './input.component';\nexport { MessageComponent } from './message.component';\nexport { NoneComponent } from './none.component';\nexport { NumberComponent } from './number.component';\nexport { RadiosComponent } from './radios.component';\nexport { RootComponent } from './root.component';\nexport { SectionComponent } from './section.component';\nexport { SelectComponent } from './select.component';\nexport { SelectFrameworkComponent } from './select-framework.component';\nexport { SelectWidgetComponent } from './select-widget.component';\nexport { SubmitComponent } from './submit.component';\nexport { TabComponent } from './tab.component';\nexport { TabsComponent } from './tabs.component';\nexport { TemplateComponent } from './template.component';\nexport { TextareaComponent } from './textarea.component';\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\nimport { OrderableDirective } from '../shared/orderable.directive';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\nimport { BASIC_WIDGETS } from './index';\n\n@NgModule({\n  imports:         [ CommonModule, FormsModule, ReactiveFormsModule ],\n  declarations:    [ ...BASIC_WIDGETS, OrderableDirective ],\n  exports:         [ ...BASIC_WIDGETS, OrderableDirective ],\n  entryComponents: [ ...BASIC_WIDGETS ],\n  providers:       [ JsonSchemaFormService ]\n})\nexport class WidgetLibraryModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: WidgetLibraryModule,\n      providers: [ JsonSchemaFormService ]\n    };\n  }\n}\n",
    "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'no-framework',\n  template: `\n    <select-widget-widget\n      [dataIndex]=\"dataIndex\"\n      [layoutIndex]=\"layoutIndex\"\n      [layoutNode]=\"layoutNode\"></select-widget-widget>`,\n})\nexport class NoFrameworkComponent {\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { Framework } from '../framework';\n\n// No framework - plain HTML controls (styles from form layout only)\nimport { NoFrameworkComponent } from './no-framework.component';\n\n@Injectable()\nexport class NoFramework extends Framework {\n  name = 'no-framework';\n\n  framework = NoFrameworkComponent;\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { WidgetLibraryModule } from '../../widget-library/widget-library.module';\nimport { Framework } from '../framework';\n// No framework - plain HTML controls (styles from form layout only)\nimport { NoFrameworkComponent } from './no-framework.component';\nimport { NoFramework } from './no.framework';\n\n@NgModule({\n  imports:         [ CommonModule, WidgetLibraryModule ],\n  declarations:    [ NoFrameworkComponent ],\n  exports:         [ NoFrameworkComponent ],\n  entryComponents: [ NoFrameworkComponent ]\n})\nexport class NoFrameworkModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: NoFrameworkModule,\n      providers: [\n        { provide: Framework, useClass: NoFramework, multi: true }\n      ]\n    };\n  }\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\nimport { FrameworkLibraryService } from './framework-library/framework-library.service';\nimport { WidgetLibraryModule } from './widget-library/widget-library.module';\nimport { WidgetLibraryService } from './widget-library/widget-library.service';\n\nimport { JsonSchemaFormComponent } from './json-schema-form.component';\n\nimport { JsonSchemaFormService } from './json-schema-form.service';\n\nimport { NoFrameworkComponent } from './framework-library/no-framework/no-framework.component';\nimport { Framework } from './framework-library/framework';\nimport { NoFramework } from './framework-library/no-framework/no.framework';\nimport { NoFrameworkModule } from './framework-library/no-framework/no-framework.module';\n\n@NgModule({\n  imports: [\n    CommonModule, FormsModule, ReactiveFormsModule,\n    WidgetLibraryModule, NoFrameworkModule\n  ],\n  declarations: [ JsonSchemaFormComponent ],\n  exports: [ JsonSchemaFormComponent, WidgetLibraryModule ]\n})\nexport class JsonSchemaFormModule {\n  static forRoot(...frameworks): ModuleWithProviders {\n    const loadFrameworks = frameworks.length ?\n      frameworks.map(framework => framework.forRoot().providers[0]) :\n      [{ provide: Framework, useClass: NoFramework, multi: true }];\n    return {\n      ngModule: JsonSchemaFormModule,\n      providers: [\n        JsonSchemaFormService, FrameworkLibraryService, WidgetLibraryService,\n        ...loadFrameworks\n      ]\n    };\n  }\n}\n"
  ],
  "names": [
    "_executeValidators",
    "control",
    "validators",
    "invert",
    "_mergeObjects",
    "objects",
    "_i",
    "arguments",
    "length",
    "mergedObject",
    "objects_1",
    "tslib_1.__values",
    "objects_1_1",
    "next",
    "done",
    "currentObject",
    "value",
    "isObject",
    "_a",
    "Object",
    "keys",
    "_b",
    "key",
    "currentValue",
    "mergedValue",
    "_c",
    "return",
    "call",
    "e_2",
    "error",
    "_mergeErrors",
    "arrayOfErrors",
    "mergedErrors",
    "apply",
    "tslib_1.__spread",
    "isEmpty",
    "isDefined",
    "undefined",
    "hasValue",
    "isArray",
    "isString",
    "isNaN",
    "isInteger",
    "strict",
    "isBoolean",
    "option",
    "isNumber",
    "toJavaScriptType",
    "types",
    "strictIntegers",
    "inArray",
    "parseInt",
    "object",
    "then",
    "copy",
    "errors",
    "isMap",
    "Map",
    "isSet",
    "Set",
    "assign",
    "console",
    "forEach",
    "fn",
    "recurse",
    "rootObject",
    "e_1_1",
    "e_1",
    "forEachCopy",
    "newObject",
    "has",
    "property",
    "hasOwnProperty",
    "mergeFilteredObject",
    "targetObject",
    "sourceObject",
    "excludeKeys",
    "keyFn",
    "valFn",
    "val",
    "e_3_1",
    "e_3",
    "e_4",
    "items_1_1",
    "items_1",
    "returnItems",
    "commonItems",
    "arrays",
    "e_5",
    "_loop_1",
    "array",
    "filter",
    "item",
    "includes",
    "arrays_1",
    "arrays_1_1",
    "state_1",
    "e_5_1",
    "JsonPointer",
    "get",
    "pointer",
    "startSlice",
    "endSlice",
    "getBoolean",
    "keyArray",
    "this",
    "parse",
    "subObject",
    "slice",
    "keyArray_1",
    "keyArray_1_1",
    "hasOwn",
    "getCopy",
    "objectToCopy",
    "forEachDeepCopy",
    "getFirst",
    "items",
    "defaultValue",
    "items_2_1",
    "items_2",
    "getFirstCopy",
    "i",
    "match",
    "lastKey",
    "push",
    "insert",
    "splice",
    "set",
    "remove",
    "dict",
    "results",
    "forEachDeep",
    "bottomUp",
    "v",
    "newPointer",
    "escape",
    "toString",
    "replace",
    "split",
    "map",
    "unescape",
    "compile",
    "_this",
    "isJsonPointer",
    "toKey",
    "isSubPointer",
    "shortPointer",
    "longPointer",
    "trueIfMatching",
    "invalid",
    "toIndexedPointer",
    "genericPointer",
    "indexArray",
    "arrayMap",
    "indexedPointer_1",
    "arrayIndex_1",
    "stringIndex",
    "indexArray_1",
    "indexArray_1_1",
    "pointerIndex",
    "e_6_1",
    "e_6",
    "toGenericPointer",
    "indexedPointer",
    "pointerArray",
    "subPointer",
    "e_7",
    "controlPointerArray",
    "subGroup",
    "controlMustExist",
    "dataPointer",
    "formGroup",
    "controls",
    "e_7_1",
    "dataPointerArray_1_1",
    "dataPointerArray_1",
    "toSchemaPointer",
    "schema",
    "type",
    "firstKey",
    "arrayItem",
    "additionalItems",
    "toDataPointer",
    "schemaPointer",
    "shift",
    "pointerSuffix",
    "secondKey",
    "mergeSchemas",
    "schemas",
    "some",
    "combinedSchema",
    "schemas_1",
    "schemas_1_1",
    "x",
    "y",
    "combinedValue",
    "_.isEqual",
    "schemaValue",
    "allOf",
    "item1",
    "findIndex",
    "item2",
    "combinedObject",
    "subKey",
    "_d",
    "_e",
    "uniqueItems",
    "required",
    "combinedDependency",
    "schemaDependency",
    "e_2_1",
    "_f",
    "dependencies",
    "multipleOf",
    "gcd_1",
    "Math",
    "min",
    "max",
    "notAnyOf",
    "reduce",
    "notAnyOfArray",
    "notSchema",
    "anyOf",
    "not",
    "_g",
    "_h",
    "patternProperties",
    "combinedObject_1",
    "combinedKey",
    "nonMatchingKey",
    "additionalProperties",
    "_k",
    "_l",
    "e_4_1",
    "_m",
    "properties",
    "buildSchemaFromData",
    "data",
    "requireAllFields",
    "isRoot",
    "newSchema",
    "getFieldType",
    "fieldType",
    "getType",
    "integer",
    "null",
    "buildSubSchema",
    "$schema",
    "removeRecursiveReferences",
    "recursiveRefMap",
    "indexOf",
    "fromPointer",
    "layoutNode",
    "controlType",
    "checkInlineType",
    "schemaType",
    "maxItems",
    "getTitleMapFromOneOf",
    "color",
    "date",
    "date-time",
    "email",
    "isInputRequired",
    "listPointerArray",
    "parentSchema",
    "keyName",
    "minItems",
    "updateInputOptions",
    "jsf",
    "options",
    "newOptions",
    "fixUiKeys",
    "toLowerCase",
    "formOptions",
    "defautWidgetOptions",
    "tslib_1.__read",
    "newTitleMap",
    "flatList",
    "titleMap",
    "enum",
    "enumNames",
    "typeahead",
    "autocomplete",
    "tagsinput",
    "validateOnly",
    "oneOf",
    "every",
    "title",
    "name",
    "newTitleMap_1",
    "group",
    "index",
    "getSubSchema",
    "schemaRefLibrary",
    "schemaRecursiveRefMap",
    "usedPointers",
    "_.cloneDeep",
    "refSchema",
    "extraKeys",
    "subSchema",
    "$ref",
    "combineAllOf",
    "jsonSchemaFormatTests",
    "time",
    "hostname",
    "ipv4",
    "ipv6",
    "uri",
    "uri-reference",
    "uri-template",
    "url",
    "uuid",
    "json-pointer",
    "relative-json-pointer",
    "regex",
    "str",
    "test",
    "e",
    "JsonValidators",
    "input",
    "nullValidator",
    "requiredType",
    "isType",
    "allowedValues",
    "isEqual",
    "enumValue",
    "inputValue",
    "const",
    "requiredValue",
    "constValue",
    "minLength",
    "minimumLength",
    "maxLength",
    "maximumLength",
    "pattern",
    "wholeString",
    "requiredPattern",
    "RegExp",
    "format",
    "requiredFormat",
    "isValid",
    "formatTest",
    "minimum",
    "minimumValue",
    "exclusiveMinimum",
    "exclusiveMinimumValue",
    "maximum",
    "maximumValue",
    "xor",
    "exclusiveMaximumValue",
    "exclusiveMaximum",
    "multipleOfValue",
    "currentProperties",
    "minimumProperties",
    "minProperties",
    "maximumProperties",
    "maxProperties",
    "requiringField",
    "requiredFields",
    "requiringFieldErrors",
    "requiredFields_1",
    "requiredFields_1_1",
    "requiredField",
    "requirements",
    "requiredFieldErrors",
    "requirement",
    "parameter",
    "validator",
    "exclusive",
    "minimumItems",
    "currentItems",
    "maximumItems",
    "unique",
    "sorted",
    "sort",
    "duplicateItems",
    "contains",
    "requiredItem",
    "composeAnyOf",
    "presentValidators",
    "composeOneOf",
    "composeAllOf",
    "combinedErrors",
    "composeNot",
    "compose",
    "composeAsync",
    "parseFloat",
    "buildFormGroupTemplate",
    "nodeValue",
    "setValues",
    "templatePointer",
    "setSchemaDefaults",
    "formValues",
    "shortDataPointer",
    "dataRecursiveRefMap",
    "dataMap",
    "nodeOptions",
    "prop",
    "ucLimit",
    "eLimit",
    "limit",
    "getControlValidators",
    "propertyKeys_1",
    "unnamedKeys",
    "fieldsRequired",
    "formControlTemplate",
    "requiredArray",
    "setRequiredFields",
    "additionalItemsPointer",
    "tupleItems",
    "schemaRefPointer",
    "itemRecursive",
    "itemRefPointer",
    "templateRefLibrary",
    "itemOptions",
    "arrayLength",
    "schemaRef",
    "refPointer",
    "newTemplate",
    "disabled",
    "buildFormGroup",
    "template",
    "validatorFns",
    "validatorFn",
    "parameters",
    "groupControls_1",
    "newControl",
    "FormGroup",
    "FormArray",
    "_.filter",
    "_.map",
    "formatFormData",
    "formData",
    "returnEmptyFields",
    "fixErrors",
    "formattedData",
    "isDate",
    "genericPointer_1",
    "newValue",
    "testValue",
    "toSchemaType",
    "getControl",
    "returnGroup",
    "formControl",
    "buildLayout",
    "widgetLibrary",
    "hasSubmitButton",
    "formLayout",
    "mapLayout",
    "layout",
    "layoutPointer",
    "rootLayout",
    "indexPad",
    "newLayout",
    "realIndex",
    "newLayoutPointer",
    "newNode",
    "itemsArray",
    "tabs",
    "concat",
    "layoutItem",
    "_id",
    "_.uniqueId",
    "widget",
    "legend",
    "validationMessages",
    "errorMessages",
    "validationMessage",
    "code",
    "newKey",
    "parseObjectPath",
    "findDataPointer_1",
    "searchItem",
    "childDataPointer",
    "lastIndexOf",
    "buildLayoutFromSchema",
    "LastKey",
    "recursive_1",
    "nodeDataMap",
    "nodeSchema",
    "hasWidget",
    "oldWidgetType",
    "getInputType",
    "dataType",
    "listItems",
    "fixTitle",
    "copyValueTo",
    "getWidget",
    "itemRefPointer_1",
    "arrayItemGroup",
    "subItem",
    "unshift",
    "arrayItemType",
    "removable",
    "orderable",
    "arrayListItems",
    "layoutRefLibrary",
    "recursiveReference",
    "getLayoutNode",
    "addable",
    "buttonText",
    "returnType",
    "dataPointerArray",
    "subSchemaFound",
    "getFromSchema",
    "fieldStyle",
    "style",
    "add",
    "parentType",
    "hasRootReference",
    "fullLayout",
    "pop",
    "forRefLibrary",
    "dataPointerPrefix",
    "newNodeType",
    "lastDataKey",
    "newSection_1",
    "innerItem",
    "keySchemaPointer",
    "additionalItemsSchemaPointer",
    "newItem",
    "itemSchemaPointer",
    "prefix",
    "dataRef",
    "refNode",
    "newLayoutNode",
    "subNode",
    "buildTitleMap",
    "enumList",
    "fieldRequired",
    "hasEmptyValue",
    "name_1",
    "name_2",
    "name_3",
    "name_4",
    "_j",
    "name_5",
    "enValidationMessages",
    "log10",
    "frValidationMessages",
    "JsonSchemaFormService",
    "JsonFormCompatibility",
    "ReactJsonSchemaFormCompatibility",
    "AngularSchemaFormCompatibility",
    "tpldata",
    "ajvOptions",
    "allErrors",
    "jsonPointers",
    "unknownFormats",
    "ajv",
    "Ajv",
    "validateFormData",
    "formGroupTemplate",
    "framework",
    "validData",
    "ajvErrors",
    "validationErrors",
    "dataErrors",
    "formValueSubscription",
    "dataChanges",
    "Subject",
    "isValidChanges",
    "validationErrorChanges",
    "defaultFormOptions",
    "pristine",
    "success",
    "supressPropertyTitles",
    "setLanguage",
    "language",
    "prototype",
    "getData",
    "getSchema",
    "getLayout",
    "resetAllValues",
    "buildRemoteError",
    "value_1",
    "value_1_1",
    "err",
    "setErrors",
    "emitEvent",
    "validateData",
    "updateSubscriptions",
    "compiledErrors",
    "dataPath",
    "message",
    "compileAjvSchema",
    "unsubscribe",
    "valueChanges",
    "subscribe",
    "formValue",
    "setOptions",
    "addOptions",
    "defaultOptions",
    "globalDefaults_1",
    "suffix",
    "Array",
    "removeSchema",
    "buildSchemaFromLayout",
    "setTpldata",
    "newTpldata",
    "parseText",
    "text",
    "values",
    "a",
    "parseExpression",
    "expression",
    "trim",
    "delim",
    "all",
    "term",
    "join",
    "setArrayItemTitle",
    "parentCtx",
    "childNode",
    "parentNode",
    "parentValues",
    "getFormControlValue",
    "isArrayItem",
    "childValue",
    "setItemTitle",
    "ctx",
    "toTitleCase",
    "getFormControlGroup",
    "dataIndex",
    "evaluateCondition",
    "arrayIndex",
    "result",
    "condition",
    "model",
    "functionBody",
    "Function",
    "dynFn",
    "initializeControl",
    "bind",
    "getFormControl",
    "boundControl",
    "controlName",
    "getFormControlName",
    "controlDisabled",
    "formatErrors",
    "showErrors",
    "validateOnRender",
    "statusChanges",
    "status",
    "errorMessage",
    "controlValue",
    "addSpaces",
    "string",
    "toUpperCase",
    "formatError",
    "errorKey",
    "errorProperty",
    "updateValue",
    "setValue",
    "markAsDirty",
    "targetControl",
    "updateArrayCheckboxList",
    "checkboxList",
    "formArray",
    "removeAt",
    "checkboxList_1",
    "checkboxList_1_1",
    "checkboxItem",
    "checked",
    "newFormControl",
    "getDataPointer",
    "getLayoutArray",
    "getParentNode",
    "getLayoutPointer",
    "layoutIndex",
    "isControlBound",
    "controlGroup",
    "addItem",
    "AddReferenceComponent",
    "ngOnInit",
    "defineProperty",
    "enumerable",
    "configurable",
    "event",
    "preventDefault",
    "parent",
    "itemCount",
    "decorators",
    "Component",
    "args",
    "selector",
    "propDecorators",
    "OneOfComponent",
    "target",
    "Input",
    "ButtonComponent",
    "onClick",
    "CheckboxComponent",
    "trueValue",
    "falseValue",
    "OrderableDirective",
    "elementRef",
    "ngZone",
    "overParentElement",
    "overChildElement",
    "element",
    "nativeElement",
    "draggable",
    "arrayLayoutIndex",
    "addEventListener",
    "sourceArrayIndex",
    "sessionStorage",
    "setItem",
    "dataTransfer",
    "dropEffect",
    "getItem",
    "classList",
    "destArrayIndex",
    "moveArrayItem",
    "removeItem",
    "ctorParameters",
    "NgZone",
    "CheckboxesComponent",
    "layoutOrientation",
    "formArray_1",
    "FileComponent",
    "InputComponent",
    "autoCompleteList",
    "MessageComponent",
    "help",
    "helpvalue",
    "msg",
    "NoneComponent",
    "NumberComponent",
    "allowNegative",
    "allowDecimal",
    "allowExponents",
    "lastValidNumber",
    "RadiosComponent",
    "radiosList",
    "RootComponent",
    "isFlexItem",
    "isDraggable",
    "node",
    "isOrderable",
    "getFlexAttribute",
    "attribute",
    "flex",
    "showWidget",
    "SectionComponent",
    "expanded",
    "notitle",
    "expandable",
    "containerType",
    "toggleExpanded",
    "flexActive",
    "displayFlex",
    "display",
    "SelectComponent",
    "selectList",
    "SelectFrameworkComponent",
    "componentFactory",
    "newComponent",
    "updateComponent",
    "ngOnChanges",
    "widgetContainer",
    "createComponent",
    "resolveComponentFactory",
    "instance",
    "SelectWidgetComponent",
    "SubmitComponent",
    "disableInvalidSubmit",
    "TabsComponent",
    "selectedItem",
    "showAddTab",
    "updateControl",
    "select",
    "lastItem",
    "setTabTitle",
    "TemplateComponent",
    "TextareaComponent",
    "WidgetLibraryService",
    "defaultWidget",
    "number",
    "password",
    "search",
    "tel",
    "datetime",
    "datetime-local",
    "month",
    "range",
    "hidden",
    "radio",
    "button",
    "updown",
    "alt-datetime",
    "textline",
    "registeredWidgets",
    "frameworkWidgets",
    "activeWidgets",
    "setActiveWidgets",
    "widgetName",
    "usedAliases",
    "setDefaultWidget",
    "widgetSet",
    "hasDefaultWidget",
    "registerWidget",
    "unRegisterWidget",
    "unRegisterAllWidgets",
    "unRegisterFrameworkWidgets",
    "registerFrameworkWidgets",
    "widgets",
    "Framework",
    "stylesheets",
    "scripts",
    "FrameworkLibraryService",
    "frameworks",
    "activeFramework",
    "loadExternalAssets",
    "frameworkLibrary",
    "defaultFramework",
    "setFramework",
    "setLoadExternalAssets",
    "hasFramework",
    "getFramework",
    "getFrameworkWidgets",
    "getFrameworkStylesheets",
    "load",
    "getFrameworkScripts",
    "JSON_SCHEMA_FORM_VALUE_ACCESSOR",
    "useExisting",
    "forwardRef",
    "JsonSchemaFormComponent",
    "multi",
    "changeDetector",
    "sanitizer",
    "formInitialized",
    "objectWrap",
    "previousInputs",
    "form",
    "JSONSchema",
    "UISchema",
    "debug",
    "onChanges",
    "EventEmitter",
    "formSchema",
    "dataChange",
    "modelChange",
    "formDataChange",
    "ngModelChange",
    "setFormValues",
    "bypassSecurityTrustResourceUrl",
    "stylesheet",
    "script",
    "updateForm",
    "writeValue",
    "formValuesInput",
    "registerOnChange",
    "onChange",
    "registerOnTouched",
    "onTouched",
    "setDisabledState",
    "isDisabled",
    "formDisabled",
    "initializeForm",
    "changedInput",
    "resetFirst",
    "startsWith",
    "newFormValues",
    "reset",
    "activateForm",
    "patchValue",
    "debugOutput",
    "JSON",
    "stringify",
    "initializeOptions",
    "initializeSchema",
    "1",
    "convertSchemaToDraft6",
    "draft",
    "changed",
    "simpleTypes",
    "contentEncoding",
    "media",
    "binaryEncoding",
    "extends",
    "disallow",
    "maxDecimal",
    "pow",
    "divisibleBy",
    "minimumCanEqual",
    "maximumCanEqual",
    "properties_1",
    "optional",
    "requiredKeys_1",
    "size",
    "requires",
    "dependencies_1",
    "id",
    "$id",
    "addToDescription",
    "description",
    "arrayKeys",
    "numberKeys",
    "objectKeys",
    "stringKeys",
    "filterKeys_1",
    "newType",
    "typeSchema",
    "newKey_1",
    "refLinks",
    "refMapSet",
    "refMap",
    "refLibrary",
    "subSchemaPointer",
    "ref",
    "checkRefLinks",
    "from",
    "fromRef2",
    "toRef2",
    "toRef1",
    "fromRef1",
    "refLink",
    "fromRef",
    "toRef",
    "compiledSchema",
    "definitions",
    "fromDataRef",
    "toDataRef",
    "initializeData",
    "ngModel",
    "initializeLayout",
    "fixJsonFormOptions",
    "alternateLayout",
    "uiSchema",
    "customFormItems",
    "itemPointer",
    "emit",
    "markForCheck",
    "validateOnRender_1",
    "markAsTouched",
    "touchAll_1",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "providers",
    "ChangeDetectorRef",
    "DomSanitizer",
    "HiddenComponent",
    "TabComponent",
    "BASIC_WIDGETS",
    "WidgetLibraryModule",
    "forRoot",
    "ngModule",
    "NgModule",
    "imports",
    "CommonModule",
    "FormsModule",
    "ReactiveFormsModule",
    "NoFrameworkComponent",
    "NoFramework",
    "_super",
    "NoFrameworkModule",
    "provide",
    "useClass",
    "JsonSchemaFormModule",
    "loadFrameworks"
  ],
  "mappings": "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"
}
